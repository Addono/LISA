{"version":3,"file":"svg-points-to-cubic-bezier.min.js","sources":["../src/index.js"],"sourcesContent":["const TAU = Math.PI * 2\n\nconst mapToEllipse = ({ x, y }, rx, ry, cosphi, sinphi, centerx, centery) => {\n  x *= rx\n  y *= ry\n\n  const xp = cosphi * x - sinphi * y\n  const yp = sinphi * x + cosphi * y\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  }\n}\n\nconst approxUnitArc = (ang1, ang2) => {\n  // See http://spencermortensen.com/articles/bezier-circle/ for the derivation\n  // of this constant.\n  const c = 0.551915024494\n\n  const x1 = Math.cos(ang1)\n  const y1 = Math.sin(ang1)\n  const x2 = Math.cos(ang1 + ang2)\n  const y2 = Math.sin(ang1 + ang2)\n\n  return [\n    {\n      x: x1 - y1 * c,\n      y: y1 + x1 * c\n    },\n    {\n      x: x2 + y2 * c,\n      y: y2 - x2 * c\n    },\n    {\n      x: x2,\n      y: y2\n    }\n  ]\n}\n\nconst vectorAngle = (ux, uy, vx, vy) => {\n  const sign = (ux * vy - uy * vx < 0) ? -1 : 1\n  const umag = Math.sqrt(ux * ux + uy * uy)\n  const vmag = Math.sqrt(ux * ux + uy * uy)\n  const dot = ux * vx + uy * vy\n\n  let div = dot / (umag * vmag)\n\n  if (div > 1) {\n    div = 1\n  }\n\n  if (div < -1) {\n    div = -1\n  }\n\n  return sign * Math.acos(div)\n}\n\nconst getArcCenter = (\n  px,\n  py,\n  cx,\n  cy,\n  rx,\n  ry,\n  largeArcFlag,\n  sweepFlag,\n  sinphi,\n  cosphi,\n  pxp,\n  pyp\n) => {\n  const rxsq = Math.pow(rx, 2)\n  const rysq = Math.pow(ry, 2)\n  const pxpsq = Math.pow(pxp, 2)\n  const pypsq = Math.pow(pyp, 2)\n\n  let radicant = (rxsq * rysq) - (rxsq * pypsq) - (rysq * pxpsq)\n\n  if (radicant < 0) {\n    radicant = 0\n  }\n\n  radicant /= (rxsq * pypsq) + (rysq * pxpsq)\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1)\n\n  const centerxp = radicant * rx / ry * pyp\n  const centeryp = radicant * -ry / rx * pxp\n\n  const centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2\n  const centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2\n\n  const vx1 = (pxp - centerxp) / rx\n  const vy1 = (pyp - centeryp) / ry\n  const vx2 = (-pxp - centerxp) / rx\n  const vy2 = (-pyp - centeryp) / ry\n\n  let ang1 = vectorAngle(1, 0, vx1, vy1)\n  let ang2 = vectorAngle(vx1, vy1, vx2, vy2)\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU\n  }\n\n  return [ centerx, centery, ang1, ang2 ]\n}\n\nconst arcToBezier = ({\n  px,\n  py,\n  cx,\n  cy,\n  rx,\n  ry,\n  xAxisRotation = 0,\n  largeArcFlag = 0,\n  sweepFlag = 0\n}) => {\n  const curves = []\n\n  if (rx === 0 || ry === 0) {\n    return []\n  }\n\n  const sinphi = Math.sin(xAxisRotation * TAU / 360)\n  const cosphi = Math.cos(xAxisRotation * TAU / 360)\n\n  const pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2\n  const pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2\n\n  if (pxp === 0 && pyp === 0) {\n    return []\n  }\n\n  rx = Math.abs(rx)\n  ry = Math.abs(ry)\n\n  const lambda =\n    Math.pow(pxp, 2) / Math.pow(rx, 2) +\n    Math.pow(pyp, 2) / Math.pow(ry, 2)\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda)\n    ry *= Math.sqrt(lambda)\n  }\n\n  let [ centerx, centery, ang1, ang2 ] = getArcCenter(\n    px,\n    py,\n    cx,\n    cy,\n    rx,\n    ry,\n    largeArcFlag,\n    sweepFlag,\n    sinphi,\n    cosphi,\n    pxp,\n    pyp\n  )\n\n  const segments = Math.max(Math.ceil(Math.abs(ang2) / (TAU / 4)), 1)\n\n  ang2 /= segments\n\n  for (let i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2))\n    ang1 += ang2\n  }\n\n  return curves.map(curve => {\n    const { x: x1, y: y1 } = mapToEllipse(curve[ 0 ], rx, ry, cosphi, sinphi, centerx, centery)\n    const { x: x2, y: y2 } = mapToEllipse(curve[ 1 ], rx, ry, cosphi, sinphi, centerx, centery)\n    const { x, y } = mapToEllipse(curve[ 2 ], rx, ry, cosphi, sinphi, centerx, centery)\n\n    return { x1, y1, x2, y2, x, y }\n  })\n}\n\nexport default arcToBezier\n"],"names":["TAU","Math","PI","mapToEllipse","rx","ry","cosphi","sinphi","centerx","centery","x","y","approxUnitArc","ang1","ang2","c","x1","cos","y1","sin","x2","y2","vectorAngle","ux","uy","vx","vy","sign","div","sqrt","acos","getArcCenter","px","py","cx","cy","largeArcFlag","sweepFlag","pxp","pyp","rxsq","pow","rysq","pxpsq","pypsq","radicant","centerxp","centeryp","vx1","vy1","vx2","vy2","xAxisRotation","curves","abs","lambda","segments","max","ceil","i","push","map","curve"],"mappings":"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"}