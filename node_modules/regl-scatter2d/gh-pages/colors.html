<!DOCTYPE html>
<html>
<head>
<title>regl-scatter2d</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta charset=utf-8><meta name="application-name" content="regl-scatter2d">
<meta name="subject" content="Scatter2d plot built with regl">
<meta name="abstract" content="Scatter2d plot built with regl">
<meta name="twitter:title" content="regl-scatter2d">
<meta name="description" content="Scatter2d plot built with regl">
<meta name="twitter:description" content="Scatter2d plot built with regl">
<meta name="author" content="Dima Yv &lt;df.creative@gmail.com&gt;">
<meta name="twitter:creator" content="Dima Yv &lt;df.creative@gmail.com&gt;">
<meta name="twitter:card" content="summary">
<meta property="og:title" content="regl-scatter2d">
<meta property="og:description" content="Scatter2d plot built with regl">
<meta property="article:author" content="Dima Yv &lt;df.creative@gmail.com&gt;">
<style type="text/css">.github-corner{display:block;position:absolute;top:0;left:auto;right:0;z-index:10000}.github-corner svg{display:block}.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%{transform:rotate(0)}20%{transform:rotate(-25deg)}40%{transform:rotate(10deg)}60%{transform:rotate(-25deg)}80%{transform:rotate(10deg)}100%{transform:rotate(0)}}@media(max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></head>
<body><a href="https://github.com/dy/regl-scatter2d" class="github-corner" aria-label="View source on Github"><svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 250 250" fill="#fff">
  <path d="M0 0l115 115h15l12 27 108 108V0z" fill="#333"/>
  <path class="octo-arm" d="M128 109c-15-9-9-19-9-19 3-7 2-11 2-11-1-7 3-2 3-2 4 5 2 11 2 11-3 10 5 15 9 16" style="-webkit-transform-origin: 130px 106px; transform-origin: 130px 106px"/>
  <path class="octo-body" d="M115 115s4 2 5 0l14-14c3-2 6-3 8-3-8-11-15-24 2-41 5-5 10-7 16-7 1-2 3-7 12-11 0 0 5 3 7 16 4 2 8 5 12 9s7 8 9 12c14 3 17 7 17 7-4 8-9 11-11 11 0 6-2 11-7 16-16 16-30 10-41 2 0 3-1 7-5 11l-12 11c-1 1 1 5 1 5z"/>
</svg>
</a></body>
<script>
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @module  point-cluster
 */

'use strict';

var kdtree = require('kdgrass');
var extend = require('object-assign');
var clamp = require('clamp');
var getBounds = require('array-bounds');
var snap = require('snap-points-2d');

module.exports = pointCluster;

function pointCluster(points) {
    var tree = kdtree(points, 1);
    var dataBounds = getBounds(points, 2);

    return cluster;

    //returns points belonging to certain scale (that is kdtree level)
    function cluster(dist, bounds) {
        if (!bounds) bounds = dataBounds;

        var result = [];
        var r = dist / 2,
            r2 = r * r,
            pr2 = Math.PI * r2;
        var box = dataBounds.slice();

        let maxDepth = 25;
        getPoints(tree, 0, tree.ids.length - 1, 0, box, 0);

        function getPoints(tree, from, to, axis, box, depth) {
            var coords = tree.coords,
                ids = tree.ids,
                nodeSize = tree.nodeSize;
            var range = to - from;
            //median
            var m = Math.floor((from + to) / 2);

            //if bottom reached - include every point
            if (range <= nodeSize) {
                // for (var id = from; id <= to; id++) {
                // var x = coords[2 * id];
                // var y = coords[2 * id + 1];
                // if (x >= bounds[0] && x <= bounds[2] && y >= bounds[1] && y <= bounds[3])
                // addPoint(id)
                // }
                // addPoint(m)
                //pick single random from the range
                // var id = Math.floor(Math.random() * (from - to) + from)
                return;
            }

            var x = coords[2 * m];
            var y = coords[2 * m + 1];
            result.push(ids[m]);

            //if required radius larger than cluster span - exit
            if (sq(box) <= pr2) {
                //TODO: mark points belonging to radius as covered
                return;
            }

            // if (x >= bounds[0] && x <= bounds[2] && y >= bounds[1] && y <= bounds[3]) {
            // var id = Math.floor(Math.random() * range + from)
            // result.push(ids[m]);
            // }

            //go deeper
            axis = (axis + 1) % 2;
            depth++;

            if (depth <= maxDepth) {
                getPoints(tree, from, m - 1, axis, [box[0], box[1], axis ? x : box[2], axis ? box[3] : y], depth);
                getPoints(tree, m + 1, to, axis, [axis ? x : box[0], axis ? box[1] : y, box[2], box[3]], depth);
            } else {
                throw 'Max depth reached';
            }
        }

        return result;
    }

    function sq(box) {
        var dx = box[2] - box[0];
        var dy = box[3] - box[1];
        return dx * dy;
    }

    function maxDist(box) {
        var max = Math.max(box[2] - box[0], box[3] - box[1]);
        return max * max;
    }

    function sqDist(box) {
        var dx = box[2] - box[0];
        var dy = box[3] - box[1];
        return dx * dx + dy * dy;
    }

    //get points covering the area with defined radius
    function cover(radius) {
        var result = [];

        //TODO: in order to reduce scale search, we can limit radius by known data bounds
        //TODO: point radius may vary for different points, so take that in account, like id => r

        //object is way faster than Set for .has testing on big number of items
        var marked = {};
        var ids = tree.ids;

        for (var i = 0, l = ids.length; i < l; i++) {
            var id = ids[i];

            // if we've already visited the point at this zoom level, skip it
            if (marked[id]) {
                continue;
            }
            marked[id] = true;

            var x = points[id * 2];
            var y = points[id * 2 + 1];

            // exclude neighbours from processing
            var neighborIds = tree.within(x, y, radius);
            // var neighborIds = tree.range(x-r, y-r, x+r, y+r);

            for (var j = 0; j < neighborIds.length; j++) {
                var b = neighborIds[j];
                if (marked[b]) {
                    continue;
                }
                marked[b] = true;
            }

            // put point for the level
            result.push(id);
        }

        return result;
    }
}

},{"array-bounds":2,"clamp":4,"kdgrass":6,"object-assign":7,"snap-points-2d":9}],2:[function(require,module,exports){
'use strict';

module.exports = normalize;

function normalize(arr, dim) {
	if (!arr || arr.length == null) throw Error('Argument should be an array');

	if (dim == null) dim = 1;else dim = Math.floor(dim);

	var bounds = Array(dim * 2);

	for (var offset = 0; offset < dim; offset++) {
		var max = -Infinity,
		    min = Infinity,
		    i = offset,
		    l = arr.length;

		for (; i < l; i += dim) {
			if (arr[i] > max) max = arr[i];
			if (arr[i] < min) min = arr[i];
		}

		bounds[offset] = min;
		bounds[dim + offset] = max;
	}

	return bounds;
}

},{}],3:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict";"use restrict";

//Number of bits in an integer

var INT_BITS = 32;

//Constants
exports.INT_BITS = INT_BITS;
exports.INT_MAX = 0x7fffffff;
exports.INT_MIN = -1 << INT_BITS - 1;

//Returns -1, 0, +1 depending on sign of x
exports.sign = function (v) {
  return (v > 0) - (v < 0);
};

//Computes absolute value of integer
exports.abs = function (v) {
  var mask = v >> INT_BITS - 1;
  return (v ^ mask) - mask;
};

//Computes minimum of integers x and y
exports.min = function (x, y) {
  return y ^ (x ^ y) & -(x < y);
};

//Computes maximum of integers x and y
exports.max = function (x, y) {
  return x ^ (x ^ y) & -(x < y);
};

//Checks if a number is a power of two
exports.isPow2 = function (v) {
  return !(v & v - 1) && !!v;
};

//Computes log base 2 of v
exports.log2 = function (v) {
  var r, shift;
  r = (v > 0xFFFF) << 4;v >>>= r;
  shift = (v > 0xFF) << 3;v >>>= shift;r |= shift;
  shift = (v > 0xF) << 2;v >>>= shift;r |= shift;
  shift = (v > 0x3) << 1;v >>>= shift;r |= shift;
  return r | v >> 1;
};

//Computes log base 10 of v
exports.log10 = function (v) {
  return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
};

//Counts number of bits
exports.popCount = function (v) {
  v = v - (v >>> 1 & 0x55555555);
  v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
  return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
};

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function (v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
};

//Rounds down to previous power of 2
exports.prevPow2 = function (v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v >>> 1);
};

//Computes parity of word
exports.parity = function (v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return 0x6996 >>> v & 1;
};

var REVERSE_TABLE = new Array(256);

(function (tab) {
  for (var i = 0; i < 256; ++i) {
    var v = i,
        r = i,
        s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = r << s & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function (v) {
  return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
};

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function (x, y) {
  x &= 0xFFFF;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;

  y &= 0xFFFF;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;

  return x | y << 1;
};

//Extracts the nth interleaved component
exports.deinterleave2 = function (v, n) {
  v = v >>> n & 0x55555555;
  v = (v | v >>> 1) & 0x33333333;
  v = (v | v >>> 2) & 0x0F0F0F0F;
  v = (v | v >>> 4) & 0x00FF00FF;
  v = (v | v >>> 16) & 0x000FFFF;
  return v << 16 >> 16;
};

//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function (x, y, z) {
  x &= 0x3FF;
  x = (x | x << 16) & 4278190335;
  x = (x | x << 8) & 251719695;
  x = (x | x << 4) & 3272356035;
  x = (x | x << 2) & 1227133513;

  y &= 0x3FF;
  y = (y | y << 16) & 4278190335;
  y = (y | y << 8) & 251719695;
  y = (y | y << 4) & 3272356035;
  y = (y | y << 2) & 1227133513;
  x |= y << 1;

  z &= 0x3FF;
  z = (z | z << 16) & 4278190335;
  z = (z | z << 8) & 251719695;
  z = (z | z << 4) & 3272356035;
  z = (z | z << 2) & 1227133513;

  return x | z << 2;
};

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function (v, n) {
  v = v >>> n & 1227133513;
  v = (v | v >>> 2) & 3272356035;
  v = (v | v >>> 4) & 251719695;
  v = (v | v >>> 8) & 4278190335;
  v = (v | v >>> 16) & 0x3FF;
  return v << 22 >> 22;
};

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function (v) {
  var t = v | v - 1;
  return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
};

},{}],4:[function(require,module,exports){
module.exports = clamp;

function clamp(value, min, max) {
  return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
}

},{}],5:[function(require,module,exports){
"use strict";

function dupe_array(count, value, i) {
  var c = count[i] | 0;
  if (c <= 0) {
    return [];
  }
  var result = new Array(c),
      j;
  if (i === count.length - 1) {
    for (j = 0; j < c; ++j) {
      result[j] = value;
    }
  } else {
    for (j = 0; j < c; ++j) {
      result[j] = dupe_array(count, value, i + 1);
    }
  }
  return result;
}

function dupe_number(count, value) {
  var result, i;
  result = new Array(count);
  for (i = 0; i < count; ++i) {
    result[i] = value;
  }
  return result;
}

function dupe(count, value) {
  if (typeof value === "undefined") {
    value = 0;
  }
  switch (typeof count) {
    case "number":
      if (count > 0) {
        return dupe_number(count | 0, value);
      }
      break;
    case "object":
      if (typeof count.length === "number") {
        return dupe_array(count, value, 0);
      }
      break;
  }
  return [];
}

module.exports = dupe;

},{}],6:[function(require,module,exports){
/**
 * @module  kdgrass
 *
 * Static kdbush
 */

'use strict';

module.exports = KDTree;

//optimized kdbush
function KDTree(points, nodeSize) {
    if (!(this instanceof KDTree)) return new KDTree(points, nodeSize);

    this.nodeSize = nodeSize || 64;

    this.coords = points.slice();

    var l = Math.floor(points.length / 2);
    this.ids = Array(l);

    for (var i = 0; i < l; i++) {
        this.ids[i] = i;
    }

    sortKD(this.ids, this.coords, this.nodeSize, 0, this.ids.length - 1, 0);
}

KDTree.prototype.range = function range(minX, minY, maxX, maxY) {
    var ids = this.ids,
        coords = this.coords,
        nodeSize = this.nodeSize;
    var stack = [0, ids.length - 1, 0];
    var result = [];
    var x, y;

    while (stack.length) {
        var axis = stack.pop();
        var right = stack.pop();
        var left = stack.pop();

        if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
                x = coords[2 * i];
                y = coords[2 * i + 1];
                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);
            }
            continue;
        }

        var m = Math.floor((left + right) / 2);

        x = coords[2 * m];
        y = coords[2 * m + 1];

        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);

        var nextAxis = (axis + 1) % 2;

        if (axis === 0 ? minX <= x : minY <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? maxX >= x : maxY >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
};

KDTree.prototype.within = function within(qx, qy, r) {
    var ids = this.ids,
        coords = this.coords,
        nodeSize = this.nodeSize;
    var stack = [0, ids.length - 1, 0];
    var result = [];
    var r2 = r * r;

    while (stack.length) {
        var axis = stack.pop();
        var right = stack.pop();
        var left = stack.pop();

        if (right - left <= nodeSize) {
            for (var i = left; i <= right; i++) {
                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
            }
            continue;
        }

        var m = Math.floor((left + right) / 2);

        var x = coords[2 * m];
        var y = coords[2 * m + 1];

        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);

        var nextAxis = (axis + 1) % 2;

        if (axis === 0 ? qx - r <= x : qy - r <= y) {
            stack.push(left);
            stack.push(m - 1);
            stack.push(nextAxis);
        }
        if (axis === 0 ? qx + r >= x : qy + r >= y) {
            stack.push(m + 1);
            stack.push(right);
            stack.push(nextAxis);
        }
    }

    return result;
};

function sqDist(ax, ay, bx, by) {
    var dx = ax - bx;
    var dy = ay - by;
    return dx * dx + dy * dy;
}

function sortKD(ids, coords, nodeSize, left, right, depth) {
    if (right - left <= nodeSize) return;

    var m = Math.floor((left + right) / 2);

    select(ids, coords, m, left, right, depth % 2);

    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);
    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);
}

function select(ids, coords, k, left, right, inc) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            select(ids, coords, k, newLeft, newRight, inc);
        }

        var t = coords[2 * k + inc];
        var i = left;
        var j = right;

        swapItem(ids, coords, left, k);
        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);

        while (i < j) {
            swapItem(ids, coords, i, j);
            i++;
            j--;
            while (coords[2 * i + inc] < t) i++;
            while (coords[2 * j + inc] > t) j--;
        }

        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);else {
            j++;
            swapItem(ids, coords, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swapItem(ids, coords, i, j) {
    swap(ids, i, j);
    swap(coords, 2 * i, 2 * j);
    swap(coords, 2 * i + 1, 2 * j + 1);
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

},{}],7:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],8:[function(require,module,exports){
'use strict';

module.exports = sortLevels;

var INSERT_SORT_CUTOFF = 32;

function sortLevels(data_levels, data_points, data_ids, data_weights, n0) {
  if (n0 <= 4 * INSERT_SORT_CUTOFF) {
    insertionSort(0, n0 - 1, data_levels, data_points, data_ids, data_weights);
  } else {
    quickSort(0, n0 - 1, data_levels, data_points, data_ids, data_weights);
  }
}

function insertionSort(left, right, data_levels, data_points, data_ids, data_weights) {
  for (var i = left + 1; i <= right; ++i) {
    var a_level = data_levels[i];
    var a_x = data_points[2 * i];
    var a_y = data_points[2 * i + 1];
    var a_id = data_ids[i];
    var a_weight = data_weights[i];

    var j = i;
    while (j > left) {
      var b_level = data_levels[j - 1];
      var b_x = data_points[2 * (j - 1)];
      if ((b_level - a_level || a_x - b_x) >= 0) {
        break;
      }
      data_levels[j] = b_level;
      data_points[2 * j] = b_x;
      data_points[2 * j + 1] = data_points[2 * j - 1];
      data_ids[j] = data_ids[j - 1];
      data_weights[j] = data_weights[j - 1];
      j -= 1;
    }

    data_levels[j] = a_level;
    data_points[2 * j] = a_x;
    data_points[2 * j + 1] = a_y;
    data_ids[j] = a_id;
    data_weights[j] = a_weight;
  }
}

function swap(i, j, data_levels, data_points, data_ids, data_weights) {
  var a_level = data_levels[i];
  var a_x = data_points[2 * i];
  var a_y = data_points[2 * i + 1];
  var a_id = data_ids[i];
  var a_weight = data_weights[i];

  data_levels[i] = data_levels[j];
  data_points[2 * i] = data_points[2 * j];
  data_points[2 * i + 1] = data_points[2 * j + 1];
  data_ids[i] = data_ids[j];
  data_weights[i] = data_weights[j];

  data_levels[j] = a_level;
  data_points[2 * j] = a_x;
  data_points[2 * j + 1] = a_y;
  data_ids[j] = a_id;
  data_weights[j] = a_weight;
}

function move(i, j, data_levels, data_points, data_ids, data_weights) {
  data_levels[i] = data_levels[j];
  data_points[2 * i] = data_points[2 * j];
  data_points[2 * i + 1] = data_points[2 * j + 1];
  data_ids[i] = data_ids[j];
  data_weights[i] = data_weights[j];
}

function rotate(i, j, k, data_levels, data_points, data_ids, data_weights) {
  var a_level = data_levels[i];
  var a_x = data_points[2 * i];
  var a_y = data_points[2 * i + 1];
  var a_id = data_ids[i];
  var a_weight = data_weights[i];

  data_levels[i] = data_levels[j];
  data_points[2 * i] = data_points[2 * j];
  data_points[2 * i + 1] = data_points[2 * j + 1];
  data_ids[i] = data_ids[j];
  data_weights[i] = data_weights[j];

  data_levels[j] = data_levels[k];
  data_points[2 * j] = data_points[2 * k];
  data_points[2 * j + 1] = data_points[2 * k + 1];
  data_ids[j] = data_ids[k];
  data_weights[j] = data_weights[k];

  data_levels[k] = a_level;
  data_points[2 * k] = a_x;
  data_points[2 * k + 1] = a_y;
  data_ids[k] = a_id;
  data_weights[k] = a_weight;
}

function shufflePivot(i, j, a_level, a_x, a_y, a_id, a_weight, data_levels, data_points, data_ids, data_weights) {

  data_levels[i] = data_levels[j];
  data_points[2 * i] = data_points[2 * j];
  data_points[2 * i + 1] = data_points[2 * j + 1];
  data_ids[i] = data_ids[j];
  data_weights[i] = data_weights[j];

  data_levels[j] = a_level;
  data_points[2 * j] = a_x;
  data_points[2 * j + 1] = a_y;
  data_ids[j] = a_id;
  data_weights[j] = a_weight;
}

function compare(i, j, data_levels, data_points, data_ids) {
  return (data_levels[i] - data_levels[j] || data_points[2 * j] - data_points[2 * i] || data_ids[i] - data_ids[j]) < 0;
}

function comparePivot(i, level, x, y, id, data_levels, data_points, data_ids) {
  return (level - data_levels[i] || data_points[2 * i] - x || id - data_ids[i]) < 0;
}

function quickSort(left, right, data_levels, data_points, data_ids, data_weights) {
  var sixth = (right - left + 1) / 6 | 0,
      index1 = left + sixth,
      index5 = right - sixth,
      index3 = left + right >> 1,
      index2 = index3 - sixth,
      index4 = index3 + sixth,
      el1 = index1,
      el2 = index2,
      el3 = index3,
      el4 = index4,
      el5 = index5,
      less = left + 1,
      great = right - 1,
      tmp = 0;
  if (compare(el1, el2, data_levels, data_points, data_ids, data_weights)) {
    tmp = el1;
    el1 = el2;
    el2 = tmp;
  }
  if (compare(el4, el5, data_levels, data_points, data_ids, data_weights)) {
    tmp = el4;
    el4 = el5;
    el5 = tmp;
  }
  if (compare(el1, el3, data_levels, data_points, data_ids, data_weights)) {
    tmp = el1;
    el1 = el3;
    el3 = tmp;
  }
  if (compare(el2, el3, data_levels, data_points, data_ids, data_weights)) {
    tmp = el2;
    el2 = el3;
    el3 = tmp;
  }
  if (compare(el1, el4, data_levels, data_points, data_ids, data_weights)) {
    tmp = el1;
    el1 = el4;
    el4 = tmp;
  }
  if (compare(el3, el4, data_levels, data_points, data_ids, data_weights)) {
    tmp = el3;
    el3 = el4;
    el4 = tmp;
  }
  if (compare(el2, el5, data_levels, data_points, data_ids, data_weights)) {
    tmp = el2;
    el2 = el5;
    el5 = tmp;
  }
  if (compare(el2, el3, data_levels, data_points, data_ids, data_weights)) {
    tmp = el2;
    el2 = el3;
    el3 = tmp;
  }
  if (compare(el4, el5, data_levels, data_points, data_ids, data_weights)) {
    tmp = el4;
    el4 = el5;
    el5 = tmp;
  }

  var pivot1_level = data_levels[el2];
  var pivot1_x = data_points[2 * el2];
  var pivot1_y = data_points[2 * el2 + 1];
  var pivot1_id = data_ids[el2];
  var pivot1_weight = data_weights[el2];

  var pivot2_level = data_levels[el4];
  var pivot2_x = data_points[2 * el4];
  var pivot2_y = data_points[2 * el4 + 1];
  var pivot2_id = data_ids[el4];
  var pivot2_weight = data_weights[el4];

  var ptr0 = el1;
  var ptr2 = el3;
  var ptr4 = el5;
  var ptr5 = index1;
  var ptr6 = index3;
  var ptr7 = index5;

  var level_x = data_levels[ptr0];
  var level_y = data_levels[ptr2];
  var level_z = data_levels[ptr4];
  data_levels[ptr5] = level_x;
  data_levels[ptr6] = level_y;
  data_levels[ptr7] = level_z;

  for (var i1 = 0; i1 < 2; ++i1) {
    var x = data_points[2 * ptr0 + i1];
    var y = data_points[2 * ptr2 + i1];
    var z = data_points[2 * ptr4 + i1];
    data_points[2 * ptr5 + i1] = x;
    data_points[2 * ptr6 + i1] = y;
    data_points[2 * ptr7 + i1] = z;
  }

  var id_x = data_ids[ptr0];
  var id_y = data_ids[ptr2];
  var id_z = data_ids[ptr4];
  data_ids[ptr5] = id_x;
  data_ids[ptr6] = id_y;
  data_ids[ptr7] = id_z;

  var weight_x = data_weights[ptr0];
  var weight_y = data_weights[ptr2];
  var weight_z = data_weights[ptr4];
  data_weights[ptr5] = weight_x;
  data_weights[ptr6] = weight_y;
  data_weights[ptr7] = weight_z;

  move(index2, left, data_levels, data_points, data_ids, data_weights);
  move(index4, right, data_levels, data_points, data_ids, data_weights);
  for (var k = less; k <= great; ++k) {
    if (comparePivot(k, pivot1_level, pivot1_x, pivot1_y, pivot1_id, data_levels, data_points, data_ids)) {
      if (k !== less) {
        swap(k, less, data_levels, data_points, data_ids, data_weights);
      }
      ++less;
    } else {
      if (!comparePivot(k, pivot2_level, pivot2_x, pivot2_y, pivot2_id, data_levels, data_points, data_ids)) {
        while (true) {
          if (!comparePivot(great, pivot2_level, pivot2_x, pivot2_y, pivot2_id, data_levels, data_points, data_ids)) {
            if (--great < k) {
              break;
            }
            continue;
          } else {
            if (comparePivot(great, pivot1_level, pivot1_x, pivot1_y, pivot1_id, data_levels, data_points, data_ids)) {
              rotate(k, less, great, data_levels, data_points, data_ids, data_weights);
              ++less;
              --great;
            } else {
              swap(k, great, data_levels, data_points, data_ids, data_weights);
              --great;
            }
            break;
          }
        }
      }
    }
  }
  shufflePivot(left, less - 1, pivot1_level, pivot1_x, pivot1_y, pivot1_id, pivot1_weight, data_levels, data_points, data_ids, data_weights);
  shufflePivot(right, great + 1, pivot2_level, pivot2_x, pivot2_y, pivot2_id, pivot2_weight, data_levels, data_points, data_ids, data_weights);
  if (less - 2 - left <= INSERT_SORT_CUTOFF) {
    insertionSort(left, less - 2, data_levels, data_points, data_ids, data_weights);
  } else {
    quickSort(left, less - 2, data_levels, data_points, data_ids, data_weights);
  }
  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
    insertionSort(great + 2, right, data_levels, data_points, data_ids, data_weights);
  } else {
    quickSort(great + 2, right, data_levels, data_points, data_ids, data_weights);
  }
  if (great - less <= INSERT_SORT_CUTOFF) {
    insertionSort(less, great, data_levels, data_points, data_ids, data_weights);
  } else {
    quickSort(less, great, data_levels, data_points, data_ids, data_weights);
  }
}

},{}],9:[function(require,module,exports){
'use strict';

var pool = require('typedarray-pool');

var sortLevels = require('./lib/sort');

module.exports = snapPoints;

function partition(points, ids, start, end, lox, loy, hix, hiy) {
  var mid = start;
  for (var i = start; i < end; ++i) {
    var x = points[2 * i];
    var y = points[2 * i + 1];
    var s = ids[i];
    if (lox <= x && x <= hix && loy <= y && y <= hiy) {
      if (i === mid) {
        mid += 1;
      } else {
        points[2 * i] = points[2 * mid];
        points[2 * i + 1] = points[2 * mid + 1];
        ids[i] = ids[mid];
        points[2 * mid] = x;
        points[2 * mid + 1] = y;
        ids[mid] = s;
        mid += 1;
      }
    }
  }
  return mid;
}

function SnapInterval(pixelSize, offset, count) {
  this.pixelSize = pixelSize;
  this.offset = offset;
  this.count = count;
}

function snapPoints(points, ids, weights, bounds) {
  var n = points.length >>> 1;
  if (n < 1) {
    return [];
  }

  var lox = Infinity,
      loy = Infinity;
  var hix = -Infinity,
      hiy = -Infinity;
  for (var i = 0; i < n; ++i) {
    var x = points[2 * i];
    var y = points[2 * i + 1];
    lox = Math.min(lox, x);
    hix = Math.max(hix, x);
    loy = Math.min(loy, y);
    hiy = Math.max(hiy, y);
    ids[i] = i;
  }

  if (lox === hix) {
    hix += 1 + Math.abs(hix);
  }
  if (loy === hiy) {
    hiy += 1 + Math.abs(hix);
  }

  //Calculate diameter
  var scaleX = 1.0 / (hix - lox);
  var scaleY = 1.0 / (hiy - loy);
  var diam = Math.max(hix - lox, hiy - loy);

  bounds = bounds || [0, 0, 0, 0];

  bounds[0] = lox;
  bounds[1] = loy;
  bounds[2] = hix;
  bounds[3] = hiy;

  var levels = pool.mallocInt32(n);
  var ptr = 0;

  function snapRec(x, y, diam, start, end, level) {
    var diam_2 = diam * 0.5;
    var offset = start + 1;
    var count = end - start;
    weights[ptr] = count;
    levels[ptr++] = level;
    for (var i = 0; i < 2; ++i) {
      for (var j = 0; j < 2; ++j) {
        var nx = x + i * diam_2;
        var ny = y + j * diam_2;
        var nextOffset = partition(points, ids, offset, end, nx, ny, nx + diam_2, ny + diam_2);
        if (nextOffset === offset) {
          continue;
        }
        if (nextOffset - offset >= Math.max(0.9 * count, 32)) {
          var mid = end + start >>> 1;
          snapRec(nx, ny, diam_2, offset, mid, level + 1);
          offset = mid;
        }
        snapRec(nx, ny, diam_2, offset, nextOffset, level + 1);
        offset = nextOffset;
      }
    }
  }
  snapRec(lox, loy, diam, 0, n, 0);
  sortLevels(levels, points, ids, weights, n);

  var lod = [];
  var lastLevel = 0;
  var prevOffset = n;
  for (var ptr = n - 1; ptr >= 0; --ptr) {
    points[2 * ptr] = (points[2 * ptr] - lox) * scaleX;
    points[2 * ptr + 1] = (points[2 * ptr + 1] - loy) * scaleY;

    var level = levels[ptr];
    if (level === lastLevel) {
      continue;
    }

    lod.push(new SnapInterval(diam * Math.pow(0.5, level), ptr + 1, prevOffset - (ptr + 1)));
    prevOffset = ptr + 1;

    lastLevel = level;
  }

  lod.push(new SnapInterval(diam * Math.pow(0.5, level + 1), 0, prevOffset));
  pool.free(levels);

  return lod;
}

},{"./lib/sort":8,"typedarray-pool":10}],10:[function(require,module,exports){
(function (global,Buffer){
'use strict';

var bits = require('bit-twiddle');
var dup = require('dup'

//Legacy pool support
);if (!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
    UINT8: dup([32, 0]),
    UINT16: dup([32, 0]),
    UINT32: dup([32, 0]),
    INT8: dup([32, 0]),
    INT16: dup([32, 0]),
    INT32: dup([32, 0]),
    FLOAT: dup([32, 0]),
    DOUBLE: dup([32, 0]),
    DATA: dup([32, 0]),
    UINT8C: dup([32, 0]),
    BUFFER: dup([32, 0])
  };
}

var hasUint8C = typeof Uint8ClampedArray !== 'undefined';
var POOL = global.__TYPEDARRAY_POOL;

//Upgrade pool
if (!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0]);
}
if (!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0]);
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA = POOL.DATA,
    BUFFER = POOL.BUFFER;

exports.free = function free(array) {
  if (Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array);
  } else {
    if (Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer;
    }
    if (!array) {
      return;
    }
    var n = array.length || array.byteLength;
    var log_n = bits.log2(n) | 0;
    DATA[log_n].push(array);
  }
};

function freeArrayBuffer(buffer) {
  if (!buffer) {
    return;
  }
  var n = buffer.length || buffer.byteLength;
  var log_n = bits.log2(n);
  DATA[log_n].push(buffer);
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer);
}

exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;

exports.freeArrayBuffer = freeArrayBuffer;

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array);
};

exports.malloc = function malloc(n, dtype) {
  if (dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n);
  } else {
    switch (dtype) {
      case 'uint8':
        return mallocUint8(n);
      case 'uint16':
        return mallocUint16(n);
      case 'uint32':
        return mallocUint32(n);
      case 'int8':
        return mallocInt8(n);
      case 'int16':
        return mallocInt16(n);
      case 'int32':
        return mallocInt32(n);
      case 'float':
      case 'float32':
        return mallocFloat(n);
      case 'double':
      case 'float64':
        return mallocDouble(n);
      case 'uint8_clamped':
        return mallocUint8Clamped(n);
      case 'buffer':
        return mallocBuffer(n);
      case 'data':
      case 'dataview':
        return mallocDataView(n);

      default:
        return null;
    }
  }
  return null;
};

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n);
  var log_n = bits.log2(n);
  var d = DATA[log_n];
  if (d.length > 0) {
    return d.pop();
  }
  return new ArrayBuffer(n);
}
exports.mallocArrayBuffer = mallocArrayBuffer;

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocUint8 = mallocUint8;

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocUint16 = mallocUint16;

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocUint32 = mallocUint32;

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocInt8 = mallocInt8;

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocInt16 = mallocInt16;

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocInt32 = mallocInt32;

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat;

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble;

function mallocUint8Clamped(n) {
  if (hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
  } else {
    return mallocUint8(n);
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped;

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n);
}
exports.mallocDataView = mallocDataView;

function mallocBuffer(n) {
  n = bits.nextPow2(n);
  var log_n = bits.log2(n);
  var cache = BUFFER[log_n];
  if (cache.length > 0) {
    return cache.pop();
  }
  return new Buffer(n);
}
exports.mallocBuffer = mallocBuffer;

exports.clearCache = function clearCache() {
  for (var i = 0; i < 32; ++i) {
    POOL.UINT8[i].length = 0;
    POOL.UINT16[i].length = 0;
    POOL.UINT32[i].length = 0;
    POOL.INT8[i].length = 0;
    POOL.INT16[i].length = 0;
    POOL.INT32[i].length = 0;
    POOL.FLOAT[i].length = 0;
    POOL.DOUBLE[i].length = 0;
    POOL.UINT8C[i].length = 0;
    DATA[i].length = 0;
    BUFFER[i].length = 0;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"bit-twiddle":3,"buffer":19,"dup":5}],11:[function(require,module,exports){
'use strict';

const createRegl = require('regl');
const extend = require('object-assign');
const rgba = require('color-rgba');
const getBounds = require('array-bounds');
const clamp = require('clamp');
const atlas = require('font-atlas-sdf');
const colorId = require('color-id');
const snapPoints = require('snap-points-2d');
const clusterPoints = require('../point-cluster');
const normalize = require('array-normalize');

module.exports = Scatter;

function Scatter(options) {
  if (!(this instanceof Scatter)) return new Scatter(options);

  // regl instance
  if (options.regl) this.regl = options.regl;

  // gl-plot2d case
  else if (options.plot) {
      this.plot = options.plot;

      this.regl = createRegl({
        gl: this.plot.gl,
        pixelRatio: this.plot.pixelRatio
      });

      this.plot.addObject(this);
    }

    // container/gl/canvas case
    else {
        this.regl = createRegl({
          pixelRatio: options.pixelRatio || this.pixelRatio,
          gl: options.gl,
          container: options.container,
          canvas: options.canvas
        });
      }

  // refs for compatibility
  this.gl = this.regl._gl;
  this.canvas = this.gl.canvas;
  this.container = this.canvas.parentNode;

  this.init(options);
}

//last positions raw data
Scatter.prototype.positions = [];
Scatter.prototype.pointCount = 0;

//selected point indexes array
Scatter.prototype.selection = null;

//current viewport settings
Scatter.prototype.scale = [1, 1];
Scatter.prototype.translate = [0, 0];

//TODO
Scatter.prototype.viewBox = null;
Scatter.prototype.dataBox = null;

//point style options
Scatter.prototype.size = 12;
Scatter.prototype.color = [1, 0, 0, 1];
Scatter.prototype.borderSize = 1;
Scatter.prototype.borderColor = [0, 0, 0, 1];

//gl settings
Scatter.prototype.pixelRatio = window.devicePixelRatio;
Scatter.prototype.gl = null;
Scatter.prototype.container = null;
Scatter.prototype.canvas = null;

//group points for faster rendering of huge number of them
Scatter.prototype.cluster = false;

//font atlas texture singleton
Scatter.prototype.charCanvas = document.createElement('canvas');
Scatter.prototype.charStep = 400;

//create drawing methods based on initial options
Scatter.prototype.init = function (options) {
  let regl = this.regl;

  this.bounds = [-Infinity, -Infinity, Infinity, Infinity];

  //textures for glyphs and color palette
  this.charTexture = regl.texture(this.charCanvas

  //awesome buffers to reuse
  );this.sizeBuffer = regl.buffer({
    usage: 'dynamic',
    type: 'float',
    data: null
  });
  this.positionBuffer = regl.buffer({
    usage: 'static',
    type: 'float',
    data: null
  });
  this.colorBuffer = regl.buffer({
    usage: 'dynamic',
    type: 'uint8',
    data: null
  });

  this.update(options);

  this.drawPoints = regl({
    vert: `
    precision mediump float;

    attribute vec2 position;
    attribute float size;
    attribute vec4 color;

    uniform vec2 scale, translate;
    uniform float borderSize;

    varying vec4 fragColor;
    varying float centerFraction;

    void main() {
      gl_PointSize = size;
      gl_Position = vec4((position + translate) * scale * 2. - 1., 0, 1);
      // gl_Position.y *= -1.;

      centerFraction = borderSize == 0. ? 2. : size / (size + borderSize + 1.25);
      fragColor = color;
    }`,

    frag: `
    precision mediump float;
    uniform vec4 borderColor;

    const float fragWeight = 1.0;

    varying vec4 fragColor;
    varying float centerFraction;

    float smoothStep(float x, float y) {
      return 1.0 / (1.0 + exp(50.0*(x - y)));
    }

    void main() {
      float radius = length(2.0*gl_PointCoord.xy-1.0);
      if(radius > 1.0) {
        discard;
      }
      vec4 baseColor = mix(borderColor, fragColor, smoothStep(radius, centerFraction));
      float alpha = 1.0 - pow(1.0 - baseColor.a, fragWeight);
      gl_FragColor = vec4(baseColor.rgb * alpha, alpha);
    }`,

    uniforms: {
      scale: regl.this('scale'),
      translate: regl.this('translate'),
      borderColor: regl.this('borderColor'),
      borderSize: regl.this('borderSize')
    },

    attributes: {
      position: this.positionBuffer,
      size: () => {
        if (Array.isArray(this.size)) {
          return this.sizeBuffer;
        }
        return { constant: this.size };
      },
      color: () => {
        if (Array.isArray(this.color[0])) {
          return this.colorBuffer;
        }
        return { constant: this.color };
      }
    },

    blend: {
      enable: true,
      equation: { rgb: 'add', alpha: 'add' },
      func: { src: 'one', dst: 'one minus src alpha' }
    },

    count: regl.this('pointCount'),

    // and same for the selection
    // elements: [0,1],

    primitive: 'points'
  }

  //debug run
  );this.drawTest = regl({
    frag: `
    precision mediump float;

    void main() {
      gl_FragColor = vec4(0, 1, 0, 1);
    }`,

    vert: `
    precision mediump float;
    attribute vec2 position;

    void main() {
      gl_Position = vec4(position, 0, 1);
    }`,

    attributes: {
      position: [[-1, -1], [1, 0], [0, 1]]
    },

    count: 3
  });

  return this;
};

Scatter.prototype.update = function (options) {
  let regl = this.regl,
      w = this.canvas.width,
      h = this.canvas.height;

  if (options.length != null) options = { positions: options };

  let {
    positions,
    selection,
    scale,
    translate,
    size,
    color,
    borderSize,
    borderColor,
    glyph,
    pixelRatio,
    viewBox,
    dataBox,
    cluster
  } = options;

  if (cluster != null) this.cluster = cluster;

  //make sure scale/translate are properly set
  if (translate != null) {
    this.translate = typeof translate === 'number' ? [translate, translate] : translate;
  }
  if (scale != null) {
    this.scale = typeof scale === 'number' ? [scale, scale] : scale;
    this.scale[0] = Math.max(this.scale[0], 1e-10);
    this.scale[1] = Math.max(this.scale[1], 1e-10);
  }

  //update buffer
  if (positions != null) {
    if (this.cluster) {
      //do clustering
      //TODO: send clustering to worker
      this.getPoints = clusterPoints(positions);
    } else {
      this.positionBuffer(positions);
      this.pointCount = Math.floor(positions.length / 2);
    }
    this.positions = positions;

    //update bounds
    this.bounds = getBounds(positions, 2);
  }

  //sizes
  if (size != null) {
    this.size = size;
    if (Array.isArray(this.size)) {
      this.sizeBuffer(this.size);
    }
  }

  if (borderSize != null) this.borderSize = borderSize;

  //reobtain points in case if translate/scale/positions changed
  if (scale != null || positions != null) {
    //recalc bounds for the data
    if (this.cluster) {
      //TODO: read actual point radius/size here
      let radius = (this.size[0] || this.size) / Math.max(w, h) / this.scale[0];
      let ids = this.getPoints(radius);

      let subpositions = new Float32Array(ids.length * 2);
      for (let i = 0, id; i < ids.length; i++) {
        let id = ids[i];
        subpositions[i * 2] = this.positions[id * 2];
        subpositions[i * 2 + 1] = this.positions[id * 2 + 1];
      }
      this.positionBuffer(subpositions);
      this.pointCount = Math.floor(subpositions.length / 2);
    }
  }

  //process colors
  if (color != null) {
    //ensure colors are arrays
    if (Array.isArray(color) && (Array.isArray(color[0]) || typeof color[0] === 'string')) {
      for (let i = 0, l = this.positions.length / 2; i < l; i++) {
        if (color[i] != null) {
          color[i] = rgba(color[i]);
        } else {
          color[i] = Scatter.prototype.color;
        }
      }
      this.colorBuffer(color);
    } else if (typeof color === 'string') {
      color = rgba(color);
    }
    this.color = color;
  }
  if (borderColor != null) {
    this.borderColor = borderColor;
  }

  //aggregate glyphs
  if (glyph != null) {}
  // var glyphChars = {}
  // for (var i = 0, l = this.pointCount, k = 0; i < l; i++) {
  //   var char = glyphs[i]
  //   if (glyphChars[char] == null) {
  //     glyphChars[char] = k++
  //   }
  // }


  //update atlas
  /*
  var maxSize = 0
  for (var i = 0, l = sizes.length; i < l; ++i) {
    if (sizes[i] > maxSize) maxSize = sizes[i]
  }
  var oldStep = this.charStep
  this.charStep = clamp(Math.ceil(maxSize*4), 128, 768)
    var chars = Object.keys(glyphChars)
  var step = this.charStep
  var charSize = Math.floor(step / 2)
  var maxW = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  var maxChars = (maxW / step) * (maxW / step)
  var atlasW = Math.min(maxW, step*chars.length)
  var atlasH = Math.min(maxW, step*Math.ceil(step*chars.length/maxW))
  var cols = Math.floor(atlasW / step)
  if (chars.length > maxChars) {
    console.warn('gl-scatter2d-fancy: number of characters is more than maximum texture size. Try reducing it.')
  }
    //do not overupdate atlas
  if (!this.chars || (this.chars+'' !== chars+'') || this.charStep != oldStep) {
    this.charCanvas = atlas({
      canvas: this.charCanvas,
      family: 'sans-serif',
      size: charSize,
      shape: [atlasW, atlasH],
      step: [step, step],
      chars: chars,
      align: true
    })
    this.chars = chars
  }
  */

  return this;
};

// Then we assign regl commands directly to the prototype of the class
Scatter.prototype.draw = function () {
  //TODO: make multipass-render here

  //handle gl-plot2d case
  //FIXME: get rid of that once regl-plot2d is available
  if (this.plot) {
    let bounds = this.bounds;
    let dataBox = this.plot.dataBox;
    let viewBox = this.plot.viewBox;

    //hack to support gl-plot2d
    this.regl._refresh();
    this.gl.scissor(viewBox[0], viewBox[1], viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]);
    this.gl.viewport(viewBox[0], viewBox[1], viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]);

    this.scale[0] = 1 / (dataBox[2] - dataBox[0]);
    this.scale[1] = 1 / (dataBox[3] - dataBox[1]);
    this.translate[0] = -dataBox[0];
    this.translate[1] = -dataBox[1];
  }

  this.drawPoints
  // this.drawTest()

  ();return this.pointCount;
};

// adjust scale and transform so to see all the data
Scatter.prototype.autorange = function (positions) {
  if (!positions) positions = this.positions;
  if (!positions || positions.length == 0) return this;

  let bounds = this.bounds;

  let scale = [1 / (bounds[2] - bounds[0]), 1 / (bounds[3] - bounds[1])];

  this.update({
    scale: scale,
    translate: [-bounds[0], -bounds[1]]
  });

  return this;
};

Scatter.prototype.clear = function () {
  this.regl.clear({
    color: [1, 1, 1, 1],
    depth: 1,
    stencil: 0
  });

  return this;
};

Scatter.prototype.pick = function (x, y, value) {
  // return this.draw()
  return null;
};

Scatter.prototype.drawPick = function () {
  return this.pointCount;
};

Scatter.prototype.dispose = function () {
  this.charTexture.destroy();
  this.sizeBuffer.destroy();
  this.positionBuffer.destroy();

  if (this.plot) this.plot.removeObject(this);

  return this;
};

Scatter.prototype.select = function () {
  //TODO: init regl draw here
  return this;
};

//TODO: move to a separate quadtree-based package
function createCluster(points) {
  let scales = snapPoints(points, [], [], []);

  return function getPoints(pixelSize, bounds) {
    for (var scaleNum = scales.length - 1; scaleNum >= 0; scaleNum--) {
      var lod = scales[scaleNum];
      if (lod.pixelSize < pixelSize && scaleNum > 1) continue;

      var range = this.getVisibleRange(lod);
      var startOffset = range[0],
          endOffset = range[1];

      if (endOffset > startOffset) gl.drawArrays(gl.POINTS, startOffset, endOffset - startOffset);

      if (!pick && firstLevel) {
        firstLevel = false;
        shader.uniforms.useWeight = 0;
      }
    }
  };
}

},{"../point-cluster":1,"array-bounds":13,"array-normalize":14,"clamp":23,"color-id":24,"color-rgba":27,"font-atlas-sdf":40,"object-assign":74,"regl":83,"snap-points-2d":107}],12:[function(require,module,exports){
/* The following list is defined in React's core */
var IS_UNITLESS = {
  animationIterationCount: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridColumn: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  stopOpacity: true,
  strokeDashoffset: true,
  strokeOpacity: true,
  strokeWidth: true
};

module.exports = function (name, value) {
  if (typeof value === 'number' && !IS_UNITLESS[name]) {
    return value + 'px';
  } else {
    return value;
  }
};

},{}],13:[function(require,module,exports){
arguments[4][2][0].apply(exports,arguments)
},{"dup":2}],14:[function(require,module,exports){
'use strict';

var getBounds = require('array-bounds');

module.exports = normalize;

function normalize(arr, dim, bounds) {
	if (!arr || arr.length == null) throw Error('Argument should be an array');

	if (dim == null) dim = 1;
	if (bounds == null) bounds = getBounds(arr, dim);

	for (var offset = 0; offset < dim; offset++) {
		var max = bounds[dim + offset],
		    min = bounds[offset],
		    i = offset,
		    l = arr.length;

		if (max === Infinity && min === -Infinity) {
			for (i = offset; i < l; i += dim) {
				arr[i] = arr[i] === max ? 1 : arr[i] === min ? 0 : .5;
			}
		} else if (max === Infinity) {
			for (i = offset; i < l; i += dim) {
				arr[i] = arr[i] === max ? 1 : 0;
			}
		} else if (min === -Infinity) {
			for (i = offset; i < l; i += dim) {
				arr[i] = arr[i] === min ? 0 : 1;
			}
		} else {
			var range = max - min;
			for (i = offset; i < l; i += dim) {
				arr[i] = (arr[i] - min) / range;
			}
		}
	}

	return arr;
}

},{"array-bounds":13}],15:[function(require,module,exports){
'use strict';

module.exports = function (val) {
	if (val === null || val === undefined) {
		return [];
	}

	return Array.isArray(val) ? val : [val];
};

},{}],16:[function(require,module,exports){
/*!
	Autosize 3.0.21
	license: MIT
	http://www.jacklmoore.com/autosize
*/
(function (global, factory) {
	if (typeof define === 'function' && define.amd) {
		define(['exports', 'module'], factory);
	} else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
		factory(exports, module);
	} else {
		var mod = {
			exports: {}
		};
		factory(mod.exports, mod);
		global.autosize = mod.exports;
	}
})(this, function (exports, module) {
	'use strict';

	var map = typeof Map === "function" ? new Map() : function () {
		var keys = [];
		var values = [];

		return {
			has: function has(key) {
				return keys.indexOf(key) > -1;
			},
			get: function get(key) {
				return values[keys.indexOf(key)];
			},
			set: function set(key, value) {
				if (keys.indexOf(key) === -1) {
					keys.push(key);
					values.push(value);
				}
			},
			'delete': function _delete(key) {
				var index = keys.indexOf(key);
				if (index > -1) {
					keys.splice(index, 1);
					values.splice(index, 1);
				}
			}
		};
	}();

	var createEvent = function createEvent(name) {
		return new Event(name, { bubbles: true });
	};
	try {
		new Event('test');
	} catch (e) {
		// IE does not support `new Event()`
		createEvent = function (name) {
			var evt = document.createEvent('Event');
			evt.initEvent(name, true, false);
			return evt;
		};
	}

	function assign(ta) {
		if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;

		var heightOffset = null;
		var clientWidth = ta.clientWidth;
		var cachedHeight = null;

		function init() {
			var style = window.getComputedStyle(ta, null);

			if (style.resize === 'vertical') {
				ta.style.resize = 'none';
			} else if (style.resize === 'both') {
				ta.style.resize = 'horizontal';
			}

			if (style.boxSizing === 'content-box') {
				heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
			} else {
				heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
			}
			// Fix when a textarea is not on document body and heightOffset is Not a Number
			if (isNaN(heightOffset)) {
				heightOffset = 0;
			}

			update();
		}

		function changeOverflow(value) {
			{
				// Chrome/Safari-specific fix:
				// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space
				// made available by removing the scrollbar. The following forces the necessary text reflow.
				var width = ta.style.width;
				ta.style.width = '0px';
				// Force reflow:
				/* jshint ignore:start */
				ta.offsetWidth;
				/* jshint ignore:end */
				ta.style.width = width;
			}

			ta.style.overflowY = value;
		}

		function getParentOverflows(el) {
			var arr = [];

			while (el && el.parentNode && el.parentNode instanceof Element) {
				if (el.parentNode.scrollTop) {
					arr.push({
						node: el.parentNode,
						scrollTop: el.parentNode.scrollTop
					});
				}
				el = el.parentNode;
			}

			return arr;
		}

		function resize() {
			var originalHeight = ta.style.height;
			var overflows = getParentOverflows(ta);
			var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)

			ta.style.height = 'auto';

			var endHeight = ta.scrollHeight + heightOffset;

			if (ta.scrollHeight === 0) {
				// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.
				ta.style.height = originalHeight;
				return;
			}

			ta.style.height = endHeight + 'px';

			// used to check if an update is actually necessary on window.resize
			clientWidth = ta.clientWidth;

			// prevents scroll-position jumping
			overflows.forEach(function (el) {
				el.node.scrollTop = el.scrollTop;
			});

			if (docTop) {
				document.documentElement.scrollTop = docTop;
			}
		}

		function update() {
			resize();

			var styleHeight = Math.round(parseFloat(ta.style.height));
			var computed = window.getComputedStyle(ta, null);

			// Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box
			var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;

			// The actual height not matching the style height (set via the resize method) indicates that
			// the max-height has been exceeded, in which case the overflow should be allowed.
			if (actualHeight !== styleHeight) {
				if (computed.overflowY === 'hidden') {
					changeOverflow('scroll');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			} else {
				// Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.
				if (computed.overflowY !== 'hidden') {
					changeOverflow('hidden');
					resize();
					actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
				}
			}

			if (cachedHeight !== actualHeight) {
				cachedHeight = actualHeight;
				var evt = createEvent('autosize:resized');
				try {
					ta.dispatchEvent(evt);
				} catch (err) {
					// Firefox will throw an error on dispatchEvent for a detached element
					// https://bugzilla.mozilla.org/show_bug.cgi?id=889376
				}
			}
		}

		var pageResize = function pageResize() {
			if (ta.clientWidth !== clientWidth) {
				update();
			}
		};

		var destroy = function (style) {
			window.removeEventListener('resize', pageResize, false);
			ta.removeEventListener('input', update, false);
			ta.removeEventListener('keyup', update, false);
			ta.removeEventListener('autosize:destroy', destroy, false);
			ta.removeEventListener('autosize:update', update, false);

			Object.keys(style).forEach(function (key) {
				ta.style[key] = style[key];
			});

			map['delete'](ta);
		}.bind(ta, {
			height: ta.style.height,
			resize: ta.style.resize,
			overflowY: ta.style.overflowY,
			overflowX: ta.style.overflowX,
			wordWrap: ta.style.wordWrap
		});

		ta.addEventListener('autosize:destroy', destroy, false);

		// IE9 does not fire onpropertychange or oninput for deletions,
		// so binding to onkeyup to catch most of those events.
		// There is no way that I know of to detect something like 'cut' in IE9.
		if ('onpropertychange' in ta && 'oninput' in ta) {
			ta.addEventListener('keyup', update, false);
		}

		window.addEventListener('resize', pageResize, false);
		ta.addEventListener('input', update, false);
		ta.addEventListener('autosize:update', update, false);
		ta.style.overflowX = 'hidden';
		ta.style.wordWrap = 'break-word';

		map.set(ta, {
			destroy: destroy,
			update: update
		});

		init();
	}

	function destroy(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.destroy();
		}
	}

	function update(ta) {
		var methods = map.get(ta);
		if (methods) {
			methods.update();
		}
	}

	var autosize = null;

	// Do nothing in Node.js environment and IE8 (or lower)
	if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
		autosize = function (el) {
			return el;
		};
		autosize.destroy = function (el) {
			return el;
		};
		autosize.update = function (el) {
			return el;
		};
	} else {
		autosize = function (el, options) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], function (x) {
					return assign(x, options);
				});
			}
			return el;
		};
		autosize.destroy = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], destroy);
			}
			return el;
		};
		autosize.update = function (el) {
			if (el) {
				Array.prototype.forEach.call(el.length ? el : [el], update);
			}
			return el;
		};
	}

	module.exports = autosize;
});

},{}],17:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

},{}],18:[function(require,module,exports){
arguments[4][3][0].apply(exports,arguments)
},{"dup":3}],19:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict';

var base64 = require('base64-js');
var ieee754 = require('ieee754');

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}

function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () {
        return 42;
      } };
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length');
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length);
  buf.__proto__ = Buffer.prototype;
  return buf;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  });
}

Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (value instanceof ArrayBuffer) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  return fromObject(value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype;
Buffer.__proto__ = Uint8Array;

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};

function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);

  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}

function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype;
  return buf;
}

function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true;
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (isArrayBufferView(string) || string instanceof ArrayBuffer) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints // avoid extra slice()
    );
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf = this.subarray(start, end
  // Return an augmented `Uint8Array` instance
  );newBuf.__proto__ = Buffer.prototype;
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : new Buffer(val, encoding);
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, ''
  // Node converts strings with length < 2 to ''
  );if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i

    // is surrogate component
    );if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView(obj) {
  return typeof ArrayBuffer.isView === 'function' && ArrayBuffer.isView(obj);
}

function numberIsNaN(obj) {
  return obj !== obj; // eslint-disable-line no-self-compare
}

},{"base64-js":17,"ieee754":46}],20:[function(require,module,exports){
/**
 * @module  caret-position/get
 *
 * Adoption from code at
 * http://blogs.nitobi.com/alexei/wp-content/uploads/2008/01/getcaretselection3.js
 *
 * @return the caret position in a text field
 */
module.exports = function (input) {
	var docObj = input.ownerDocument,
	    result = { start: 0, end: 0, caret: 0 };

	if (navigator.appVersion.indexOf("MSIE") != -1) {
		if (input.tagName == "TEXTAREA") {
			if (input.value.charCodeAt(input.value.length - 1) < 14) {
				input.value = input.value.replace(/34/g, '') + String.fromCharCode(28);
			}
			var range = docObj.selection.createRange(),
			    rangeCopy = range.duplicate();

			rangeCopy.moveToElementText(input);
			rangeCopy.setEndPoint('StartToEnd', range);
			result.end = input.value.length - rangeCopy.text.length;

			rangeCopy.setEndPoint('StartToStart', range);
			result.start = input.value.length - rangeCopy.text.length;
			result.caret = result.end;

			if (input.value.substr(input.value.length - 1) == String.fromCharCode(28)) {
				input.value = input.value.substr(0, input.value.length - 1);
			}
		} else {
			var range = docObj.selection.createRange(),
			    rangeCopy = range.duplicate();

			result.start = 0 - rangeCopy.moveStart('character', -100000);
			result.end = result.start + range.text.length;
			result.caret = result.end;
		}
	} else {
		result.start = input.selectionStart;
		result.end = input.selectionEnd;
		result.caret = result.end;
	}
	if (result.start < 0) {
		result = { start: 0, end: 0, caret: 0 };
	}
	return result;
};

},{}],21:[function(require,module,exports){
/**
 * @module  caret-position
 */

module.exports = caret;

function caret(a, b, c) {
  if (b !== undefined) return caret.get(a);
  return caret.set(a, b, c);
};

caret.get = require('./get');
caret.set = require('./set');

},{"./get":20,"./set":22}],22:[function(require,module,exports){
/**
 * @module  caret-position/set
 *
 * Adoption from code at http://blog.vishalon.net/index.php/javascript-getting-and-setting-caret-position-in-textarea/
 *
 * @param {string} input Select in that input
 * @param {int} start from character number
 * @param {int} end to character number
 */
module.exports = function (input, start, end) {
	if (end === undefined) {
		end = start;
	}

	if (input.setSelectionRange) {
		input.focus();
		input.setSelectionRange(start, end);
	} else {
		var range = input.createTextRange();
		range.collapse(true);
		range.moveEnd('character', start);
		range.moveStart('character', end);
		range.select();
	}
};

},{}],23:[function(require,module,exports){
arguments[4][4][0].apply(exports,arguments)
},{"dup":4}],24:[function(require,module,exports){
/** @module  color-number */

'use strict';

var clamp = require('clamp');

module.exports = toNumber;

function toNumber(rgba, normalized) {
	if (normalized == null) normalized = true;

	var r = rgba[0],
	    g = rgba[1],
	    b = rgba[2],
	    a = rgba[3];

	if (a == null) a = normalized ? 1 : 255;

	if (normalized) {
		r *= 255;
		g *= 255;
		b *= 255;
		a *= 255;
	}

	r = clamp(r, 0, 255) & 0xFF;
	g = clamp(g, 0, 255) & 0xFF;
	b = clamp(b, 0, 255) & 0xFF;
	a = clamp(a, 0, 255) & 0xFF;

	//hi-order shift converts to -1, so we can't use <<24
	var n = r * 0x01000000 + (g << 16) + (b << 8) + a;

	return n;
}

},{"clamp":23}],25:[function(require,module,exports){
module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

},{}],26:[function(require,module,exports){
/**
 * @module color-parse
 */

'use strict';

module.exports = parse;

var names = require('color-name');
var isObject = require('is-plain-obj');

/**
 * Base hues
 * http://dev.w3.org/csswg/css-color/#typedef-named-hue
 */
//FIXME: use external hue detector
var baseHues = {
	red: 0,
	orange: 60,
	yellow: 120,
	green: 180,
	blue: 240,
	purple: 300
};

/**
 * Parse color from the string passed
 *
 * @return {Object} A space indicator `space`, an array `values` and `alpha`
 */
function parse(cstr) {
	var m,
	    parts = [],
	    alpha = 1,
	    space;

	if (typeof cstr === 'string') {
		//keyword
		if (names[cstr]) {
			parts = names[cstr].slice();
			space = 'rgb';
		}

		//reserved words
		else if (cstr === 'transparent') {
				alpha = 0;
				space = 'rgb';
				parts = [0, 0, 0];
			}

			//hex
			else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
					var base = cstr.slice(1);
					var size = base.length;
					var isShort = size <= 4;
					alpha = 1;

					if (isShort) {
						parts = [parseInt(base[0] + base[0], 16), parseInt(base[1] + base[1], 16), parseInt(base[2] + base[2], 16)];
						if (size === 4) {
							alpha = parseInt(base[3] + base[3], 16) / 255;
						}
					} else {
						parts = [parseInt(base[0] + base[1], 16), parseInt(base[2] + base[3], 16), parseInt(base[4] + base[5], 16)];
						if (size === 8) {
							alpha = parseInt(base[6] + base[7], 16) / 255;
						}
					}

					if (!parts[0]) parts[0] = 0;
					if (!parts[1]) parts[1] = 0;
					if (!parts[2]) parts[2] = 0;

					space = 'rgb';
				}

				//color space
				else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
						var name = m[1];
						var base = name.replace(/a$/, '');
						space = base;
						var size = base === 'cmyk' ? 4 : base === 'gray' ? 1 : 3;
						parts = m[2].trim().split(/\s*,\s*/).map(function (x, i) {
							//<percentage>
							if (/%$/.test(x)) {
								//alpha
								if (i === size) return parseFloat(x) / 100;
								//rgb
								if (base === 'rgb') return parseFloat(x) * 255 / 100;
								return parseFloat(x);
							}
							//hue
							else if (base[i] === 'h') {
									//<deg>
									if (/deg$/.test(x)) {
										return parseFloat(x);
									}
									//<base-hue>
									else if (baseHues[x] !== undefined) {
											return baseHues[x];
										}
								}
							return parseFloat(x);
						});

						if (name === base) parts.push(1);
						alpha = parts[size] === undefined ? 1 : parts[size];
						parts = parts.slice(0, size);
					}

					//named channels case
					else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
							parts = cstr.match(/([0-9]+)/g).map(function (value) {
								return parseFloat(value);
							});

							space = cstr.match(/([a-z])/ig).join('').toLowerCase();
						}
	}

	//numeric case
	else if (typeof cstr === 'number') {
			space = 'rgb';
			parts = [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff];
		}

		//object case - detects css cases of rgb and hsl
		else if (isObject(cstr)) {
				if (cstr.r != null) {
					parts = [cstr.r, cstr.g, cstr.b];
					space = 'rgb';
				} else if (cstr.red != null) {
					parts = [cstr.red, cstr.green, cstr.blue];
					space = 'rgb';
				} else if (cstr.h != null) {
					parts = [cstr.h, cstr.s, cstr.l];
					space = 'hsl';
				} else if (cstr.hue != null) {
					parts = [cstr.hue, cstr.saturation, cstr.lightness];
					space = 'hsl';
				}

				if (cstr.a != null) alpha = cstr.a;else if (cstr.alpha != null) alpha = cstr.alpha;else if (cstr.opacity != null) alpha = cstr.opacity / 100;
			}

			//array
			else if (Array.isArray(cstr) || ArrayBuffer.isView(cstr)) {
					parts = [cstr[0], cstr[1], cstr[2]];
					space = 'rgb';
					alpha = cstr.length === 4 ? cstr[3] : 1;
				}

	return {
		space: space,
		values: parts,
		alpha: alpha
	};
}

},{"color-name":25,"is-plain-obj":54}],27:[function(require,module,exports){
/** @module  color-rgba */

'use strict';

var parse = require('color-parse');
var hsl = require('color-space/hsl');
var clamp = require('clamp');

module.exports = function rgba(color, normalize) {
	if (normalize == null) normalize = true;

	var parsed = parse(color);

	if (!parsed.space) return [];

	if (Array.isArray(color)) return color;

	var values = parsed.values,
	    i,
	    l = values.length;
	for (i = 0; i < l; i++) {
		values[i] = clamp(values[i], 0, 255);
	}

	if (parsed.space[0] === 'h') {
		values = hsl.rgb(values);
	}

	if (normalize) {
		for (i = 0; i < l; i++) {
			values[i] /= 255;
		}
	}

	values.push(clamp(parsed.alpha, 0, 1));

	return values;
};

},{"clamp":23,"color-parse":26,"color-space/hsl":28}],28:[function(require,module,exports){
/**
 * @module color-space/hsl
 */
'use strict';

var rgb = require('./rgb');

module.exports = {
	name: 'hsl',
	min: [0, 0, 0],
	max: [360, 100, 100],
	channel: ['hue', 'saturation', 'lightness'],
	alias: ['HSL'],

	rgb: function (hsl) {
		var h = hsl[0] / 360,
		    s = hsl[1] / 100,
		    l = hsl[2] / 100,
		    t1,
		    t2,
		    t3,
		    rgb,
		    val;

		if (s === 0) {
			val = l * 255;
			return [val, val, val];
		}

		if (l < 0.5) {
			t2 = l * (1 + s);
		} else {
			t2 = l + s - l * s;
		}
		t1 = 2 * l - t2;

		rgb = [0, 0, 0];
		for (var i = 0; i < 3; i++) {
			t3 = h + 1 / 3 * -(i - 1);
			if (t3 < 0) {
				t3++;
			} else if (t3 > 1) {
				t3--;
			}

			if (6 * t3 < 1) {
				val = t1 + (t2 - t1) * 6 * t3;
			} else if (2 * t3 < 1) {
				val = t2;
			} else if (3 * t3 < 2) {
				val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
			} else {
				val = t1;
			}

			rgb[i] = val * 255;
		}

		return rgb;
	}
};

//extend rgb
rgb.hsl = function (rgb) {
	var r = rgb[0] / 255,
	    g = rgb[1] / 255,
	    b = rgb[2] / 255,
	    min = Math.min(r, g, b),
	    max = Math.max(r, g, b),
	    delta = max - min,
	    h,
	    s,
	    l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

},{"./rgb":29}],29:[function(require,module,exports){
/**
 * RGB space.
 *
 * @module  color-space/rgb
 */
'use strict';

module.exports = {
	name: 'rgb',
	min: [0, 0, 0],
	max: [255, 255, 255],
	channel: ['red', 'green', 'blue'],
	alias: ['RGB']
};

},{}],30:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1),
      callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

},{}],31:[function(require,module,exports){
var prefix = require('prefix-style');
var toCamelCase = require('to-camel-case');
var cache = { 'float': 'cssFloat' };
var addPxToStyle = require('add-px-to-style');

function style(element, property, value) {
  var camel = cache[property];
  if (typeof camel === 'undefined') {
    camel = detect(property);
  }

  // may be false if CSS prop is unsupported
  if (camel) {
    if (value === undefined) {
      return element.style[camel];
    }

    element.style[camel] = addPxToStyle(camel, value);
  }
}

function each(element, properties) {
  for (var k in properties) {
    if (properties.hasOwnProperty(k)) {
      style(element, k, properties[k]);
    }
  }
}

function detect(cssProp) {
  var camel = toCamelCase(cssProp);
  var result = prefix(camel);
  cache[camel] = cache[cssProp] = cache[result] = result;
  return result;
}

function set() {
  if (arguments.length === 2) {
    if (typeof arguments[1] === 'string') {
      arguments[0].style.cssText = arguments[1];
    } else {
      each(arguments[0], arguments[1]);
    }
  } else {
    style(arguments[0], arguments[1], arguments[2]);
  }
}

module.exports = set;
module.exports.set = set;

module.exports.get = function (element, properties) {
  if (Array.isArray(properties)) {
    return properties.reduce(function (obj, prop) {
      obj[prop] = style(element, prop || '');
      return obj;
    }, {});
  } else {
    return style(element, properties || '');
  }
};

},{"add-px-to-style":12,"prefix-style":79,"to-camel-case":110}],32:[function(require,module,exports){
'use strict';

var trim = require('trim');
var prefix = require('prefix');
var prop = prefix('transform');
var propTransOrigin = prefix('transformOrigin');
var fns = require('./lib/properties');

var _has = Object.prototype.hasOwnProperty;

var shortcuts = {
  x: 'translateX',
  y: 'translateY',
  z: 'translateZ'
};

exports = module.exports = transform;

function transform(target, properties) {
  var output = [];
  var i;
  var name;
  var propValue;

  for (i in properties) {
    propValue = properties[i];

    // replace shortcut with its transform value.
    name = _has.call(shortcuts, i) ? name = shortcuts[i] : name = i;

    if (_has.call(fns, name)) {
      output.push(fns[name](numToString(propValue)));
      continue;
    }

    if (name === 'origin') {
      target.style[propTransOrigin] = propValue;
      continue;
    }

    console.warn(name, 'is not a valid property');
  }

  target.style[prop] = output.join(' ');
}

exports.get = get;

function get(target) {
  return style(target);
}

exports.none = none;

function none(target) {
  target.style[prop] = '';
  target.style[propTransOrigin] = '';
}

exports.isSupported = isSupported;

function isSupported() {
  return prop.length > 0;
}

function style(target) {
  return target.style[prop];
}

function numToString(value) {
  if (typeof value === 'number') {
    value += '';
  } else {
    value = trim(value);
  }

  return value;
}

},{"./lib/properties":34,"prefix":80,"trim":117}],33:[function(require,module,exports){
'use strict';

exports = module.exports = compose;

function compose() {
  var funcs = arguments;

  return function () {
    var args = arguments;
    for (var i = funcs.length - 1; i >= 0; i--) {
      args = [funcs[i].apply(this, args)];
    }
    return args[0];
  };
}

},{}],34:[function(require,module,exports){
'use strict';

var trim = require('trim');
var compose = require('./compose');

var NUMBER_REGEX = /^-?\d+(\.\d+)?$/;

module.exports = {
  translate: compose(function (value) {
    return 'translate(' + value + ')';
  }, defaultUnit('px'), comma),

  translate3d: compose(function (value) {
    return 'translate3d(' + value + ')';
  }, defaultUnit('px'), comma),

  translateX: compose(function (x) {
    return 'translateX(' + x + ')';
  }, defaultUnit('px')),

  translateY: compose(function (y) {
    return 'translateY(' + y + ')';
  }, defaultUnit('px')),

  translateZ: compose(function (z) {
    return 'translateZ(' + z + ')';
  }, defaultUnit('px')),

  scale: compose(function (value) {
    return 'scale(' + value + ')';
  }, comma),

  scale3d: compose(function (value) {
    return 'scale3d(' + value + ')';
  }, comma),

  scaleX: function (value) {
    return 'scaleX(' + value + ')';
  },

  scaleY: function (value) {
    return 'scaleY(' + value + ')';
  },

  scaleZ: function (value) {
    return 'scaleZ(' + value + ')';
  },

  rotate: compose(function (value) {
    return 'rotate(' + value + ')';
  }, defaultUnit('deg'), comma),

  rotate3d: compose(function (value) {
    return 'rotate3d(' + value + ')';
  }, comma),

  rotateX: compose(function (value) {
    return 'rotateX(' + value + ')';
  }, defaultUnit('deg')),

  rotateY: compose(function (value) {
    return 'rotateY(' + value + ')';
  }, defaultUnit('deg')),

  rotateZ: compose(function (value) {
    return 'rotateZ(' + value + ')';
  }, defaultUnit('deg')),

  skew: compose(function (value) {
    return 'skew(' + value + ')';
  }, defaultUnit('deg'), comma),

  skewX: compose(function (value) {
    return 'skewX(' + value + ')';
  }, defaultUnit('deg')),

  skewY: compose(function (value) {
    return 'skewY(' + value + ')';
  }, defaultUnit('deg')),

  matrix: compose(function (value) {
    return 'matrix(' + value + ')';
  }, comma),

  matrix3d: compose(function (value) {
    return 'matrix3d(' + value + ')';
  }, comma),

  perspective: compose(function (value) {
    return 'perspective(' + value + ')';
  }, defaultUnit('px'))
};

function comma(value) {
  if (!/,/.test(value)) {
    value = value.split(' ').join(',');
  }

  return value;
}

function defaultUnit(unit) {
  return function (value) {
    return value.split(',').map(function (v) {
      v = trim(v);

      if (NUMBER_REGEX.test(v)) {
        v += unit;
      }

      return v;
    }).join(',');
  };
}

},{"./compose":33,"trim":117}],35:[function(require,module,exports){
module.exports = defaultProperty;

function defaultProperty(get, set) {
  return {
    configurable: true,
    enumerable: true,
    get: get,
    set: set
  };
}

},{}],36:[function(require,module,exports){
arguments[4][5][0].apply(exports,arguments)
},{"dup":5}],37:[function(require,module,exports){
if (!Array.prototype.fill) {
    Array.prototype.fill = function (value) {

        // Steps 1-2.
        if (this == null) {
            throw new TypeError('this is null or not defined');
        }

        var O = Object(this);

        // Steps 3-5.
        var len = O.length >>> 0;

        // Steps 6-7.
        var start = arguments[1];
        var relativeStart = start >> 0;

        // Step 8.
        var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);

        // Steps 9-10.
        var end = arguments[2];
        var relativeEnd = end === undefined ? len : end >> 0;

        // Step 11.
        var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

        // Step 12.
        while (k < final) {
            O[k] = value;
            k++;
        }

        // Step 13.
        return O;
    };
}

},{}],38:[function(require,module,exports){
require('./arr-fill');
require('typedarray-methods');
require('get-float-time-domain-data');
const css = require('insert-styles');

css("/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in\n *    IE on Windows Phone and in iOS.\n */\n\nhtml {\n  line-height: 1.15; /* 1 */\n  -ms-text-size-adjust: 100%; /* 2 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\n\n/* Sections\n   ========================================================================== */\n\n/**\n * Remove the margin in all browsers (opinionated).\n */\n\nbody {\n  margin: 0;\n}\n\n/**\n * Add the correct display in IE 9-.\n */\n\narticle,\naside,\nfooter,\nheader,\nnav,\nsection {\n  display: block;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\n\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n/* Grouping content\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n * 1. Add the correct display in IE.\n */\n\nfigcaption,\nfigure,\nmain { /* 1 */\n  display: block;\n}\n\n/**\n * Add the correct margin in IE 8.\n */\n\nfigure {\n  margin: 1em 40px;\n}\n\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\n\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/* Text-level semantics\n   ========================================================================== */\n\n/**\n * 1. Remove the gray background on active links in IE 10.\n * 2. Remove gaps in links underline in iOS 8+ and Safari 8+.\n */\n\na {\n  background-color: transparent; /* 1 */\n  -webkit-text-decoration-skip: objects; /* 2 */\n}\n\n/**\n * 1. Remove the bottom border in Chrome 57- and Firefox 39-.\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\n\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Prevent the duplicate application of `bolder` by the next rule in Safari 6.\n */\n\nb,\nstrong {\n  font-weight: inherit;\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct font style in Android 4.3-.\n */\n\ndfn {\n  font-style: italic;\n}\n\n/**\n * Add the correct background and color in IE 9-.\n */\n\nmark {\n  background-color: #ff0;\n  color: #000;\n}\n\n/**\n * Add the correct font size in all browsers.\n */\n\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n */\n\naudio,\nvideo {\n  display: inline-block;\n}\n\n/**\n * Add the correct display in iOS 4-7.\n */\n\naudio:not([controls]) {\n  display: none;\n  height: 0;\n}\n\n/**\n * Remove the border on images inside links in IE 10-.\n */\n\nimg {\n  border-style: none;\n}\n\n/**\n * Hide the overflow in IE.\n */\n\nsvg:not(:root) {\n  overflow: hidden;\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers (opinionated).\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: sans-serif; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`\n *    controls in Android 4.\n * 2. Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\nhtml [type=\"button\"], /* 1 */\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; /* 2 */\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Correct the padding in Firefox.\n */\n\nfieldset {\n  padding: 0.35em 0.75em 0.625em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * 1. Add the correct display in IE 9-.\n * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  display: inline-block; /* 1 */\n  vertical-align: baseline; /* 2 */\n}\n\n/**\n * Remove the default vertical scrollbar in IE.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10-.\n * 2. Remove the padding in IE 10-.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-cancel-button,\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/* Interactive\n   ========================================================================== */\n\n/*\n * Add the correct display in IE 9-.\n * 1. Add the correct display in Edge, IE, and Firefox.\n */\n\ndetails, /* 1 */\nmenu {\n  display: block;\n}\n\n/*\n * Add the correct display in all browsers.\n */\n\nsummary {\n  display: list-item;\n}\n\n/* Scripting\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n */\n\ncanvas {\n  display: inline-block;\n}\n\n/**\n * Add the correct display in IE.\n */\n\ntemplate {\n  display: none;\n}\n\n/* Hidden\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 10-.\n */\n\n[hidden] {\n  display: none;\n}\n");

css(`
	html {
		touch-action: manipulation;
	}
`);

addMeta({
	name: 'viewport',
	content: 'width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=0'
});
addMeta({
	'http-equiv': 'x-ua-compatible',
	content: 'ie=edge'
});
addMeta({
	charset: 'utf-8'
});

function addMeta(obj) {
	let meta = document.createElement('meta');
	let qs = 'meta';
	for (let name in obj) {
		qs += `[${name}]`;
		meta.setAttribute(name, obj[name]);
	}
	if (!document.querySelector(qs)) {
		document.head.insertBefore(meta, document.head.firstChild);
	}
}

},{"./arr-fill":37,"get-float-time-domain-data":43,"insert-styles":50,"typedarray-methods":118}],39:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function (n) {
  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function (type) {
  var er, handler, len, args, i, listeners;

  if (!this._events) this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler)) return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++) listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function (type, listener) {
  var m;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function (type, listener) {
  if (!isFunction(listener)) throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function (type, listener) {
  var list, position, length, i;

  if (!isFunction(listener)) throw TypeError('listener must be a function');

  if (!this._events || !this._events[type]) return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener || isFunction(list.listener) && list.listener === listener) {
    delete this._events[type];
    if (this._events.removeListener) this.emit('removeListener', type, listener);
  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener) this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function (type) {
  var key, listeners;

  if (!this._events) return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length) this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function (type) {
  var ret;
  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function (type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function (emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],40:[function(require,module,exports){
'use strict';

var SDF = require('tiny-sdf');

module.exports = atlas;

function atlas(options) {
	options = options || {};

	var canvas = options.canvas || document.createElement('canvas');
	var family = options.family || 'monospace';
	var shape = options.shape || [512, 512];
	var step = options.step || [32, 32];
	var size = options.size || 16;
	var chars = options.chars || [32, 126];
	var bufferSize = Math.floor((step[0] - size) / 2);
	var radius = options.radius || bufferSize * 1.5;
	var sdf = new SDF(size, bufferSize, radius, 0, family);
	var vAlign = options.align || true;
	var i, j;

	if (typeof size === 'number') {
		size = size + 'px';
	}

	if (!Array.isArray(chars)) {
		chars = String(chars).split('');
	} else if (chars.length === 2 && typeof chars[0] === 'number' && typeof chars[1] === 'number') {
		var newchars = [];

		for (i = chars[0], j = 0; i <= chars[1]; i++) {
			newchars[j++] = String.fromCharCode(i);
		}

		chars = newchars;
	}

	shape = shape.slice();
	canvas.width = shape[0];
	canvas.height = shape[1];

	var ctx = canvas.getContext('2d');

	ctx.fillStyle = '#000';
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	ctx.font = size + ' ' + family;
	ctx.textBaseline = 'middle';

	var x = 0;
	var y = 0;
	var len = Math.min(chars.length, Math.floor(shape[0] / step[0]) * Math.ceil(shape[1] / step[1])

	// hack tiny-sdf to render centered
	//FIXME: get rif of it by [possibly] PR to tiny-sdf
	);var align = sdf.ctx.textAlign;
	var buffer = sdf.buffer;

	sdf.ctx.textAlign = 'center';
	sdf.buffer = sdf.size / 2;

	for (i = 0; i < len; i++) {
		var data = sdf.draw(chars[i]);

		var offY = 0;
		if (vAlign) offY = getAlignOffset(data);

		ctx.putImageData(data, x, y - offY);

		x += step[0];
		if (x > shape[0] - step[0]) {
			x = 0;
			y += step[1];
		}
	}

	// unhack tiny-sdf
	sdf.ctx.textAlign = align;
	sdf.buffer = buffer;

	return canvas;

	function getAlignOffset(data) {
		var buf = data.data,
		    w = data.width,
		    h = data.height;

		var top = 0,
		    bottom = 0,
		    x,
		    y,
		    r,
		    line;

		//find top boundary
		for (y = 0; y < h; y++) {
			line = y * w * 4;
			for (x = 0; x < w; x++) {
				r = buf[line + x * 4];

				if (r > 0) {
					top = y;
					break;
				}
			}
			if (top) break;
		}

		//find bottom boundary
		for (y = h; y--;) {
			line = y * w * 4;
			for (x = 0; x < w; x++) {
				r = buf[line + x * 4];

				if (r > 0) {
					bottom = y;
					break;
				}
			}
			if (bottom) break;
		}

		return top - .5 * (top + (h - bottom));
	}
}

},{"tiny-sdf":108}],41:[function(require,module,exports){
/**
 * @module fps-indicator
 */
'use strict';

const raf = require('raf');
const now = require('right-now');
const css = require('to-css');

module.exports = fps;

function fps(opts) {
	if (!(this instanceof fps)) return new fps(opts);

	if (typeof opts === 'string') opts = { position: opts };
	opts = opts || {};

	if (opts.container) {
		if (typeof opts.container === 'string') {
			this.container = document.querySelector(opts.container);
		} else {
			this.container = opts.container;
		}
	} else {
		this.container = document.body || document.documentElement;
	}

	//init fps
	this.element = document.createElement('div');
	this.element.classList.add('fps');
	this.element.innerHTML = `
		<div class="fps-bg"></div>
		<canvas class="fps-canvas"></canvas>
		<span class="fps-text">fps <span class="fps-value">60.0</span></span>
	`;
	this.container.appendChild(this.element);

	this.canvas = this.element.querySelector('.fps-canvas');
	this.textEl = this.element.querySelector('.fps-text');
	this.valueEl = this.element.querySelector('.fps-value');
	this.bgEl = this.element.querySelector('.fps-bg');

	let style = opts.css || opts.style || ``;
	if (typeof style === 'object') style = css(style);

	let posCss = ``;
	switch (opts.position) {
		case 'top-left':
			posCss = `left: 0; top: 0;`;
			break;
		case 'top-right':
			posCss = `right: 0; top: 0;`;
			break;
		case 'bottom-right':
			posCss = `right: 0; bottom: 0;`;
			break;
		case 'bottom-left':
			posCss = `left: 0; bottom: 0;`;
			break;
		default:
			posCss = `left: 0; bottom: 0;`;
	}

	this.element.style.cssText = `
		line-height: 1;
		position: absolute;
		font-family: Roboto, sans-serif;
		z-index: 1;
		font-weight: 300;
		font-size: small;
		padding: 1rem;
		${posCss}` + (opts.color ? `color: ${opts.color}` : ``) + style;

	this.canvas.style.cssText = `
		position: relative;
		width: 2em;
		height: 1em;
		display: block;
		float: left;
		margin-right: .333em;
	`;

	this.bgEl.style.cssText = `
		position: absolute;
		height: 1em;
		width: 2em;
		background: currentcolor;
		opacity: .1;
	`;

	this.canvas.width = parseInt(getComputedStyle(this.canvas).width) || 1;
	this.canvas.height = parseInt(getComputedStyle(this.canvas).height) || 1;

	this.context = this.canvas.getContext('2d');

	let ctx = this.context;
	let w = this.canvas.width;
	let h = this.canvas.height;
	let count = 0;
	let lastTime = 0;
	let values = opts.values || Array(this.canvas.width);
	let period = opts.period || 1000;
	let max = opts.max || 100;

	//enable update routine
	let that = this;
	raf(function measure() {
		count++;
		let t = now();

		if (t - lastTime > period) {
			lastTime = t;
			values.push(count / (max * period * 0.001));
			values = values.slice(-w);
			count = 0;

			ctx.clearRect(0, 0, w, h);
			ctx.fillStyle = getComputedStyle(that.canvas).color;
			for (let i = w; i--;) {
				let value = values[i];
				if (value == null) break;
				ctx.fillRect(i, h - h * value, 1, h * value);
			}

			that.valueEl.innerHTML = (values[values.length - 1] * max).toFixed(1);
		}

		raf(measure);
	});
}

},{"raf":82,"right-now":85,"to-css":111}],42:[function(require,module,exports){
'use strict';

module.exports = gaussRandom;

function gaussRandom() {
  return Math.sqrt(-2.0 * Math.log(Math.random())) * Math.cos(2.0 * Math.PI * Math.random());
}

},{}],43:[function(require,module,exports){
(function (global){
"use strict";

if (global.AnalyserNode && !global.AnalyserNode.prototype.getFloatTimeDomainData) {
  var uint8 = new Uint8Array(2048);
  global.AnalyserNode.prototype.getFloatTimeDomainData = function (array) {
    this.getByteTimeDomainData(uint8);
    for (var i = 0, imax = array.length; i < imax; i++) {
      array[i] = (uint8[i] - 128) * 0.0078125;
    }
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],44:[function(require,module,exports){
/** generate unique id for selector */
var counter = Date.now() % 1e9;

module.exports = function getUid() {
	return (Math.random() * 1e9 >>> 0) + counter++;
};

},{}],45:[function(require,module,exports){
module.exports = distance;

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x * x + y * y);
}

},{}],46:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

},{}],47:[function(require,module,exports){
(function (global, factory) {
	if (typeof define === 'function' && define.amd) {
		define(['exports', 'module'], factory);
	} else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
		factory(exports, module);
	} else {
		var mod = {
			exports: {}
		};
		factory(mod.exports, mod);
		global.Impetus = mod.exports;
	}
})(this, function (exports, module) {
	'use strict';

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError('Cannot call a class as a function');
		}
	}

	var stopThresholdDefault = 0.3;
	var bounceDeceleration = 0.04;
	var bounceAcceleration = 0.11;

	var Impetus = function Impetus(_ref) {
		var _ref$source = _ref.source;
		var sourceEl = _ref$source === undefined ? document : _ref$source;
		var updateCallback = _ref.update;
		var _ref$multiplier = _ref.multiplier;
		var multiplier = _ref$multiplier === undefined ? 1 : _ref$multiplier;
		var _ref$friction = _ref.friction;
		var friction = _ref$friction === undefined ? 0.92 : _ref$friction;
		var initialValues = _ref.initialValues;
		var boundX = _ref.boundX;
		var boundY = _ref.boundY;
		var _ref$bounce = _ref.bounce;
		var bounce = _ref$bounce === undefined ? true : _ref$bounce;

		_classCallCheck(this, Impetus);

		var boundXmin, boundXmax, boundYmin, boundYmax, pointerLastX, pointerLastY, pointerCurrentX, pointerCurrentY, pointerId, decVelX, decVelY;
		var targetX = 0;
		var targetY = 0;
		var stopThreshold = stopThresholdDefault * multiplier;
		var ticking = false;
		var pointerActive = false;
		var paused = false;
		var decelerating = false;
		var trackingPoints = [];

		/**
   * Initialize instance
   */
		(function init() {
			sourceEl = typeof sourceEl === 'string' ? document.querySelector(sourceEl) : sourceEl;
			if (!sourceEl) {
				throw new Error('IMPETUS: source not found.');
			}

			if (!updateCallback) {
				throw new Error('IMPETUS: update function not defined.');
			}

			if (initialValues) {
				if (initialValues[0]) {
					targetX = initialValues[0];
				}
				if (initialValues[1]) {
					targetY = initialValues[1];
				}
				callUpdateCallback();
			}

			// Initialize bound values
			if (boundX) {
				boundXmin = boundX[0];
				boundXmax = boundX[1];
			}
			if (boundY) {
				boundYmin = boundY[0];
				boundYmax = boundY[1];
			}

			sourceEl.addEventListener('touchstart', onDown);
			sourceEl.addEventListener('mousedown', onDown);
		})();

		/**
   * Disable movement processing
   * @public
   */
		this.pause = function () {
			pointerActive = false;
			paused = true;
		};

		/**
   * Enable movement processing
   * @public
   */
		this.resume = function () {
			paused = false;
		};

		/**
   * Update the current x and y values
   * @public
   * @param {Number} x
   * @param {Number} y
   */
		this.setValues = function (x, y) {
			if (typeof x === 'number') {
				targetX = x;
			}
			if (typeof y === 'number') {
				targetY = y;
			}
		};

		/**
   * Update the multiplier value
   * @public
   * @param {Number} val
   */
		this.setMultiplier = function (val) {
			multiplier = val;
			stopThreshold = stopThresholdDefault * multiplier;
		};

		/**
   * Executes the update function
   */
		function callUpdateCallback() {
			updateCallback.call(sourceEl, targetX, targetY);
		}

		/**
   * Creates a custom normalized event object from touch and mouse events
   * @param  {Event} ev
   * @returns {Object} with x, y, and id properties
   */
		function normalizeEvent(ev) {
			if (ev.type === 'touchmove' || ev.type === 'touchstart' || ev.type === 'touchend') {
				var touch = ev.targetTouches[0] || ev.changedTouches[0];
				return {
					x: touch.clientX,
					y: touch.clientY,
					id: touch.identifier
				};
			} else {
				// mouse events
				return {
					x: ev.clientX,
					y: ev.clientY,
					id: null
				};
			}
		}

		/**
   * Initializes movement tracking
   * @param  {Object} ev Normalized event
   */
		function onDown(ev) {
			var event = normalizeEvent(ev);
			if (!pointerActive && !paused) {
				pointerActive = true;
				decelerating = false;
				pointerId = event.id;

				pointerLastX = pointerCurrentX = event.x;
				pointerLastY = pointerCurrentY = event.y;
				trackingPoints = [];
				addTrackingPoint(pointerLastX, pointerLastY);

				document.addEventListener('touchmove', onMove);
				document.addEventListener('touchend', onUp);
				document.addEventListener('touchcancel', stopTracking);
				document.addEventListener('mousemove', onMove);
				document.addEventListener('mouseup', onUp);
			}
		}

		/**
   * Handles move events
   * @param  {Object} ev Normalized event
   */
		function onMove(ev) {
			ev.preventDefault();
			var event = normalizeEvent(ev);

			if (pointerActive && event.id === pointerId) {
				pointerCurrentX = event.x;
				pointerCurrentY = event.y;
				addTrackingPoint(pointerLastX, pointerLastY);
				requestTick();
			}
		}

		/**
   * Handles up/end events
   * @param {Object} ev Normalized event
   */
		function onUp(ev) {
			var event = normalizeEvent(ev);

			if (pointerActive && event.id === pointerId) {
				stopTracking();
			}
		}

		/**
   * Stops movement tracking, starts animation
   */
		function stopTracking() {
			pointerActive = false;
			addTrackingPoint(pointerLastX, pointerLastY);
			startDecelAnim();

			document.removeEventListener('touchmove', onMove);
			document.removeEventListener('touchend', onUp);
			document.removeEventListener('touchcancel', stopTracking);
			document.removeEventListener('mouseup', onUp);
			document.removeEventListener('mousemove', onMove);
		}

		/**
   * Records movement for the last 100ms
   * @param {number} x
   * @param {number} y [description]
   */
		function addTrackingPoint(x, y) {
			var time = Date.now();
			while (trackingPoints.length > 0) {
				if (time - trackingPoints[0].time <= 100) {
					break;
				}
				trackingPoints.shift();
			}

			trackingPoints.push({ x: x, y: y, time: time });
		}

		/**
   * Calculate new values, call update function
   */
		function updateAndRender() {
			var pointerChangeX = pointerCurrentX - pointerLastX;
			var pointerChangeY = pointerCurrentY - pointerLastY;

			targetX += pointerChangeX * multiplier;
			targetY += pointerChangeY * multiplier;

			if (bounce) {
				var diff = checkBounds();
				if (diff.x !== 0) {
					targetX -= pointerChangeX * dragOutOfBoundsMultiplier(diff.x) * multiplier;
				}
				if (diff.y !== 0) {
					targetY -= pointerChangeY * dragOutOfBoundsMultiplier(diff.y) * multiplier;
				}
			} else {
				checkBounds(true);
			}

			callUpdateCallback();

			pointerLastX = pointerCurrentX;
			pointerLastY = pointerCurrentY;
			ticking = false;
		}

		/**
   * Returns a value from around 0.5 to 1, based on distance
   * @param {Number} val
   */
		function dragOutOfBoundsMultiplier(val) {
			return 0.000005 * Math.pow(val, 2) + 0.0001 * val + 0.55;
		}

		/**
   * prevents animating faster than current framerate
   */
		function requestTick() {
			if (!ticking) {
				requestAnimFrame(updateAndRender);
			}
			ticking = true;
		}

		/**
   * Determine position relative to bounds
   * @param {Boolean} restrict Whether to restrict target to bounds
   */
		function checkBounds(restrict) {
			var xDiff = 0;
			var yDiff = 0;

			if (boundXmin !== undefined && targetX < boundXmin) {
				xDiff = boundXmin - targetX;
			} else if (boundXmax !== undefined && targetX > boundXmax) {
				xDiff = boundXmax - targetX;
			}

			if (boundYmin !== undefined && targetY < boundYmin) {
				yDiff = boundYmin - targetY;
			} else if (boundYmax !== undefined && targetY > boundYmax) {
				yDiff = boundYmax - targetY;
			}

			if (restrict) {
				if (xDiff !== 0) {
					targetX = xDiff > 0 ? boundXmin : boundXmax;
				}
				if (yDiff !== 0) {
					targetY = yDiff > 0 ? boundYmin : boundYmax;
				}
			}

			return {
				x: xDiff,
				y: yDiff,
				inBounds: xDiff === 0 && yDiff === 0
			};
		}

		/**
   * Initialize animation of values coming to a stop
   */
		function startDecelAnim() {
			var firstPoint = trackingPoints[0];
			var lastPoint = trackingPoints[trackingPoints.length - 1];

			var xOffset = lastPoint.x - firstPoint.x;
			var yOffset = lastPoint.y - firstPoint.y;
			var timeOffset = lastPoint.time - firstPoint.time;

			var D = timeOffset / 15 / multiplier;

			decVelX = xOffset / D || 0; // prevent NaN
			decVelY = yOffset / D || 0;

			var diff = checkBounds();

			if (Math.abs(decVelX) > 1 || Math.abs(decVelY) > 1 || !diff.inBounds) {
				decelerating = true;
				requestAnimFrame(stepDecelAnim);
			}
		}

		/**
   * Animates values slowing down
   */
		function stepDecelAnim() {
			if (!decelerating) {
				return;
			}

			decVelX *= friction;
			decVelY *= friction;

			targetX += decVelX;
			targetY += decVelY;

			var diff = checkBounds();

			if (Math.abs(decVelX) > stopThreshold || Math.abs(decVelY) > stopThreshold || !diff.inBounds) {

				if (bounce) {
					var reboundAdjust = 2.5;

					if (diff.x !== 0) {
						if (diff.x * decVelX <= 0) {
							decVelX += diff.x * bounceDeceleration;
						} else {
							var adjust = diff.x > 0 ? reboundAdjust : -reboundAdjust;
							decVelX = (diff.x + adjust) * bounceAcceleration;
						}
					}
					if (diff.y !== 0) {
						if (diff.y * decVelY <= 0) {
							decVelY += diff.y * bounceDeceleration;
						} else {
							var adjust = diff.y > 0 ? reboundAdjust : -reboundAdjust;
							decVelY = (diff.y + adjust) * bounceAcceleration;
						}
					}
				} else {
					if (diff.x !== 0) {
						if (diff.x > 0) {
							targetX = boundXmin;
						} else {
							targetX = boundXmax;
						}
						decVelX = 0;
					}
					if (diff.y !== 0) {
						if (diff.y > 0) {
							targetY = boundYmin;
						} else {
							targetY = boundYmax;
						}
						decVelY = 0;
					}
				}

				callUpdateCallback();

				requestAnimFrame(stepDecelAnim);
			} else {
				decelerating = false;
			}
		}
	}

	/**
  * @see http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
  */
	;

	module.exports = Impetus;
	var requestAnimFrame = function () {
		return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
			window.setTimeout(callback, 1000 / 60);
		};
	}();
});

},{}],48:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

},{}],49:[function(require,module,exports){
/**
 * @module  input-number
 */

const caret = require('caret-position2');
const clamp = require('mumath/clamp');
const round = require('mumath/round');
const keys = {
		38: 'up',
		40: 'down'
};
const numRE = /[\-\.0-9]/;

module.exports = numerify;

function numerify(input, opts) {
		opts = opts || {};
		opts.step = opts.step || (opts.min && opts.max ? opts.max - opts.min / 100 : 1);
		opts.max = opts.max || Infinity;
		opts.min = opts.min || -Infinity;
		opts.precision = opts.precision || 0.00001;

		var focused = false;

		input.addEventListener('keydown', e => {
				let key = keys[e.which];

				if (!key) return;

				e.preventDefault();

				let str = input.value;
				let pos = caret.get(input);

				//parse left side
				let left = pos.start;
				while (numRE.test(str[left - 1])) {
						left--;
				}

				//parse right side
				let right = pos.end;
				while (numRE.test(str[right])) {
						right++;
				}

				let numStr = str.slice(left, right);

				if (!numStr) return;

				let number = parseFloat(numStr);

				if (key === 'up') {
						number = clamp(number + opts.step, opts.min, opts.max);
				} else {
						number = clamp(number - opts.step, opts.min, opts.max);
				}
				number = round(number, opts.precision);

				let leftStr = str.slice(0, left);
				let rightStr = str.slice(right);

				let result = leftStr + number + rightStr;

				input.value = result;

				caret.set(input, left, result.length - rightStr.length);

				//resurrect suppressed event
				let inputEvent = new Event('input');
				input.dispatchEvent(inputEvent);

				//emulate change event
				if (!focused) {
						focused = true;
						input.addEventListener('blur', function change() {
								input.removeEventListener('blur', change);
								let changeEvent = new Event('change');
								input.dispatchEvent(changeEvent);
								focused = false;
						});
				}
		});

		return input;
}

},{"caret-position2":21,"mumath/clamp":70,"mumath/round":72}],50:[function(require,module,exports){
(function (global){
'use strict';

var cache = {};

function noop() {}

module.exports = !global.document ? noop : insertStyles;

function insertStyles(styles, options) {
  var id = options && options.id || styles;

  var element = cache[id] = cache[id] || createStyle(id);

  if ('textContent' in element) {
    element.textContent = styles;
  } else {
    element.styleSheet.cssText = styles;
  }
}

function createStyle(id) {
  var element = document.getElementById(id);

  if (element) return element;

  element = document.createElement('style');
  element.setAttribute('type', 'text/css');

  document.head.appendChild(element);

  return element;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],51:[function(require,module,exports){
module.exports = isMobile;

function isMobile(ua) {
  if (!ua && typeof navigator != 'undefined') ua = navigator.userAgent;
  if (ua && ua.headers && typeof ua.headers['user-agent'] == 'string') {
    ua = ua.headers['user-agent'];
  }
  if (typeof ua != 'string') return false;

  return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(ua) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(ua.substr(0, 4))
  );
}

},{}],52:[function(require,module,exports){
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function isNumber(n) {
  return !!+n && !Array.isArray(n) && isFinite(n) || n === '0' || n === 0;
};

},{}],53:[function(require,module,exports){
(function (root) {
  'use strict';

  function isNumeric(v) {
    if (typeof v === 'number' && !isNaN(v)) return true;
    v = (v || '').toString().trim();
    if (!v) return false;
    return !isNaN(v);
  }

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = isNumeric;
    }
    exports.isNumeric = isNumeric;
  } else if (typeof define === 'function' && define.amd) {
    define([], function () {
      return isNumeric;
    });
  } else {
    root.isNumeric = isNumeric;
  }
})(this);

},{}],54:[function(require,module,exports){
'use strict';

var toString = Object.prototype.toString;

module.exports = function (x) {
	var prototype;
	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
};

},{}],55:[function(require,module,exports){
module.exports = extend;

/*
  var obj = {a: 3, b: 5};
  extend(obj, {a: 4, c: 8}); // {a: 4, b: 5, c: 8}
  obj; // {a: 4, b: 5, c: 8}

  var obj = {a: 3, b: 5};
  extend({}, obj, {a: 4, c: 8}); // {a: 4, b: 5, c: 8}
  obj; // {a: 3, b: 5}

  var arr = [1, 2, 3];
  var obj = {a: 3, b: 5};
  extend(obj, {c: arr}); // {a: 3, b: 5, c: [1, 2, 3]}
  arr.push[4];
  obj; // {a: 3, b: 5, c: [1, 2, 3, 4]}

  var arr = [1, 2, 3];
  var obj = {a: 3, b: 5};
  extend(true, obj, {c: arr}); // {a: 3, b: 5, c: [1, 2, 3]}
  arr.push[4];
  obj; // {a: 3, b: 5, c: [1, 2, 3]}
*/

function extend(obj1, obj2 /*, [objn]*/) {
  var args = [].slice.call(arguments);
  var deep = false;
  if (typeof args[0] === 'boolean') {
    deep = args.shift();
  }
  var result = args[0];
  var extenders = args.slice(1);
  var len = extenders.length;
  for (var i = 0; i < len; i++) {
    var extender = extenders[i];
    for (var key in extender) {
      // include prototype properties
      var value = extender[key];
      if (deep && value && typeof value == 'object') {
        var base = Array.isArray(value) ? [] : {};
        result[key] = extend(true, result[key] || base, value);
      } else {
        result[key] = value;
      }
    }
  }
  return result;
}

},{}],56:[function(require,module,exports){
/**
 * lodash 3.1.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray');

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `_.flatten` with added support for restricting
 * flattening and specifying the start index.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {boolean} [isDeep] Specify a deep flatten.
 * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, isDeep, isStrict, result) {
  result || (result = []);

  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index];
    if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) {
      if (isDeep) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, isDeep, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = baseFlatten;

},{"lodash.isarguments":62,"lodash.isarray":63}],57:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isFunction = require('lodash.isfunction');

/**
 * The base implementation of `_.functions` which creates an array of
 * `object` function property names filtered from those provided.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Array} props The property names to filter.
 * @returns {Array} Returns the new array of filtered property names.
 */
function baseFunctions(object, props) {
  var index = -1,
      length = props.length,
      resIndex = -1,
      result = [];

  while (++index < length) {
    var key = props[index];
    if (isFunction(object[key])) {
      result[++resIndex] = key;
    }
  }
  return result;
}

module.exports = baseFunctions;

},{"lodash.isfunction":64}],58:[function(require,module,exports){
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var root = require('lodash._root');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_BOUND_FLAG = 4,
    CURRY_FLAG = 8,
    CURRY_RIGHT_FLAG = 16,
    PARTIAL_FLAG = 32,
    PARTIAL_RIGHT_FLAG = 64,
    ARY_FLAG = 128,
    FLIP_FLAG = 512;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {...*} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  var length = args.length;
  switch (length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = typeof value == 'number' || reIsUint.test(value) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = -1,
      result = [];

  while (++index < length) {
    if (array[index] === placeholder) {
      array[index] = PLACEHOLDER;
      result[++resIndex] = index;
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = function () {
  function object() {}
  return function (prototype) {
    if (isObject(prototype)) {
      object.prototype = prototype;
      var result = new object();
      object.prototype = undefined;
    }
    return result || {};
  };
}();

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array|Object} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders) {
  var holdersLength = holders.length,
      argsIndex = -1,
      argsLength = nativeMax(args.length - holdersLength, 0),
      leftIndex = -1,
      leftLength = partials.length,
      result = Array(leftLength + argsLength);

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    result[holders[argsIndex]] = args[argsIndex];
  }
  while (argsLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array|Object} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders) {
  var holdersIndex = -1,
      holdersLength = holders.length,
      argsIndex = -1,
      argsLength = nativeMax(args.length - holdersLength, 0),
      rightIndex = -1,
      rightLength = partials.length,
      result = Array(argsLength + rightLength);

  while (++argsIndex < argsLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    result[offset + holders[holdersIndex]] = args[argsIndex++];
  }
  return result;
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Creates a function that wraps `func` to invoke it with the optional `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createBaseWrapper(func, bitmask, thisArg) {
  var isBind = bitmask & BIND_FLAG,
      Ctor = createCtorWrapper(func);

  function wrapper() {
    var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtorWrapper(Ctor) {
  return function () {
    // Use a `switch` statement to work with class constructors.
    // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

/**
 * Creates a function that wraps `func` to enable currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
 * @param {number} arity The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createCurryWrapper(func, bitmask, arity) {
  var Ctor = createCtorWrapper(func);

  function wrapper() {
    var length = arguments.length,
        index = length,
        args = Array(length),
        fn = this && this !== root && this instanceof wrapper ? Ctor : func,
        placeholder = wrapper.placeholder;

    while (index--) {
      args[index] = arguments[index];
    }
    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);

    length -= holders.length;
    return length < arity ? createRecurryWrapper(func, bitmask, createHybridWrapper, placeholder, undefined, args, holders, undefined, undefined, arity - length) : apply(fn, this, args);
  }
  return wrapper;
}

/**
 * Creates a function that wraps `func` to invoke it with optional `this`
 * binding of `thisArg`, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & ARY_FLAG,
      isBind = bitmask & BIND_FLAG,
      isBindKey = bitmask & BIND_KEY_FLAG,
      isCurry = bitmask & CURRY_FLAG,
      isCurryRight = bitmask & CURRY_RIGHT_FLAG,
      isFlip = bitmask & FLIP_FLAG,
      Ctor = isBindKey ? undefined : createCtorWrapper(func);

  function wrapper() {
    var length = arguments.length,
        index = length,
        args = Array(length);

    while (index--) {
      args[index] = arguments[index];
    }
    if (partials) {
      args = composeArgs(args, partials, holders);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight);
    }
    if (isCurry || isCurryRight) {
      var placeholder = wrapper.placeholder,
          argsHolders = replaceHolders(args, placeholder);

      length -= argsHolders.length;
      if (length < arity) {
        return createRecurryWrapper(func, bitmask, createHybridWrapper, placeholder, thisArg, args, argsHolders, argPos, ary, arity - length);
      }
    }
    var thisBinding = isBind ? thisArg : this,
        fn = isBindKey ? thisBinding[func] : func;

    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && args.length > 1) {
      args.reverse();
    }
    if (isAry && ary < args.length) {
      args.length = ary;
    }
    if (this && this !== root && this instanceof wrapper) {
      fn = Ctor || createCtorWrapper(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}

/**
 * Creates a function that wraps `func` to invoke it with the optional `this`
 * binding of `thisArg` and the `partials` prepended to those provided to
 * the wrapper.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartialWrapper(func, bitmask, thisArg, partials) {
  var isBind = bitmask & BIND_FLAG,
      Ctor = createCtorWrapper(func);

  function wrapper() {
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = this && this !== root && this instanceof wrapper ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

/**
 * Creates a function that wraps `func` to continue currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.
 * @param {Function} wrapFunc The function to create the `func` wrapper.
 * @param {*} placeholder The placeholder to replace.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & CURRY_FLAG,
      newArgPos = argPos ? copyArray(argPos) : undefined,
      newsHolders = isCurry ? holders : undefined,
      newHoldersRight = isCurry ? undefined : holders,
      newPartials = isCurry ? partials : undefined,
      newPartialsRight = isCurry ? undefined : partials;

  bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
  bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

  if (!(bitmask & CURRY_BOUND_FLAG)) {
    bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
  }
  var result = wrapFunc(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, arity);

  result.placeholder = placeholder;
  return result;
}

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask of wrapper flags.
 *  The bitmask may be composed of the following flags:
 *     1 - `_.bind`
 *     2 - `_.bindKey`
 *     4 - `_.curry` or `_.curryRight` of a bound function
 *     8 - `_.curry`
 *    16 - `_.curryRight`
 *    32 - `_.partial`
 *    64 - `_.partialRight`
 *   128 - `_.rearg`
 *   256 - `_.ary`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & BIND_KEY_FLAG;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
    partials = holders = undefined;
  }
  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
  arity = arity === undefined ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;

  if (bitmask & PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = undefined;
  }
  var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] == null ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);

  if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
    bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == BIND_FLAG) {
    var result = createBaseWrapper(func, bitmask, thisArg);
  } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
    result = createCurryWrapper(func, bitmask, arity);
  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
    result = createPartialWrapper(func, bitmask, thisArg, partials);
  } else {
    result = createHybridWrapper.apply(undefined, newData);
  }
  return result;
}

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin(indexes.length, arrLength),
      oldArray = copyArray(array);

  while (length--) {
    var index = indexes[length];
    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array constructors, and
  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Converts `value` to an integer.
 *
 * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3');
 * // => 3
 */
function toInteger(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  var remainder = value % 1;
  return value === value ? remainder ? value - remainder : value : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3);
 * // => 3
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3');
 * // => 3
 */
function toNumber(value) {
  if (isObject(value)) {
    var other = isFunction(value.valueOf) ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = createWrapper;

},{"lodash._root":59}],59:[function(require,module,exports){
(function (global){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to determine if values are of the language type `Object`. */
var objectTypes = {
  'function': true,
  'object': true
};

/** Detect free variable `exports`. */
var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType ? exports : undefined;

/** Detect free variable `module`. */
var freeModule = objectTypes[typeof module] && module && !module.nodeType ? module : undefined;

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(objectTypes[typeof self] && self);

/** Detect free variable `window`. */
var freeWindow = checkGlobal(objectTypes[typeof window] && window);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(objectTypes[typeof this] && this);

/**
 * Used as a reference to the global object.
 *
 * The `this` value is used if it's the global object to avoid Greasemonkey's
 * restricted `window` object, otherwise the `window` object is used.
 */
var root = freeGlobal || freeWindow !== (thisGlobal && thisGlobal.window) && freeWindow || freeSelf || thisGlobal || Function('return this')();

/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return value && value.Object === Object ? value : null;
}

module.exports = root;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],60:[function(require,module,exports){
/**
 * lodash 3.1.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseFlatten = require('lodash._baseflatten'),
    createWrapper = require('lodash._createwrapper'),
    functions = require('lodash.functions'),
    restParam = require('lodash.restparam');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1;

/**
 * Binds methods of an object to the object itself, overwriting the existing
 * method. Method names may be specified as individual arguments or as arrays
 * of method names. If no method names are provided all enumerable function
 * properties, own and inherited, of `object` are bound.
 *
 * **Note:** This method does not set the `length` property of bound functions.
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Object} object The object to bind and assign the bound methods to.
 * @param {...(string|string[])} [methodNames] The object method names to bind,
 *  specified as individual method names or arrays of method names.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var view = {
 *   'label': 'docs',
 *   'onClick': function() {
 *     console.log('clicked ' + this.label);
 *   }
 * };
 *
 * _.bindAll(view);
 * jQuery('#docs').on('click', view.onClick);
 * // => logs 'clicked docs' when the element is clicked
 */
var bindAll = restParam(function (object, methodNames) {
  methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);

  var index = -1,
      length = methodNames.length;

  while (++index < length) {
    var key = methodNames[index];
    object[key] = createWrapper(object[key], BIND_FLAG, object);
  }
  return object;
});

module.exports = bindAll;

},{"lodash._baseflatten":56,"lodash._createwrapper":58,"lodash.functions":61,"lodash.restparam":66}],61:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseFunctions = require('lodash._basefunctions'),
    keysIn = require('lodash.keysin');

/**
 * Creates an array of function property names from all enumerable properties,
 * own and inherited, of `object`.
 *
 * @static
 * @memberOf _
 * @alias methods
 * @category Object
 * @param {Object} object The object to inspect.
 * @returns {Array} Returns the new array of property names.
 * @example
 *
 * _.functions(_);
 * // => ['all', 'any', 'bind', ...]
 */
function functions(object) {
  return baseFunctions(object, keysIn(object));
}

module.exports = functions;

},{"lodash._basefunctions":57,"lodash.keysin":65}],62:[function(require,module,exports){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isArguments;

},{}],63:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function (value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isArray;

},{}],64:[function(require,module,exports){
/**
 * lodash 3.0.8 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array constructors, and
  // PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isFunction;

},{}],65:[function(require,module,exports){
/**
 * lodash 3.0.8 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray');

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = typeof value == 'number' || reIsUint.test(value) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = length && isLength(length) && (isArray(object) || isArguments(object)) && length || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = index + '';
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keysIn;

},{"lodash.isarguments":62,"lodash.isarray":63}],66:[function(require,module,exports){
/**
 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? func.length - 1 : +start || 0, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0:
        return func.call(this, rest);
      case 1:
        return func.call(this, args[0], rest);
      case 2:
        return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;

},{}],67:[function(require,module,exports){
/**
 * Special language-specific overrides.
 *
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 *
 * @type {Object}
 */
var LANGUAGES = {
  tr: {
    regexp: /\u0130|\u0049|\u0049\u0307/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  az: {
    regexp: /[\u0130]/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  lt: {
    regexp: /[\u0049\u004A\u012E\u00CC\u00CD\u0128]/g,
    map: {
      '\u0049': '\u0069\u0307',
      '\u004A': '\u006A\u0307',
      '\u012E': '\u012F\u0307',
      '\u00CC': '\u0069\u0307\u0300',
      '\u00CD': '\u0069\u0307\u0301',
      '\u0128': '\u0069\u0307\u0303'
    }
  }

  /**
   * Lowercase a string.
   *
   * @param  {String} str
   * @return {String}
   */
};module.exports = function (str, locale) {
  var lang = LANGUAGES[locale];

  str = str == null ? '' : String(str);

  if (lang) {
    str = str.replace(lang.regexp, function (m) {
      return lang.map[m];
    });
  }

  return str.toLowerCase();
};

},{}],68:[function(require,module,exports){
var rootPosition = { left: 0, top: 0 };

module.exports = mouseEventOffset;
function mouseEventOffset(ev, target, out) {
  target = target || ev.currentTarget || ev.srcElement;
  if (!Array.isArray(out)) {
    out = [0, 0];
  }
  var cx = ev.clientX || 0;
  var cy = ev.clientY || 0;
  var rect = getBoundingClientOffset(target);
  out[0] = cx - rect.left;
  out[1] = cy - rect.top;
  return out;
}

function getBoundingClientOffset(element) {
  if (element === window || element === document || element === document.body) {
    return rootPosition;
  } else {
    return element.getBoundingClientRect();
  }
}

},{}],69:[function(require,module,exports){
'use strict';

var toPX = require('to-px');

module.exports = mouseWheelListen;

function mouseWheelListen(element, callback, noScroll) {
  if (typeof element === 'function') {
    noScroll = !!callback;
    callback = element;
    element = window;
  }
  var lineHeight = toPX('ex', element);
  var listener = function (ev) {
    if (noScroll) {
      ev.preventDefault();
    }
    var dx = ev.deltaX || 0;
    var dy = ev.deltaY || 0;
    var dz = ev.deltaZ || 0;
    var mode = ev.deltaMode;
    var scale = 1;
    switch (mode) {
      case 1:
        scale = lineHeight;
        break;
      case 2:
        scale = window.innerHeight;
        break;
    }
    dx *= scale;
    dy *= scale;
    dz *= scale;
    if (dx || dy || dz) {
      return callback(dx, dy, dz, ev);
    }
  };
  element.addEventListener('wheel', listener);
  return listener;
}

},{"to-px":113}],70:[function(require,module,exports){
/**
 * Clamp value.
 * Detects proper clamp min/max.
 *
 * @param {number} a Current value to cut off
 * @param {number} min One side limit
 * @param {number} max Other side limit
 *
 * @return {number} Clamped value
 */

module.exports = require('./wrap')(function (a, min, max) {
  return max > min ? Math.max(Math.min(a, max), min) : Math.max(Math.min(a, min), max);
});

},{"./wrap":73}],71:[function(require,module,exports){
/**
 * @module  mumath/precision
 *
 * Get precision from float:
 *
 * @example
 * 1.1 → 1, 1234 → 0, .1234 → 4
 *
 * @param {number} n
 *
 * @return {number} decimap places
 */

module.exports = require('./wrap')(function (n) {
  var s = n + '',
      d = s.indexOf('.') + 1;

  return !d ? 0 : s.length - d;
});

},{"./wrap":73}],72:[function(require,module,exports){
/**
 * Precision round
 *
 * @param {number} value
 * @param {number} step Minimal discrete to round
 *
 * @return {number}
 *
 * @example
 * toPrecision(213.34, 1) == 213
 * toPrecision(213.34, .1) == 213.3
 * toPrecision(213.34, 10) == 210
 */
var precision = require('./precision');

module.exports = require('./wrap')(function (value, step) {
  if (step === 0) return value;
  if (!step) return Math.round(value);
  step = parseFloat(step);
  value = Math.round(value / step) * step;
  return parseFloat(value.toFixed(precision(step)));
});

},{"./precision":71,"./wrap":73}],73:[function(require,module,exports){
/**
 * Get fn wrapped with array/object attrs recognition
 *
 * @return {Function} Target function
 */
module.exports = function (fn) {
	return function (a) {
		var args = arguments;
		if (a instanceof Array) {
			var result = new Array(a.length),
			    slice;
			for (var i = 0; i < a.length; i++) {
				slice = [];
				for (var j = 0, l = args.length, val; j < l; j++) {
					val = args[j] instanceof Array ? args[j][i] : args[j];
					val = val;
					slice.push(val);
				}
				result[i] = fn.apply(this, slice);
			}
			return result;
		} else if (typeof a === 'object') {
			var result = {},
			    slice;
			for (var i in a) {
				slice = [];
				for (var j = 0, l = args.length, val; j < l; j++) {
					val = typeof args[j] === 'object' ? args[j][i] : args[j];
					val = val;
					slice.push(val);
				}
				result[i] = fn.apply(this, slice);
			}
			return result;
		} else {
			return fn.apply(this, args);
		}
	};
};

},{}],74:[function(require,module,exports){
arguments[4][7][0].apply(exports,arguments)
},{"dup":7}],75:[function(require,module,exports){
/**
 * @module  pan-zoom
 *
 * Events for pan and zoom
 */
'use strict';

const Impetus = require('impetus');
const wheel = require('mouse-wheel');
const touchPinch = require('touch-pinch');
const position = require('touch-position');

module.exports = panzoom;

function panzoom(target, cb) {
	if (!target || !(cb instanceof Function)) return false;

	//enable panning
	let pos = position({
		element: target
	});

	let impetus;

	let lastY = 0,
	    lastX = 0;
	impetus = new Impetus({
		source: target,
		update: (x, y) => {
			let e = {
				type: 'mouse',
				dx: x - lastX, dy: y - lastY, dz: 0,
				x: pos[0], y: pos[1]
			};

			lastX = x;
			lastY = y;

			cb(e);
		},
		multiplier: 1,
		friction: .75
	});

	//enable zooming
	wheel(target, (dx, dy, dz, e) => {
		e.preventDefault();
		cb({
			type: 'mouse',
			dx: 0, dy: 0, dz: dy,
			x: pos[0], y: pos[1]
		});
	});

	//mobile pinch zoom
	let pinch = touchPinch(target);
	let mult = 2;
	let initialCoords;

	pinch.on('start', curr => {
		impetus && impetus.pause();

		let [f1, f2] = pinch.fingers;

		initialCoords = [f2.position[0] * .5 + f1.position[0] * .5, f2.position[1] * .5 + f1.position[1] * .5];
	});
	pinch.on('end', () => {
		initialCoords = null;

		impetus && impetus.resume();
	});
	pinch.on('change', (curr, prev) => {
		if (!pinch.pinching || !initialCoords) return;

		cb({
			type: 'touch',
			dx: 0, dy: 0, dz: -(curr - prev) * mult,
			x: initialCoords[0], y: initialCoords[1]
		});
	});
}

},{"impetus":47,"mouse-wheel":69,"touch-pinch":115,"touch-position":116}],76:[function(require,module,exports){
var sentenceCase = require('sentence-case'

/**
 * Param case a string.
 *
 * @param  {String} string
 * @param  {String} [locale]
 * @return {String}
 */
);module.exports = function (string, locale) {
  return sentenceCase(string, locale, '-');
};

},{"sentence-case":87}],77:[function(require,module,exports){
module.exports = function parseUnit(str, out) {
    if (!out) out = [0, ''];

    str = String(str);
    var num = parseFloat(str, 10);
    out[0] = num;
    out[1] = str.match(/[\d.\-\+]*\s*(.*)/)[1] || '';
    return out;
};

},{}],78:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.12.2
(function () {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if (typeof performance !== "undefined" && performance !== null && performance.now) {
    module.exports = function () {
      return performance.now();
    };
  } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
    module.exports = function () {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function () {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function () {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function () {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }
}).call(this);



}).call(this,require('_process'))
},{"_process":81}],79:[function(require,module,exports){
var div = null;
var prefixes = ['Webkit', 'Moz', 'O', 'ms'];

module.exports = function prefixStyle(prop) {
  // re-use a dummy div
  if (!div) {
    div = document.createElement('div');
  }

  var style = div.style;

  // prop exists without prefix
  if (prop in style) {
    return prop;
  }

  // borderRadius -> BorderRadius
  var titleCase = prop.charAt(0).toUpperCase() + prop.slice(1

  // find the vendor-prefixed prop
  );for (var i = prefixes.length; i >= 0; i--) {
    var name = prefixes[i] + titleCase;
    // e.g. WebkitBorderRadius or webkitBorderRadius
    if (name in style) {
      return name;
    }
  }

  return false;
};

},{}],80:[function(require,module,exports){
function identity(x) {
  return x;
}

module.exports = identity;
module.exports.dash = identity;
module.exports.dash = identity;

},{}],81:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

},{}],82:[function(require,module,exports){
(function (global){
var now = require('performance-now'),
    root = typeof window === 'undefined' ? global : window,
    vendors = ['moz', 'webkit'],
    suffix = 'AnimationFrame',
    raf = root['request' + suffix],
    caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

for (var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix];
  caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];
}

// Some versions of FF have rAF but not cAF
if (!raf || !caf) {
  var last = 0,
      id = 0,
      queue = [],
      frameDuration = 1000 / 60;

  raf = function (callback) {
    if (queue.length === 0) {
      var _now = now(),
          next = Math.max(0, frameDuration - (_now - last));
      last = next + _now;
      setTimeout(function () {
        var cp = queue.slice(0
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        );queue.length = 0;
        for (var i = 0; i < cp.length; i++) {
          if (!cp[i].cancelled) {
            try {
              cp[i].callback(last);
            } catch (e) {
              setTimeout(function () {
                throw e;
              }, 0);
            }
          }
        }
      }, Math.round(next));
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    });
    return id;
  };

  caf = function (handle) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i].handle === handle) {
        queue[i].cancelled = true;
      }
    }
  };
}

module.exports = function (fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn);
};
module.exports.cancel = function () {
  caf.apply(root, arguments);
};
module.exports.polyfill = function () {
  root.requestAnimationFrame = raf;
  root.cancelAnimationFrame = caf;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"performance-now":78}],83:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.createREGL = factory();
})(this, function () {
  'use strict';

  var arrayTypes = {
    "[object Int8Array]": 5120,
    "[object Int16Array]": 5122,
    "[object Int32Array]": 5124,
    "[object Uint8Array]": 5121,
    "[object Uint8ClampedArray]": 5121,
    "[object Uint16Array]": 5123,
    "[object Uint32Array]": 5125,
    "[object Float32Array]": 5126,
    "[object Float64Array]": 5121,
    "[object ArrayBuffer]": 5121
  };

  var isTypedArray = function (x) {
    return Object.prototype.toString.call(x) in arrayTypes;
  };

  var extend = function (base, opts) {
    var keys = Object.keys(opts);
    for (var i = 0; i < keys.length; ++i) {
      base[keys[i]] = opts[keys[i]];
    }
    return base;
  };

  // Error checking and parameter validation.
  //
  // Statements for the form `check.someProcedure(...)` get removed by
  // a browserify transform for optimized/minified bundles.
  //
  /* globals btoa */
  // only used for extracting shader names.  if btoa not present, then errors
  // will be slightly crappier
  function decodeB64(str) {
    if (typeof btoa !== 'undefined') {
      return btoa(str);
    }
    return 'base64:' + str;
  }

  function raise(message) {
    var error = new Error('(regl) ' + message);
    console.error(error);
    throw error;
  }

  function check(pred, message) {
    if (!pred) {
      raise(message);
    }
  }

  function encolon(message) {
    if (message) {
      return ': ' + message;
    }
    return '';
  }

  function checkParameter(param, possibilities, message) {
    if (!(param in possibilities)) {
      raise('unknown parameter (' + param + ')' + encolon(message) + '. possible values: ' + Object.keys(possibilities).join());
    }
  }

  function checkIsTypedArray(data, message) {
    if (!isTypedArray(data)) {
      raise('invalid parameter type' + encolon(message) + '. must be a typed array');
    }
  }

  function checkTypeOf(value, type, message) {
    if (typeof value !== type) {
      raise('invalid parameter type' + encolon(message) + '. expected ' + type + ', got ' + typeof value);
    }
  }

  function checkNonNegativeInt(value, message) {
    if (!(value >= 0 && (value | 0) === value)) {
      raise('invalid parameter type, (' + value + ')' + encolon(message) + '. must be a nonnegative integer');
    }
  }

  function checkOneOf(value, list, message) {
    if (list.indexOf(value) < 0) {
      raise('invalid value' + encolon(message) + '. must be one of: ' + list);
    }
  }

  var constructorKeys = ['gl', 'canvas', 'container', 'attributes', 'pixelRatio', 'extensions', 'optionalExtensions', 'profile', 'onDone'];

  function checkConstructor(obj) {
    Object.keys(obj).forEach(function (key) {
      if (constructorKeys.indexOf(key) < 0) {
        raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys);
      }
    });
  }

  function leftPad(str, n) {
    str = str + '';
    while (str.length < n) {
      str = ' ' + str;
    }
    return str;
  }

  function ShaderFile() {
    this.name = 'unknown';
    this.lines = [];
    this.index = {};
    this.hasErrors = false;
  }

  function ShaderLine(number, line) {
    this.number = number;
    this.line = line;
    this.errors = [];
  }

  function ShaderError(fileNumber, lineNumber, message) {
    this.file = fileNumber;
    this.line = lineNumber;
    this.message = message;
  }

  function guessCommand() {
    var error = new Error();
    var stack = (error.stack || error).toString();
    var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack);
    if (pat) {
      return pat[1];
    }
    var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack);
    if (pat2) {
      return pat2[1];
    }
    return 'unknown';
  }

  function guessCallSite() {
    var error = new Error();
    var stack = (error.stack || error).toString();
    var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack);
    if (pat) {
      return pat[1];
    }
    var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack);
    if (pat2) {
      return pat2[1];
    }
    return 'unknown';
  }

  function parseSource(source, command) {
    var lines = source.split('\n');
    var lineNumber = 1;
    var fileNumber = 0;
    var files = {
      unknown: new ShaderFile(),
      0: new ShaderFile()
    };
    files.unknown.name = files[0].name = command || guessCommand();
    files.unknown.lines.push(new ShaderLine(0, ''));
    for (var i = 0; i < lines.length; ++i) {
      var line = lines[i];
      var parts = /^\s*\#\s*(\w+)\s+(.+)\s*$/.exec(line);
      if (parts) {
        switch (parts[1]) {
          case 'line':
            var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2]);
            if (lineNumberInfo) {
              lineNumber = lineNumberInfo[1] | 0;
              if (lineNumberInfo[2]) {
                fileNumber = lineNumberInfo[2] | 0;
                if (!(fileNumber in files)) {
                  files[fileNumber] = new ShaderFile();
                }
              }
            }
            break;
          case 'define':
            var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2]);
            if (nameInfo) {
              files[fileNumber].name = nameInfo[1] ? decodeB64(nameInfo[2]) : nameInfo[2];
            }
            break;
        }
      }
      files[fileNumber].lines.push(new ShaderLine(lineNumber++, line));
    }
    Object.keys(files).forEach(function (fileNumber) {
      var file = files[fileNumber];
      file.lines.forEach(function (line) {
        file.index[line.number] = line;
      });
    });
    return files;
  }

  function parseErrorLog(errLog) {
    var result = [];
    errLog.split('\n').forEach(function (errMsg) {
      if (errMsg.length < 5) {
        return;
      }
      var parts = /^ERROR\:\s+(\d+)\:(\d+)\:\s*(.*)$/.exec(errMsg);
      if (parts) {
        result.push(new ShaderError(parts[1] | 0, parts[2] | 0, parts[3].trim()));
      } else if (errMsg.length > 0) {
        result.push(new ShaderError('unknown', 0, errMsg));
      }
    });
    return result;
  }

  function annotateFiles(files, errors) {
    errors.forEach(function (error) {
      var file = files[error.file];
      if (file) {
        var line = file.index[error.line];
        if (line) {
          line.errors.push(error);
          file.hasErrors = true;
          return;
        }
      }
      files.unknown.hasErrors = true;
      files.unknown.lines[0].errors.push(error);
    });
  }

  function checkShaderError(gl, shader, source, type, command) {
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      var errLog = gl.getShaderInfoLog(shader);
      var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex';
      checkCommandType(source, 'string', typeName + ' shader source must be a string', command);
      var files = parseSource(source, command);
      var errors = parseErrorLog(errLog);
      annotateFiles(files, errors);

      Object.keys(files).forEach(function (fileNumber) {
        var file = files[fileNumber];
        if (!file.hasErrors) {
          return;
        }

        var strings = [''];
        var styles = [''];

        function push(str, style) {
          strings.push(str);
          styles.push(style || '');
        }

        push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold');

        file.lines.forEach(function (line) {
          if (line.errors.length > 0) {
            push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold');
            push(line.line + '\n', 'color:red; background-color:yellow; font-weight:bold');

            // try to guess token
            var offset = 0;
            line.errors.forEach(function (error) {
              var message = error.message;
              var token = /^\s*\'(.*)\'\s*\:\s*(.*)$/.exec(message);
              if (token) {
                var tokenPat = token[1];
                message = token[2];
                switch (tokenPat) {
                  case 'assign':
                    tokenPat = '=';
                    break;
                }
                offset = Math.max(line.line.indexOf(tokenPat, offset), 0);
              } else {
                offset = 0;
              }

              push(leftPad('| ', 6));
              push(leftPad('^^^', offset + 3) + '\n', 'font-weight:bold');
              push(leftPad('| ', 6));
              push(message + '\n', 'font-weight:bold');
            });
            push(leftPad('| ', 6) + '\n');
          } else {
            push(leftPad(line.number, 4) + '|  ');
            push(line.line + '\n', 'color:red');
          }
        });
        if (typeof document !== 'undefined') {
          styles[0] = strings.join('%c');
          console.log.apply(console, styles);
        } else {
          console.log(strings.join(''));
        }
      });

      check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name);
    }
  }

  function checkLinkError(gl, program, fragShader, vertShader, command) {
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      var errLog = gl.getProgramInfoLog(program);
      var fragParse = parseSource(fragShader, command);
      var vertParse = parseSource(vertShader, command);

      var header = 'Error linking program with vertex shader, "' + vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"';

      if (typeof document !== 'undefined') {
        console.log('%c' + header + '\n%c' + errLog, 'color:red;text-decoration:underline;font-weight:bold', 'color:red');
      } else {
        console.log(header + '\n' + errLog);
      }
      check.raise(header);
    }
  }

  function saveCommandRef(object) {
    object._commandRef = guessCommand();
  }

  function saveDrawCommandInfo(opts, uniforms, attributes, stringStore) {
    saveCommandRef(opts);

    function id(str) {
      if (str) {
        return stringStore.id(str);
      }
      return 0;
    }
    opts._fragId = id(opts.static.frag);
    opts._vertId = id(opts.static.vert);

    function addProps(dict, set) {
      Object.keys(set).forEach(function (u) {
        dict[stringStore.id(u)] = true;
      });
    }

    var uniformSet = opts._uniformSet = {};
    addProps(uniformSet, uniforms.static);
    addProps(uniformSet, uniforms.dynamic);

    var attributeSet = opts._attributeSet = {};
    addProps(attributeSet, attributes.static);
    addProps(attributeSet, attributes.dynamic);

    opts._hasCount = 'count' in opts.static || 'count' in opts.dynamic || 'elements' in opts.static || 'elements' in opts.dynamic;
  }

  function commandRaise(message, command) {
    var callSite = guessCallSite();
    raise(message + ' in command ' + (command || guessCommand()) + (callSite === 'unknown' ? '' : ' called from ' + callSite));
  }

  function checkCommand(pred, message, command) {
    if (!pred) {
      commandRaise(message, command || guessCommand());
    }
  }

  function checkParameterCommand(param, possibilities, message, command) {
    if (!(param in possibilities)) {
      commandRaise('unknown parameter (' + param + ')' + encolon(message) + '. possible values: ' + Object.keys(possibilities).join(), command || guessCommand());
    }
  }

  function checkCommandType(value, type, message, command) {
    if (typeof value !== type) {
      commandRaise('invalid parameter type' + encolon(message) + '. expected ' + type + ', got ' + typeof value, command || guessCommand());
    }
  }

  function checkOptional(block) {
    block();
  }

  function checkFramebufferFormat(attachment, texFormats, rbFormats) {
    if (attachment.texture) {
      checkOneOf(attachment.texture._texture.internalformat, texFormats, 'unsupported texture format for attachment');
    } else {
      checkOneOf(attachment.renderbuffer._renderbuffer.format, rbFormats, 'unsupported renderbuffer format for attachment');
    }
  }

  var GL_CLAMP_TO_EDGE = 0x812F;

  var GL_NEAREST = 0x2600;
  var GL_NEAREST_MIPMAP_NEAREST = 0x2700;
  var GL_LINEAR_MIPMAP_NEAREST = 0x2701;
  var GL_NEAREST_MIPMAP_LINEAR = 0x2702;
  var GL_LINEAR_MIPMAP_LINEAR = 0x2703;

  var GL_BYTE = 5120;
  var GL_UNSIGNED_BYTE = 5121;
  var GL_SHORT = 5122;
  var GL_UNSIGNED_SHORT = 5123;
  var GL_INT = 5124;
  var GL_UNSIGNED_INT = 5125;
  var GL_FLOAT = 5126;

  var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
  var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
  var GL_UNSIGNED_SHORT_5_6_5 = 0x8363;
  var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA;

  var GL_HALF_FLOAT_OES = 0x8D61;

  var TYPE_SIZE = {};

  TYPE_SIZE[GL_BYTE] = TYPE_SIZE[GL_UNSIGNED_BYTE] = 1;

  TYPE_SIZE[GL_SHORT] = TYPE_SIZE[GL_UNSIGNED_SHORT] = TYPE_SIZE[GL_HALF_FLOAT_OES] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] = TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2;

  TYPE_SIZE[GL_INT] = TYPE_SIZE[GL_UNSIGNED_INT] = TYPE_SIZE[GL_FLOAT] = TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4;

  function pixelSize(type, channels) {
    if (type === GL_UNSIGNED_SHORT_5_5_5_1 || type === GL_UNSIGNED_SHORT_4_4_4_4 || type === GL_UNSIGNED_SHORT_5_6_5) {
      return 2;
    } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
      return 4;
    } else {
      return TYPE_SIZE[type] * channels;
    }
  }

  function isPow2(v) {
    return !(v & v - 1) && !!v;
  }

  function checkTexture2D(info, mipData, limits) {
    var i;
    var w = mipData.width;
    var h = mipData.height;
    var c = mipData.channels;

    // Check texture shape
    check(w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize, 'invalid texture shape');

    // check wrap mode
    if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
      check(isPow2(w) && isPow2(h), 'incompatible wrap mode for texture, both width and height must be power of 2');
    }

    if (mipData.mipmask === 1) {
      if (w !== 1 && h !== 1) {
        check(info.minFilter !== GL_NEAREST_MIPMAP_NEAREST && info.minFilter !== GL_NEAREST_MIPMAP_LINEAR && info.minFilter !== GL_LINEAR_MIPMAP_NEAREST && info.minFilter !== GL_LINEAR_MIPMAP_LINEAR, 'min filter requires mipmap');
      }
    } else {
      // texture must be power of 2
      check(isPow2(w) && isPow2(h), 'texture must be a square power of 2 to support mipmapping');
      check(mipData.mipmask === (w << 1) - 1, 'missing or incomplete mipmap data');
    }

    if (mipData.type === GL_FLOAT) {
      if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {
        check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST, 'filter not supported, must enable oes_texture_float_linear');
      }
      check(!info.genMipmaps, 'mipmap generation not supported with float textures');
    }

    // check image complete
    var mipimages = mipData.images;
    for (i = 0; i < 16; ++i) {
      if (mipimages[i]) {
        var mw = w >> i;
        var mh = h >> i;
        check(mipData.mipmask & 1 << i, 'missing mipmap data');

        var img = mipimages[i];

        check(img.width === mw && img.height === mh, 'invalid shape for mip images');

        check(img.format === mipData.format && img.internalformat === mipData.internalformat && img.type === mipData.type, 'incompatible type for mip image');

        if (img.compressed) {
          // TODO: check size for compressed images
        } else if (img.data) {
          // check(img.data.byteLength === mw * mh *
          // Math.max(pixelSize(img.type, c), img.unpackAlignment),
          var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment;
          check(img.data.byteLength === rowSize * mh, 'invalid data for image, buffer size is inconsistent with image format');
        } else if (img.element) {
          // TODO: check element can be loaded
        } else if (img.copy) {
          // TODO: check compatible format and type
        }
      } else if (!info.genMipmaps) {
        check((mipData.mipmask & 1 << i) === 0, 'extra mipmap data');
      }
    }

    if (mipData.compressed) {
      check(!info.genMipmaps, 'mipmap generation for compressed images not supported');
    }
  }

  function checkTextureCube(texture, info, faces, limits) {
    var w = texture.width;
    var h = texture.height;
    var c = texture.channels;

    // Check texture shape
    check(w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize, 'invalid texture shape');
    check(w === h, 'cube map must be square');
    check(info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE, 'wrap mode not supported by cube map');

    for (var i = 0; i < faces.length; ++i) {
      var face = faces[i];
      check(face.width === w && face.height === h, 'inconsistent cube map face shape');

      if (info.genMipmaps) {
        check(!face.compressed, 'can not generate mipmap for compressed textures');
        check(face.mipmask === 1, 'can not specify mipmaps and generate mipmaps');
      } else {
        // TODO: check mip and filter mode
      }

      var mipmaps = face.images;
      for (var j = 0; j < 16; ++j) {
        var img = mipmaps[j];
        if (img) {
          var mw = w >> j;
          var mh = h >> j;
          check(face.mipmask & 1 << j, 'missing mipmap data');
          check(img.width === mw && img.height === mh, 'invalid shape for mip images');
          check(img.format === texture.format && img.internalformat === texture.internalformat && img.type === texture.type, 'incompatible type for mip image');

          if (img.compressed) {
            // TODO: check size for compressed images
          } else if (img.data) {
            check(img.data.byteLength === mw * mh * Math.max(pixelSize(img.type, c), img.unpackAlignment), 'invalid data for image, buffer size is inconsistent with image format');
          } else if (img.element) {
            // TODO: check element can be loaded
          } else if (img.copy) {
            // TODO: check compatible format and type
          }
        }
      }
    }
  }

  var check$1 = extend(check, {
    optional: checkOptional,
    raise: raise,
    commandRaise: commandRaise,
    command: checkCommand,
    parameter: checkParameter,
    commandParameter: checkParameterCommand,
    constructor: checkConstructor,
    type: checkTypeOf,
    commandType: checkCommandType,
    isTypedArray: checkIsTypedArray,
    nni: checkNonNegativeInt,
    oneOf: checkOneOf,
    shaderError: checkShaderError,
    linkError: checkLinkError,
    callSite: guessCallSite,
    saveCommandRef: saveCommandRef,
    saveDrawInfo: saveDrawCommandInfo,
    framebufferFormat: checkFramebufferFormat,
    guessCommand: guessCommand,
    texture2D: checkTexture2D,
    textureCube: checkTextureCube
  });

  var VARIABLE_COUNTER = 0;

  var DYN_FUNC = 0;

  function DynamicVariable(type, data) {
    this.id = VARIABLE_COUNTER++;
    this.type = type;
    this.data = data;
  }

  function escapeStr(str) {
    return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  }

  function splitParts(str) {
    if (str.length === 0) {
      return [];
    }

    var firstChar = str.charAt(0);
    var lastChar = str.charAt(str.length - 1);

    if (str.length > 1 && firstChar === lastChar && (firstChar === '"' || firstChar === "'")) {
      return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"'];
    }

    var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str);
    if (parts) {
      return splitParts(str.substr(0, parts.index)).concat(splitParts(parts[1])).concat(splitParts(str.substr(parts.index + parts[0].length)));
    }

    var subparts = str.split('.');
    if (subparts.length === 1) {
      return ['"' + escapeStr(str) + '"'];
    }

    var result = [];
    for (var i = 0; i < subparts.length; ++i) {
      result = result.concat(splitParts(subparts[i]));
    }
    return result;
  }

  function toAccessorString(str) {
    return '[' + splitParts(str).join('][') + ']';
  }

  function defineDynamic(type, data) {
    return new DynamicVariable(type, toAccessorString(data + ''));
  }

  function isDynamic(x) {
    return typeof x === 'function' && !x._reglType || x instanceof DynamicVariable;
  }

  function unbox(x, path) {
    if (typeof x === 'function') {
      return new DynamicVariable(DYN_FUNC, x);
    }
    return x;
  }

  var dynamic = {
    DynamicVariable: DynamicVariable,
    define: defineDynamic,
    isDynamic: isDynamic,
    unbox: unbox,
    accessor: toAccessorString
  };

  /* globals requestAnimationFrame, cancelAnimationFrame */
  var raf = {
    next: typeof requestAnimationFrame === 'function' ? function (cb) {
      return requestAnimationFrame(cb);
    } : function (cb) {
      return setTimeout(cb, 16);
    },
    cancel: typeof cancelAnimationFrame === 'function' ? function (raf) {
      return cancelAnimationFrame(raf);
    } : clearTimeout
  };

  /* globals performance */
  var clock = typeof performance !== 'undefined' && performance.now ? function () {
    return performance.now();
  } : function () {
    return +new Date();
  };

  function createStringStore() {
    var stringIds = { '': 0 };
    var stringValues = [''];
    return {
      id: function (str) {
        var result = stringIds[str];
        if (result) {
          return result;
        }
        result = stringIds[str] = stringValues.length;
        stringValues.push(str);
        return result;
      },

      str: function (id) {
        return stringValues[id];
      }
    };
  }

  // Context and canvas creation helper functions
  function createCanvas(element, onDone, pixelRatio) {
    var canvas = document.createElement('canvas');
    extend(canvas.style, {
      border: 0,
      margin: 0,
      padding: 0,
      top: 0,
      left: 0
    });
    element.appendChild(canvas);

    if (element === document.body) {
      canvas.style.position = 'absolute';
      extend(element.style, {
        margin: 0,
        padding: 0
      });
    }

    function resize() {
      var w = window.innerWidth;
      var h = window.innerHeight;
      if (element !== document.body) {
        var bounds = element.getBoundingClientRect();
        w = bounds.right - bounds.left;
        h = bounds.bottom - bounds.top;
      }
      canvas.width = pixelRatio * w;
      canvas.height = pixelRatio * h;
      extend(canvas.style, {
        width: w + 'px',
        height: h + 'px'
      });
    }

    window.addEventListener('resize', resize, false);

    function onDestroy() {
      window.removeEventListener('resize', resize);
      element.removeChild(canvas);
    }

    resize();

    return {
      canvas: canvas,
      onDestroy: onDestroy
    };
  }

  function createContext(canvas, contexAttributes) {
    function get(name) {
      try {
        return canvas.getContext(name, contexAttributes);
      } catch (e) {
        return null;
      }
    }
    return get('webgl') || get('experimental-webgl') || get('webgl-experimental');
  }

  function isHTMLElement(obj) {
    return typeof obj.nodeName === 'string' && typeof obj.appendChild === 'function' && typeof obj.getBoundingClientRect === 'function';
  }

  function isWebGLContext(obj) {
    return typeof obj.drawArrays === 'function' || typeof obj.drawElements === 'function';
  }

  function parseExtensions(input) {
    if (typeof input === 'string') {
      return input.split();
    }
    check$1(Array.isArray(input), 'invalid extension array');
    return input;
  }

  function getElement(desc) {
    if (typeof desc === 'string') {
      check$1(typeof document !== 'undefined', 'not supported outside of DOM');
      return document.querySelector(desc);
    }
    return desc;
  }

  function parseArgs(args_) {
    var args = args_ || {};
    var element, container, canvas, gl;
    var contextAttributes = {};
    var extensions = [];
    var optionalExtensions = [];
    var pixelRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio;
    var profile = false;
    var onDone = function (err) {
      if (err) {
        check$1.raise(err);
      }
    };
    var onDestroy = function () {};
    if (typeof args === 'string') {
      check$1(typeof document !== 'undefined', 'selector queries only supported in DOM enviroments');
      element = document.querySelector(args);
      check$1(element, 'invalid query string for element');
    } else if (typeof args === 'object') {
      if (isHTMLElement(args)) {
        element = args;
      } else if (isWebGLContext(args)) {
        gl = args;
        canvas = gl.canvas;
      } else {
        check$1.constructor(args);
        if ('gl' in args) {
          gl = args.gl;
        } else if ('canvas' in args) {
          canvas = getElement(args.canvas);
        } else if ('container' in args) {
          container = getElement(args.container);
        }
        if ('attributes' in args) {
          contextAttributes = args.attributes;
          check$1.type(contextAttributes, 'object', 'invalid context attributes');
        }
        if ('extensions' in args) {
          extensions = parseExtensions(args.extensions);
        }
        if ('optionalExtensions' in args) {
          optionalExtensions = parseExtensions(args.optionalExtensions);
        }
        if ('onDone' in args) {
          check$1.type(args.onDone, 'function', 'invalid or missing onDone callback');
          onDone = args.onDone;
        }
        if ('profile' in args) {
          profile = !!args.profile;
        }
        if ('pixelRatio' in args) {
          pixelRatio = +args.pixelRatio;
          check$1(pixelRatio > 0, 'invalid pixel ratio');
        }
      }
    } else {
      check$1.raise('invalid arguments to regl');
    }

    if (element) {
      if (element.nodeName.toLowerCase() === 'canvas') {
        canvas = element;
      } else {
        container = element;
      }
    }

    if (!gl) {
      if (!canvas) {
        check$1(typeof document !== 'undefined', 'must manually specify webgl context outside of DOM environments');
        var result = createCanvas(container || document.body, onDone, pixelRatio);
        if (!result) {
          return null;
        }
        canvas = result.canvas;
        onDestroy = result.onDestroy;
      }
      gl = createContext(canvas, contextAttributes);
    }

    if (!gl) {
      onDestroy();
      onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org');
      return null;
    }

    return {
      gl: gl,
      canvas: canvas,
      container: container,
      extensions: extensions,
      optionalExtensions: optionalExtensions,
      pixelRatio: pixelRatio,
      profile: profile,
      onDone: onDone,
      onDestroy: onDestroy
    };
  }

  function createExtensionCache(gl, config) {
    var extensions = {};

    function tryLoadExtension(name_) {
      check$1.type(name_, 'string', 'extension name must be string');
      var name = name_.toLowerCase();
      var ext;
      try {
        ext = extensions[name] = gl.getExtension(name);
      } catch (e) {}
      return !!ext;
    }

    for (var i = 0; i < config.extensions.length; ++i) {
      var name = config.extensions[i];
      if (!tryLoadExtension(name)) {
        config.onDestroy();
        config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser');
        return null;
      }
    }

    config.optionalExtensions.forEach(tryLoadExtension);

    return {
      extensions: extensions,
      restore: function () {
        Object.keys(extensions).forEach(function (name) {
          if (!tryLoadExtension(name)) {
            throw new Error('(regl): error restoring extension ' + name);
          }
        });
      }
    };
  }

  var GL_SUBPIXEL_BITS = 0x0D50;
  var GL_RED_BITS = 0x0D52;
  var GL_GREEN_BITS = 0x0D53;
  var GL_BLUE_BITS = 0x0D54;
  var GL_ALPHA_BITS = 0x0D55;
  var GL_DEPTH_BITS = 0x0D56;
  var GL_STENCIL_BITS = 0x0D57;

  var GL_ALIASED_POINT_SIZE_RANGE = 0x846D;
  var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E;

  var GL_MAX_TEXTURE_SIZE = 0x0D33;
  var GL_MAX_VIEWPORT_DIMS = 0x0D3A;
  var GL_MAX_VERTEX_ATTRIBS = 0x8869;
  var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
  var GL_MAX_VARYING_VECTORS = 0x8DFC;
  var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
  var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
  var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872;
  var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
  var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
  var GL_MAX_RENDERBUFFER_SIZE = 0x84E8;

  var GL_VENDOR = 0x1F00;
  var GL_RENDERER = 0x1F01;
  var GL_VERSION = 0x1F02;
  var GL_SHADING_LANGUAGE_VERSION = 0x8B8C;

  var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;

  var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF;
  var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824;

  var wrapLimits = function (gl, extensions) {
    var maxAnisotropic = 1;
    if (extensions.ext_texture_filter_anisotropic) {
      maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    }

    var maxDrawbuffers = 1;
    var maxColorAttachments = 1;
    if (extensions.webgl_draw_buffers) {
      maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL);
      maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL);
    }

    return {
      // drawing buffer bit depth
      colorBits: [gl.getParameter(GL_RED_BITS), gl.getParameter(GL_GREEN_BITS), gl.getParameter(GL_BLUE_BITS), gl.getParameter(GL_ALPHA_BITS)],
      depthBits: gl.getParameter(GL_DEPTH_BITS),
      stencilBits: gl.getParameter(GL_STENCIL_BITS),
      subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

      // supported extensions
      extensions: Object.keys(extensions).filter(function (ext) {
        return !!extensions[ext];
      }),

      // max aniso samples
      maxAnisotropic: maxAnisotropic,

      // max draw buffers
      maxDrawbuffers: maxDrawbuffers,
      maxColorAttachments: maxColorAttachments,

      // point and line size ranges
      pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
      lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
      maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
      maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
      maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
      maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
      maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
      maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
      maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
      maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
      maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

      // vendor info
      glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
      renderer: gl.getParameter(GL_RENDERER),
      vendor: gl.getParameter(GL_VENDOR),
      version: gl.getParameter(GL_VERSION)
    };
  };

  function isNDArrayLike(obj) {
    return !!obj && typeof obj === 'object' && Array.isArray(obj.shape) && Array.isArray(obj.stride) && typeof obj.offset === 'number' && obj.shape.length === obj.stride.length && (Array.isArray(obj.data) || isTypedArray(obj.data));
  }

  var values = function (obj) {
    return Object.keys(obj).map(function (key) {
      return obj[key];
    });
  };

  function loop(n, f) {
    var result = Array(n);
    for (var i = 0; i < n; ++i) {
      result[i] = f(i);
    }
    return result;
  }

  var GL_BYTE$1 = 5120;
  var GL_UNSIGNED_BYTE$2 = 5121;
  var GL_SHORT$1 = 5122;
  var GL_UNSIGNED_SHORT$1 = 5123;
  var GL_INT$1 = 5124;
  var GL_UNSIGNED_INT$1 = 5125;
  var GL_FLOAT$2 = 5126;

  var bufferPool = loop(8, function () {
    return [];
  });

  function nextPow16(v) {
    for (var i = 16; i <= 1 << 28; i *= 16) {
      if (v <= i) {
        return i;
      }
    }
    return 0;
  }

  function log2(v) {
    var r, shift;
    r = (v > 0xFFFF) << 4;
    v >>>= r;
    shift = (v > 0xFF) << 3;
    v >>>= shift;r |= shift;
    shift = (v > 0xF) << 2;
    v >>>= shift;r |= shift;
    shift = (v > 0x3) << 1;
    v >>>= shift;r |= shift;
    return r | v >> 1;
  }

  function alloc(n) {
    var sz = nextPow16(n);
    var bin = bufferPool[log2(sz) >> 2];
    if (bin.length > 0) {
      return bin.pop();
    }
    return new ArrayBuffer(sz);
  }

  function free(buf) {
    bufferPool[log2(buf.byteLength) >> 2].push(buf);
  }

  function allocType(type, n) {
    var result = null;
    switch (type) {
      case GL_BYTE$1:
        result = new Int8Array(alloc(n), 0, n);
        break;
      case GL_UNSIGNED_BYTE$2:
        result = new Uint8Array(alloc(n), 0, n);
        break;
      case GL_SHORT$1:
        result = new Int16Array(alloc(2 * n), 0, n);
        break;
      case GL_UNSIGNED_SHORT$1:
        result = new Uint16Array(alloc(2 * n), 0, n);
        break;
      case GL_INT$1:
        result = new Int32Array(alloc(4 * n), 0, n);
        break;
      case GL_UNSIGNED_INT$1:
        result = new Uint32Array(alloc(4 * n), 0, n);
        break;
      case GL_FLOAT$2:
        result = new Float32Array(alloc(4 * n), 0, n);
        break;
      default:
        return null;
    }
    if (result.length !== n) {
      return result.subarray(0, n);
    }
    return result;
  }

  function freeType(array) {
    free(array.buffer);
  }

  var pool = {
    alloc: alloc,
    free: free,
    allocType: allocType,
    freeType: freeType
  };

  var flattenUtils = {
    shape: arrayShape$1,
    flatten: flattenArray
  };

  function flatten1D(array, nx, out) {
    for (var i = 0; i < nx; ++i) {
      out[i] = array[i];
    }
  }

  function flatten2D(array, nx, ny, out) {
    var ptr = 0;
    for (var i = 0; i < nx; ++i) {
      var row = array[i];
      for (var j = 0; j < ny; ++j) {
        out[ptr++] = row[j];
      }
    }
  }

  function flatten3D(array, nx, ny, nz, out, ptr_) {
    var ptr = ptr_;
    for (var i = 0; i < nx; ++i) {
      var row = array[i];
      for (var j = 0; j < ny; ++j) {
        var col = row[j];
        for (var k = 0; k < nz; ++k) {
          out[ptr++] = col[k];
        }
      }
    }
  }

  function flattenRec(array, shape, level, out, ptr) {
    var stride = 1;
    for (var i = level + 1; i < shape.length; ++i) {
      stride *= shape[i];
    }
    var n = shape[level];
    if (shape.length - level === 4) {
      var nx = shape[level + 1];
      var ny = shape[level + 2];
      var nz = shape[level + 3];
      for (i = 0; i < n; ++i) {
        flatten3D(array[i], nx, ny, nz, out, ptr);
        ptr += stride;
      }
    } else {
      for (i = 0; i < n; ++i) {
        flattenRec(array[i], shape, level + 1, out, ptr);
        ptr += stride;
      }
    }
  }

  function flattenArray(array, shape, type, out_) {
    var sz = 1;
    if (shape.length) {
      for (var i = 0; i < shape.length; ++i) {
        sz *= shape[i];
      }
    } else {
      sz = 0;
    }
    var out = out_ || pool.allocType(type, sz);
    switch (shape.length) {
      case 0:
        break;
      case 1:
        flatten1D(array, shape[0], out);
        break;
      case 2:
        flatten2D(array, shape[0], shape[1], out);
        break;
      case 3:
        flatten3D(array, shape[0], shape[1], shape[2], out, 0);
        break;
      default:
        flattenRec(array, shape, 0, out, 0);
    }
    return out;
  }

  function arrayShape$1(array_) {
    var shape = [];
    for (var array = array_; array.length; array = array[0]) {
      shape.push(array.length);
    }
    return shape;
  }

  var int8 = 5120;
  var int16 = 5122;
  var int32 = 5124;
  var uint8 = 5121;
  var uint16 = 5123;
  var uint32 = 5125;
  var float = 5126;
  var float32 = 5126;
  var glTypes = {
    int8: int8,
    int16: int16,
    int32: int32,
    uint8: uint8,
    uint16: uint16,
    uint32: uint32,
    float: float,
    float32: float32
  };

  var dynamic$1 = 35048;
  var stream = 35040;
  var usageTypes = {
    dynamic: dynamic$1,
    stream: stream,
    "static": 35044
  };

  var arrayFlatten = flattenUtils.flatten;
  var arrayShape = flattenUtils.shape;

  var GL_STATIC_DRAW = 0x88E4;
  var GL_STREAM_DRAW = 0x88E0;

  var GL_UNSIGNED_BYTE$1 = 5121;
  var GL_FLOAT$1 = 5126;

  var DTYPES_SIZES = [];
  DTYPES_SIZES[5120] = 1; // int8
  DTYPES_SIZES[5122] = 2; // int16
  DTYPES_SIZES[5124] = 4; // int32
  DTYPES_SIZES[5121] = 1; // uint8
  DTYPES_SIZES[5123] = 2; // uint16
  DTYPES_SIZES[5125] = 4; // uint32
  DTYPES_SIZES[5126] = 4; // float32

  function typedArrayCode(data) {
    return arrayTypes[Object.prototype.toString.call(data)] | 0;
  }

  function copyArray(out, inp) {
    for (var i = 0; i < inp.length; ++i) {
      out[i] = inp[i];
    }
  }

  function transpose(result, data, shapeX, shapeY, strideX, strideY, offset) {
    var ptr = 0;
    for (var i = 0; i < shapeX; ++i) {
      for (var j = 0; j < shapeY; ++j) {
        result[ptr++] = data[strideX * i + strideY * j + offset];
      }
    }
  }

  function wrapBufferState(gl, stats, config) {
    var bufferCount = 0;
    var bufferSet = {};

    function REGLBuffer(type) {
      this.id = bufferCount++;
      this.buffer = gl.createBuffer();
      this.type = type;
      this.usage = GL_STATIC_DRAW;
      this.byteLength = 0;
      this.dimension = 1;
      this.dtype = GL_UNSIGNED_BYTE$1;

      this.persistentData = null;

      if (config.profile) {
        this.stats = { size: 0 };
      }
    }

    REGLBuffer.prototype.bind = function () {
      gl.bindBuffer(this.type, this.buffer);
    };

    REGLBuffer.prototype.destroy = function () {
      destroy(this);
    };

    var streamPool = [];

    function createStream(type, data) {
      var buffer = streamPool.pop();
      if (!buffer) {
        buffer = new REGLBuffer(type);
      }
      buffer.bind();
      initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false);
      return buffer;
    }

    function destroyStream(stream$$1) {
      streamPool.push(stream$$1);
    }

    function initBufferFromTypedArray(buffer, data, usage) {
      buffer.byteLength = data.byteLength;
      gl.bufferData(buffer.type, data, usage);
    }

    function initBufferFromData(buffer, data, usage, dtype, dimension, persist) {
      var shape;
      buffer.usage = usage;
      if (Array.isArray(data)) {
        buffer.dtype = dtype || GL_FLOAT$1;
        if (data.length > 0) {
          var flatData;
          if (Array.isArray(data[0])) {
            shape = arrayShape(data);
            var dim = 1;
            for (var i = 1; i < shape.length; ++i) {
              dim *= shape[i];
            }
            buffer.dimension = dim;
            flatData = arrayFlatten(data, shape, buffer.dtype);
            initBufferFromTypedArray(buffer, flatData, usage);
            if (persist) {
              buffer.persistentData = flatData;
            } else {
              pool.freeType(flatData);
            }
          } else if (typeof data[0] === 'number') {
            buffer.dimension = dimension;
            var typedData = pool.allocType(buffer.dtype, data.length);
            copyArray(typedData, data);
            initBufferFromTypedArray(buffer, typedData, usage);
            if (persist) {
              buffer.persistentData = typedData;
            } else {
              pool.freeType(typedData);
            }
          } else if (isTypedArray(data[0])) {
            buffer.dimension = data[0].length;
            buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$1;
            flatData = arrayFlatten(data, [data.length, data[0].length], buffer.dtype);
            initBufferFromTypedArray(buffer, flatData, usage);
            if (persist) {
              buffer.persistentData = flatData;
            } else {
              pool.freeType(flatData);
            }
          } else {
            check$1.raise('invalid buffer data');
          }
        }
      } else if (isTypedArray(data)) {
        buffer.dtype = dtype || typedArrayCode(data);
        buffer.dimension = dimension;
        initBufferFromTypedArray(buffer, data, usage);
        if (persist) {
          buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer));
        }
      } else if (isNDArrayLike(data)) {
        shape = data.shape;
        var stride = data.stride;
        var offset = data.offset;

        var shapeX = 0;
        var shapeY = 0;
        var strideX = 0;
        var strideY = 0;
        if (shape.length === 1) {
          shapeX = shape[0];
          shapeY = 1;
          strideX = stride[0];
          strideY = 0;
        } else if (shape.length === 2) {
          shapeX = shape[0];
          shapeY = shape[1];
          strideX = stride[0];
          strideY = stride[1];
        } else {
          check$1.raise('invalid shape');
        }

        buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$1;
        buffer.dimension = shapeY;

        var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY);
        transpose(transposeData, data.data, shapeX, shapeY, strideX, strideY, offset);
        initBufferFromTypedArray(buffer, transposeData, usage);
        if (persist) {
          buffer.persistentData = transposeData;
        } else {
          pool.freeType(transposeData);
        }
      } else {
        check$1.raise('invalid buffer data');
      }
    }

    function destroy(buffer) {
      stats.bufferCount--;

      var handle = buffer.buffer;
      check$1(handle, 'buffer must not be deleted already');
      gl.deleteBuffer(handle);
      buffer.buffer = null;
      delete bufferSet[buffer.id];
    }

    function createBuffer(options, type, deferInit, persistent) {
      stats.bufferCount++;

      var buffer = new REGLBuffer(type);
      bufferSet[buffer.id] = buffer;

      function reglBuffer(options) {
        var usage = GL_STATIC_DRAW;
        var data = null;
        var byteLength = 0;
        var dtype = 0;
        var dimension = 1;
        if (Array.isArray(options) || isTypedArray(options) || isNDArrayLike(options)) {
          data = options;
        } else if (typeof options === 'number') {
          byteLength = options | 0;
        } else if (options) {
          check$1.type(options, 'object', 'buffer arguments must be an object, a number or an array');

          if ('data' in options) {
            check$1(data === null || Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data), 'invalid data for buffer');
            data = options.data;
          }

          if ('usage' in options) {
            check$1.parameter(options.usage, usageTypes, 'invalid buffer usage');
            usage = usageTypes[options.usage];
          }

          if ('type' in options) {
            check$1.parameter(options.type, glTypes, 'invalid buffer type');
            dtype = glTypes[options.type];
          }

          if ('dimension' in options) {
            check$1.type(options.dimension, 'number', 'invalid dimension');
            dimension = options.dimension | 0;
          }

          if ('length' in options) {
            check$1.nni(byteLength, 'buffer length must be a nonnegative integer');
            byteLength = options.length | 0;
          }
        }

        buffer.bind();
        if (!data) {
          gl.bufferData(buffer.type, byteLength, usage);
          buffer.dtype = dtype || GL_UNSIGNED_BYTE$1;
          buffer.usage = usage;
          buffer.dimension = dimension;
          buffer.byteLength = byteLength;
        } else {
          initBufferFromData(buffer, data, usage, dtype, dimension, persistent);
        }

        if (config.profile) {
          buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype];
        }

        return reglBuffer;
      }

      function setSubData(data, offset) {
        check$1(offset + data.byteLength <= buffer.byteLength, 'invalid buffer subdata call, buffer is too small. ' + ' Can\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength);

        gl.bufferSubData(buffer.type, offset, data);
      }

      function subdata(data, offset_) {
        var offset = (offset_ || 0) | 0;
        var shape;
        buffer.bind();
        if (Array.isArray(data)) {
          if (data.length > 0) {
            if (typeof data[0] === 'number') {
              var converted = pool.allocType(buffer.dtype, data.length);
              copyArray(converted, data);
              setSubData(converted, offset);
              pool.freeType(converted);
            } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
              shape = arrayShape(data);
              var flatData = arrayFlatten(data, shape, buffer.dtype);
              setSubData(flatData, offset);
              pool.freeType(flatData);
            } else {
              check$1.raise('invalid buffer data');
            }
          }
        } else if (isTypedArray(data)) {
          setSubData(data, offset);
        } else if (isNDArrayLike(data)) {
          shape = data.shape;
          var stride = data.stride;

          var shapeX = 0;
          var shapeY = 0;
          var strideX = 0;
          var strideY = 0;
          if (shape.length === 1) {
            shapeX = shape[0];
            shapeY = 1;
            strideX = stride[0];
            strideY = 0;
          } else if (shape.length === 2) {
            shapeX = shape[0];
            shapeY = shape[1];
            strideX = stride[0];
            strideY = stride[1];
          } else {
            check$1.raise('invalid shape');
          }
          var dtype = Array.isArray(data.data) ? buffer.dtype : typedArrayCode(data.data);

          var transposeData = pool.allocType(dtype, shapeX * shapeY);
          transpose(transposeData, data.data, shapeX, shapeY, strideX, strideY, data.offset);
          setSubData(transposeData, offset);
          pool.freeType(transposeData);
        } else {
          check$1.raise('invalid data for buffer subdata');
        }
        return reglBuffer;
      }

      if (!deferInit) {
        reglBuffer(options);
      }

      reglBuffer._reglType = 'buffer';
      reglBuffer._buffer = buffer;
      reglBuffer.subdata = subdata;
      if (config.profile) {
        reglBuffer.stats = buffer.stats;
      }
      reglBuffer.destroy = function () {
        destroy(buffer);
      };

      return reglBuffer;
    }

    function restoreBuffers() {
      values(bufferSet).forEach(function (buffer) {
        buffer.buffer = gl.createBuffer();
        gl.bindBuffer(buffer.type, buffer.buffer);
        gl.bufferData(buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage);
      });
    }

    if (config.profile) {
      stats.getTotalBufferSize = function () {
        var total = 0;
        // TODO: Right now, the streams are not part of the total count.
        Object.keys(bufferSet).forEach(function (key) {
          total += bufferSet[key].stats.size;
        });
        return total;
      };
    }

    return {
      create: createBuffer,

      createStream: createStream,
      destroyStream: destroyStream,

      clear: function () {
        values(bufferSet).forEach(destroy);
        streamPool.forEach(destroy);
      },

      getBuffer: function (wrapper) {
        if (wrapper && wrapper._buffer instanceof REGLBuffer) {
          return wrapper._buffer;
        }
        return null;
      },

      restore: restoreBuffers,

      _initBuffer: initBufferFromData
    };
  }

  var points = 0;
  var point = 0;
  var lines = 1;
  var line = 1;
  var triangles = 4;
  var triangle = 4;
  var primTypes = {
    points: points,
    point: point,
    lines: lines,
    line: line,
    triangles: triangles,
    triangle: triangle,
    "line loop": 2,
    "line strip": 3,
    "triangle strip": 5,
    "triangle fan": 6
  };

  var GL_POINTS = 0;
  var GL_LINES = 1;
  var GL_TRIANGLES = 4;

  var GL_BYTE$2 = 5120;
  var GL_UNSIGNED_BYTE$3 = 5121;
  var GL_SHORT$2 = 5122;
  var GL_UNSIGNED_SHORT$2 = 5123;
  var GL_INT$2 = 5124;
  var GL_UNSIGNED_INT$2 = 5125;

  var GL_ELEMENT_ARRAY_BUFFER = 34963;

  var GL_STREAM_DRAW$1 = 0x88E0;
  var GL_STATIC_DRAW$1 = 0x88E4;

  function wrapElementsState(gl, extensions, bufferState, stats) {
    var elementSet = {};
    var elementCount = 0;

    var elementTypes = {
      'uint8': GL_UNSIGNED_BYTE$3,
      'uint16': GL_UNSIGNED_SHORT$2
    };

    if (extensions.oes_element_index_uint) {
      elementTypes.uint32 = GL_UNSIGNED_INT$2;
    }

    function REGLElementBuffer(buffer) {
      this.id = elementCount++;
      elementSet[this.id] = this;
      this.buffer = buffer;
      this.primType = GL_TRIANGLES;
      this.vertCount = 0;
      this.type = 0;
    }

    REGLElementBuffer.prototype.bind = function () {
      this.buffer.bind();
    };

    var bufferPool = [];

    function createElementStream(data) {
      var result = bufferPool.pop();
      if (!result) {
        result = new REGLElementBuffer(bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true, false)._buffer);
      }
      initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0);
      return result;
    }

    function destroyElementStream(elements) {
      bufferPool.push(elements);
    }

    function initElements(elements, data, usage, prim, count, byteLength, type) {
      elements.buffer.bind();
      if (data) {
        var predictedType = type;
        if (!type && (!isTypedArray(data) || isNDArrayLike(data) && !isTypedArray(data.data))) {
          predictedType = extensions.oes_element_index_uint ? GL_UNSIGNED_INT$2 : GL_UNSIGNED_SHORT$2;
        }
        bufferState._initBuffer(elements.buffer, data, usage, predictedType, 3);
      } else {
        gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage);
        elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$3;
        elements.buffer.usage = usage;
        elements.buffer.dimension = 3;
        elements.buffer.byteLength = byteLength;
      }

      var dtype = type;
      if (!type) {
        switch (elements.buffer.dtype) {
          case GL_UNSIGNED_BYTE$3:
          case GL_BYTE$2:
            dtype = GL_UNSIGNED_BYTE$3;
            break;

          case GL_UNSIGNED_SHORT$2:
          case GL_SHORT$2:
            dtype = GL_UNSIGNED_SHORT$2;
            break;

          case GL_UNSIGNED_INT$2:
          case GL_INT$2:
            dtype = GL_UNSIGNED_INT$2;
            break;

          default:
            check$1.raise('unsupported type for element array');
        }
        elements.buffer.dtype = dtype;
      }
      elements.type = dtype;

      // Check oes_element_index_uint extension
      check$1(dtype !== GL_UNSIGNED_INT$2 || !!extensions.oes_element_index_uint, '32 bit element buffers not supported, enable oes_element_index_uint first');

      // try to guess default primitive type and arguments
      var vertCount = count;
      if (vertCount < 0) {
        vertCount = elements.buffer.byteLength;
        if (dtype === GL_UNSIGNED_SHORT$2) {
          vertCount >>= 1;
        } else if (dtype === GL_UNSIGNED_INT$2) {
          vertCount >>= 2;
        }
      }
      elements.vertCount = vertCount;

      // try to guess primitive type from cell dimension
      var primType = prim;
      if (prim < 0) {
        primType = GL_TRIANGLES;
        var dimension = elements.buffer.dimension;
        if (dimension === 1) primType = GL_POINTS;
        if (dimension === 2) primType = GL_LINES;
        if (dimension === 3) primType = GL_TRIANGLES;
      }
      elements.primType = primType;
    }

    function destroyElements(elements) {
      stats.elementsCount--;

      check$1(elements.buffer !== null, 'must not double destroy elements');
      delete elementSet[elements.id];
      elements.buffer.destroy();
      elements.buffer = null;
    }

    function createElements(options, persistent) {
      var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true);
      var elements = new REGLElementBuffer(buffer._buffer);
      stats.elementsCount++;

      function reglElements(options) {
        if (!options) {
          buffer();
          elements.primType = GL_TRIANGLES;
          elements.vertCount = 0;
          elements.type = GL_UNSIGNED_BYTE$3;
        } else if (typeof options === 'number') {
          buffer(options);
          elements.primType = GL_TRIANGLES;
          elements.vertCount = options | 0;
          elements.type = GL_UNSIGNED_BYTE$3;
        } else {
          var data = null;
          var usage = GL_STATIC_DRAW$1;
          var primType = -1;
          var vertCount = -1;
          var byteLength = 0;
          var dtype = 0;
          if (Array.isArray(options) || isTypedArray(options) || isNDArrayLike(options)) {
            data = options;
          } else {
            check$1.type(options, 'object', 'invalid arguments for elements');
            if ('data' in options) {
              data = options.data;
              check$1(Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data), 'invalid data for element buffer');
            }
            if ('usage' in options) {
              check$1.parameter(options.usage, usageTypes, 'invalid element buffer usage');
              usage = usageTypes[options.usage];
            }
            if ('primitive' in options) {
              check$1.parameter(options.primitive, primTypes, 'invalid element buffer primitive');
              primType = primTypes[options.primitive];
            }
            if ('count' in options) {
              check$1(typeof options.count === 'number' && options.count >= 0, 'invalid vertex count for elements');
              vertCount = options.count | 0;
            }
            if ('type' in options) {
              check$1.parameter(options.type, elementTypes, 'invalid buffer type');
              dtype = elementTypes[options.type];
            }
            if ('length' in options) {
              byteLength = options.length | 0;
            } else {
              byteLength = vertCount;
              if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
                byteLength *= 2;
              } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
                byteLength *= 4;
              }
            }
          }
          initElements(elements, data, usage, primType, vertCount, byteLength, dtype);
        }

        return reglElements;
      }

      reglElements(options);

      reglElements._reglType = 'elements';
      reglElements._elements = elements;
      reglElements.subdata = function (data, offset) {
        buffer.subdata(data, offset);
        return reglElements;
      };
      reglElements.destroy = function () {
        destroyElements(elements);
      };

      return reglElements;
    }

    return {
      create: createElements,
      createStream: createElementStream,
      destroyStream: destroyElementStream,
      getElements: function (elements) {
        if (typeof elements === 'function' && elements._elements instanceof REGLElementBuffer) {
          return elements._elements;
        }
        return null;
      },
      clear: function () {
        values(elementSet).forEach(destroyElements);
      }
    };
  }

  var FLOAT = new Float32Array(1);
  var INT = new Uint32Array(FLOAT.buffer);

  var GL_UNSIGNED_SHORT$4 = 5123;

  function convertToHalfFloat(array) {
    var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length);

    for (var i = 0; i < array.length; ++i) {
      if (isNaN(array[i])) {
        ushorts[i] = 0xffff;
      } else if (array[i] === Infinity) {
        ushorts[i] = 0x7c00;
      } else if (array[i] === -Infinity) {
        ushorts[i] = 0xfc00;
      } else {
        FLOAT[0] = array[i];
        var x = INT[0];

        var sgn = x >>> 31 << 15;
        var exp = (x << 1 >>> 24) - 127;
        var frac = x >> 13 & (1 << 10) - 1;

        if (exp < -24) {
          // round non-representable denormals to 0
          ushorts[i] = sgn;
        } else if (exp < -14) {
          // handle denormals
          var s = -14 - exp;
          ushorts[i] = sgn + (frac + (1 << 10) >> s);
        } else if (exp > 15) {
          // round overflow to +/- Infinity
          ushorts[i] = sgn + 0x7c00;
        } else {
          // otherwise convert directly
          ushorts[i] = sgn + (exp + 15 << 10) + frac;
        }
      }
    }

    return ushorts;
  }

  function isArrayLike(s) {
    return Array.isArray(s) || isTypedArray(s);
  }

  var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3;

  var GL_TEXTURE_2D = 0x0DE1;
  var GL_TEXTURE_CUBE_MAP = 0x8513;
  var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;

  var GL_RGBA = 0x1908;
  var GL_ALPHA = 0x1906;
  var GL_RGB = 0x1907;
  var GL_LUMINANCE = 0x1909;
  var GL_LUMINANCE_ALPHA = 0x190A;

  var GL_RGBA4 = 0x8056;
  var GL_RGB5_A1 = 0x8057;
  var GL_RGB565 = 0x8D62;

  var GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033;
  var GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034;
  var GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363;
  var GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA;

  var GL_DEPTH_COMPONENT = 0x1902;
  var GL_DEPTH_STENCIL = 0x84F9;

  var GL_SRGB_EXT = 0x8C40;
  var GL_SRGB_ALPHA_EXT = 0x8C42;

  var GL_HALF_FLOAT_OES$1 = 0x8D61;

  var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
  var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;
  var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;
  var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

  var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92;
  var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;
  var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;

  var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;
  var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;
  var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;
  var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;

  var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;

  var GL_UNSIGNED_BYTE$4 = 0x1401;
  var GL_UNSIGNED_SHORT$3 = 0x1403;
  var GL_UNSIGNED_INT$3 = 0x1405;
  var GL_FLOAT$3 = 0x1406;

  var GL_TEXTURE_WRAP_S = 0x2802;
  var GL_TEXTURE_WRAP_T = 0x2803;

  var GL_REPEAT = 0x2901;
  var GL_CLAMP_TO_EDGE$1 = 0x812F;
  var GL_MIRRORED_REPEAT = 0x8370;

  var GL_TEXTURE_MAG_FILTER = 0x2800;
  var GL_TEXTURE_MIN_FILTER = 0x2801;

  var GL_NEAREST$1 = 0x2600;
  var GL_LINEAR = 0x2601;
  var GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700;
  var GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701;
  var GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702;
  var GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703;

  var GL_GENERATE_MIPMAP_HINT = 0x8192;
  var GL_DONT_CARE = 0x1100;
  var GL_FASTEST = 0x1101;
  var GL_NICEST = 0x1102;

  var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;

  var GL_UNPACK_ALIGNMENT = 0x0CF5;
  var GL_UNPACK_FLIP_Y_WEBGL = 0x9240;
  var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
  var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;

  var GL_BROWSER_DEFAULT_WEBGL = 0x9244;

  var GL_TEXTURE0 = 0x84C0;

  var MIPMAP_FILTERS = [GL_NEAREST_MIPMAP_NEAREST$1, GL_NEAREST_MIPMAP_LINEAR$1, GL_LINEAR_MIPMAP_NEAREST$1, GL_LINEAR_MIPMAP_LINEAR$1];

  var CHANNELS_FORMAT = [0, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_RGBA];

  var FORMAT_CHANNELS = {};
  FORMAT_CHANNELS[GL_LUMINANCE] = FORMAT_CHANNELS[GL_ALPHA] = FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1;
  FORMAT_CHANNELS[GL_DEPTH_STENCIL] = FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2;
  FORMAT_CHANNELS[GL_RGB] = FORMAT_CHANNELS[GL_SRGB_EXT] = 3;
  FORMAT_CHANNELS[GL_RGBA] = FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4;

  function objectName(str) {
    return '[object ' + str + ']';
  }

  var CANVAS_CLASS = objectName('HTMLCanvasElement');
  var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D');
  var IMAGE_CLASS = objectName('HTMLImageElement');
  var VIDEO_CLASS = objectName('HTMLVideoElement');

  var PIXEL_CLASSES = Object.keys(arrayTypes).concat([CANVAS_CLASS, CONTEXT2D_CLASS, IMAGE_CLASS, VIDEO_CLASS]);

  // for every texture type, store
  // the size in bytes.
  var TYPE_SIZES = [];
  TYPE_SIZES[GL_UNSIGNED_BYTE$4] = 1;
  TYPE_SIZES[GL_FLOAT$3] = 4;
  TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2;

  TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2;
  TYPE_SIZES[GL_UNSIGNED_INT$3] = 4;

  var FORMAT_SIZES_SPECIAL = [];
  FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2;
  FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2;
  FORMAT_SIZES_SPECIAL[GL_RGB565] = 2;
  FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4;

  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;

  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1;

  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5;
  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25;

  FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5;

  function isNumericArray(arr) {
    return Array.isArray(arr) && (arr.length === 0 || typeof arr[0] === 'number');
  }

  function isRectArray(arr) {
    if (!Array.isArray(arr)) {
      return false;
    }
    var width = arr.length;
    if (width === 0 || !isArrayLike(arr[0])) {
      return false;
    }
    return true;
  }

  function classString(x) {
    return Object.prototype.toString.call(x);
  }

  function isCanvasElement(object) {
    return classString(object) === CANVAS_CLASS;
  }

  function isContext2D(object) {
    return classString(object) === CONTEXT2D_CLASS;
  }

  function isImageElement(object) {
    return classString(object) === IMAGE_CLASS;
  }

  function isVideoElement(object) {
    return classString(object) === VIDEO_CLASS;
  }

  function isPixelData(object) {
    if (!object) {
      return false;
    }
    var className = classString(object);
    if (PIXEL_CLASSES.indexOf(className) >= 0) {
      return true;
    }
    return isNumericArray(object) || isRectArray(object) || isNDArrayLike(object);
  }

  function typedArrayCode$1(data) {
    return arrayTypes[Object.prototype.toString.call(data)] | 0;
  }

  function convertData(result, data) {
    var n = data.length;
    switch (result.type) {
      case GL_UNSIGNED_BYTE$4:
      case GL_UNSIGNED_SHORT$3:
      case GL_UNSIGNED_INT$3:
      case GL_FLOAT$3:
        var converted = pool.allocType(result.type, n);
        converted.set(data);
        result.data = converted;
        break;

      case GL_HALF_FLOAT_OES$1:
        result.data = convertToHalfFloat(data);
        break;

      default:
        check$1.raise('unsupported texture type, must specify a typed array');
    }
  }

  function preConvert(image, n) {
    return pool.allocType(image.type === GL_HALF_FLOAT_OES$1 ? GL_FLOAT$3 : image.type, n);
  }

  function postConvert(image, data) {
    if (image.type === GL_HALF_FLOAT_OES$1) {
      image.data = convertToHalfFloat(data);
      pool.freeType(data);
    } else {
      image.data = data;
    }
  }

  function transposeData(image, array, strideX, strideY, strideC, offset) {
    var w = image.width;
    var h = image.height;
    var c = image.channels;
    var n = w * h * c;
    var data = preConvert(image, n);

    var p = 0;
    for (var i = 0; i < h; ++i) {
      for (var j = 0; j < w; ++j) {
        for (var k = 0; k < c; ++k) {
          data[p++] = array[strideX * j + strideY * i + strideC * k + offset];
        }
      }
    }

    postConvert(image, data);
  }

  function getTextureSize(format, type, width, height, isMipmap, isCube) {
    var s;
    if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {
      // we have a special array for dealing with weird color formats such as RGB5A1
      s = FORMAT_SIZES_SPECIAL[format];
    } else {
      s = FORMAT_CHANNELS[format] * TYPE_SIZES[type];
    }

    if (isCube) {
      s *= 6;
    }

    if (isMipmap) {
      // compute the total size of all the mipmaps.
      var total = 0;

      var w = width;
      while (w >= 1) {
        // we can only use mipmaps on a square image,
        // so we can simply use the width and ignore the height:
        total += s * w * w;
        w /= 2;
      }
      return total;
    } else {
      return s * width * height;
    }
  }

  function createTextureSet(gl, extensions, limits, reglPoll, contextState, stats, config) {
    // -------------------------------------------------------
    // Initialize constants and parameter tables here
    // -------------------------------------------------------
    var mipmapHint = {
      "don't care": GL_DONT_CARE,
      'dont care': GL_DONT_CARE,
      'nice': GL_NICEST,
      'fast': GL_FASTEST
    };

    var wrapModes = {
      'repeat': GL_REPEAT,
      'clamp': GL_CLAMP_TO_EDGE$1,
      'mirror': GL_MIRRORED_REPEAT
    };

    var magFilters = {
      'nearest': GL_NEAREST$1,
      'linear': GL_LINEAR
    };

    var minFilters = extend({
      'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,
      'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,
      'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,
      'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,
      'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1
    }, magFilters);

    var colorSpace = {
      'none': 0,
      'browser': GL_BROWSER_DEFAULT_WEBGL
    };

    var textureTypes = {
      'uint8': GL_UNSIGNED_BYTE$4,
      'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,
      'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,
      'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1
    };

    var textureFormats = {
      'alpha': GL_ALPHA,
      'luminance': GL_LUMINANCE,
      'luminance alpha': GL_LUMINANCE_ALPHA,
      'rgb': GL_RGB,
      'rgba': GL_RGBA,
      'rgba4': GL_RGBA4,
      'rgb5 a1': GL_RGB5_A1,
      'rgb565': GL_RGB565
    };

    var compressedTextureFormats = {};

    if (extensions.ext_srgb) {
      textureFormats.srgb = GL_SRGB_EXT;
      textureFormats.srgba = GL_SRGB_ALPHA_EXT;
    }

    if (extensions.oes_texture_float) {
      textureTypes.float32 = textureTypes.float = GL_FLOAT$3;
    }

    if (extensions.oes_texture_half_float) {
      textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1;
    }

    if (extensions.webgl_depth_texture) {
      extend(textureFormats, {
        'depth': GL_DEPTH_COMPONENT,
        'depth stencil': GL_DEPTH_STENCIL
      });

      extend(textureTypes, {
        'uint16': GL_UNSIGNED_SHORT$3,
        'uint32': GL_UNSIGNED_INT$3,
        'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1
      });
    }

    if (extensions.webgl_compressed_texture_s3tc) {
      extend(compressedTextureFormats, {
        'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
        'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
        'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
        'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
      });
    }

    if (extensions.webgl_compressed_texture_atc) {
      extend(compressedTextureFormats, {
        'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,
        'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
        'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
      });
    }

    if (extensions.webgl_compressed_texture_pvrtc) {
      extend(compressedTextureFormats, {
        'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
        'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
        'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
        'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
      });
    }

    if (extensions.webgl_compressed_texture_etc1) {
      compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL;
    }

    // Copy over all texture formats
    var supportedCompressedFormats = Array.prototype.slice.call(gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS));
    Object.keys(compressedTextureFormats).forEach(function (name) {
      var format = compressedTextureFormats[name];
      if (supportedCompressedFormats.indexOf(format) >= 0) {
        textureFormats[name] = format;
      }
    });

    var supportedFormats = Object.keys(textureFormats);
    limits.textureFormats = supportedFormats;

    // associate with every format string its
    // corresponding GL-value.
    var textureFormatsInvert = [];
    Object.keys(textureFormats).forEach(function (key) {
      var val = textureFormats[key];
      textureFormatsInvert[val] = key;
    });

    // associate with every type string its
    // corresponding GL-value.
    var textureTypesInvert = [];
    Object.keys(textureTypes).forEach(function (key) {
      var val = textureTypes[key];
      textureTypesInvert[val] = key;
    });

    var magFiltersInvert = [];
    Object.keys(magFilters).forEach(function (key) {
      var val = magFilters[key];
      magFiltersInvert[val] = key;
    });

    var minFiltersInvert = [];
    Object.keys(minFilters).forEach(function (key) {
      var val = minFilters[key];
      minFiltersInvert[val] = key;
    });

    var wrapModesInvert = [];
    Object.keys(wrapModes).forEach(function (key) {
      var val = wrapModes[key];
      wrapModesInvert[val] = key;
    });

    // colorFormats[] gives the format (channels) associated to an
    // internalformat
    var colorFormats = supportedFormats.reduce(function (color, key) {
      var glenum = textureFormats[key];
      if (glenum === GL_LUMINANCE || glenum === GL_ALPHA || glenum === GL_LUMINANCE || glenum === GL_LUMINANCE_ALPHA || glenum === GL_DEPTH_COMPONENT || glenum === GL_DEPTH_STENCIL) {
        color[glenum] = glenum;
      } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
        color[glenum] = GL_RGBA;
      } else {
        color[glenum] = GL_RGB;
      }
      return color;
    }, {});

    function TexFlags() {
      // format info
      this.internalformat = GL_RGBA;
      this.format = GL_RGBA;
      this.type = GL_UNSIGNED_BYTE$4;
      this.compressed = false;

      // pixel storage
      this.premultiplyAlpha = false;
      this.flipY = false;
      this.unpackAlignment = 1;
      this.colorSpace = 0;

      // shape info
      this.width = 0;
      this.height = 0;
      this.channels = 0;
    }

    function copyFlags(result, other) {
      result.internalformat = other.internalformat;
      result.format = other.format;
      result.type = other.type;
      result.compressed = other.compressed;

      result.premultiplyAlpha = other.premultiplyAlpha;
      result.flipY = other.flipY;
      result.unpackAlignment = other.unpackAlignment;
      result.colorSpace = other.colorSpace;

      result.width = other.width;
      result.height = other.height;
      result.channels = other.channels;
    }

    function parseFlags(flags, options) {
      if (typeof options !== 'object' || !options) {
        return;
      }

      if ('premultiplyAlpha' in options) {
        check$1.type(options.premultiplyAlpha, 'boolean', 'invalid premultiplyAlpha');
        flags.premultiplyAlpha = options.premultiplyAlpha;
      }

      if ('flipY' in options) {
        check$1.type(options.flipY, 'boolean', 'invalid texture flip');
        flags.flipY = options.flipY;
      }

      if ('alignment' in options) {
        check$1.oneOf(options.alignment, [1, 2, 4, 8], 'invalid texture unpack alignment');
        flags.unpackAlignment = options.alignment;
      }

      if ('colorSpace' in options) {
        check$1.parameter(options.colorSpace, colorSpace, 'invalid colorSpace');
        flags.colorSpace = colorSpace[options.colorSpace];
      }

      if ('type' in options) {
        var type = options.type;
        check$1(extensions.oes_texture_float || !(type === 'float' || type === 'float32'), 'you must enable the OES_texture_float extension in order to use floating point textures.');
        check$1(extensions.oes_texture_half_float || !(type === 'half float' || type === 'float16'), 'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.');
        check$1(extensions.webgl_depth_texture || !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'), 'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.');
        check$1.parameter(type, textureTypes, 'invalid texture type');
        flags.type = textureTypes[type];
      }

      var w = flags.width;
      var h = flags.height;
      var c = flags.channels;
      var hasChannels = false;
      if ('shape' in options) {
        check$1(Array.isArray(options.shape) && options.shape.length >= 2, 'shape must be an array');
        w = options.shape[0];
        h = options.shape[1];
        if (options.shape.length === 3) {
          c = options.shape[2];
          check$1(c > 0 && c <= 4, 'invalid number of channels');
          hasChannels = true;
        }
        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width');
        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height');
      } else {
        if ('radius' in options) {
          w = h = options.radius;
          check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius');
        }
        if ('width' in options) {
          w = options.width;
          check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width');
        }
        if ('height' in options) {
          h = options.height;
          check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height');
        }
        if ('channels' in options) {
          c = options.channels;
          check$1(c > 0 && c <= 4, 'invalid number of channels');
          hasChannels = true;
        }
      }
      flags.width = w | 0;
      flags.height = h | 0;
      flags.channels = c | 0;

      var hasFormat = false;
      if ('format' in options) {
        var formatStr = options.format;
        check$1(extensions.webgl_depth_texture || !(formatStr === 'depth' || formatStr === 'depth stencil'), 'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.');
        check$1.parameter(formatStr, textureFormats, 'invalid texture format');
        var internalformat = flags.internalformat = textureFormats[formatStr];
        flags.format = colorFormats[internalformat];
        if (formatStr in textureTypes) {
          if (!('type' in options)) {
            flags.type = textureTypes[formatStr];
          }
        }
        if (formatStr in compressedTextureFormats) {
          flags.compressed = true;
        }
        hasFormat = true;
      }

      // Reconcile channels and format
      if (!hasChannels && hasFormat) {
        flags.channels = FORMAT_CHANNELS[flags.format];
      } else if (hasChannels && !hasFormat) {
        if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
          flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels];
        }
      } else if (hasFormat && hasChannels) {
        check$1(flags.channels === FORMAT_CHANNELS[flags.format], 'number of channels inconsistent with specified format');
      }
    }

    function setFlags(flags) {
      gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY);
      gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha);
      gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace);
      gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment);
    }

    // -------------------------------------------------------
    // Tex image data
    // -------------------------------------------------------
    function TexImage() {
      TexFlags.call(this);

      this.xOffset = 0;
      this.yOffset = 0;

      // data
      this.data = null;
      this.needsFree = false;

      // html element
      this.element = null;

      // copyTexImage info
      this.needsCopy = false;
    }

    function parseImage(image, options) {
      var data = null;
      if (isPixelData(options)) {
        data = options;
      } else if (options) {
        check$1.type(options, 'object', 'invalid pixel data type');
        parseFlags(image, options);
        if ('x' in options) {
          image.xOffset = options.x | 0;
        }
        if ('y' in options) {
          image.yOffset = options.y | 0;
        }
        if (isPixelData(options.data)) {
          data = options.data;
        }
      }

      check$1(!image.compressed || data instanceof Uint8Array, 'compressed texture data must be stored in a uint8array');

      if (options.copy) {
        check$1(!data, 'can not specify copy and data field for the same texture');
        var viewW = contextState.viewportWidth;
        var viewH = contextState.viewportHeight;
        image.width = image.width || viewW - image.xOffset;
        image.height = image.height || viewH - image.yOffset;
        image.needsCopy = true;
        check$1(image.xOffset >= 0 && image.xOffset < viewW && image.yOffset >= 0 && image.yOffset < viewH && image.width > 0 && image.width <= viewW && image.height > 0 && image.height <= viewH, 'copy texture read out of bounds');
      } else if (!data) {
        image.width = image.width || 1;
        image.height = image.height || 1;
        image.channels = image.channels || 4;
      } else if (isTypedArray(data)) {
        image.channels = image.channels || 4;
        image.data = data;
        if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$4) {
          image.type = typedArrayCode$1(data);
        }
      } else if (isNumericArray(data)) {
        image.channels = image.channels || 4;
        convertData(image, data);
        image.alignment = 1;
        image.needsFree = true;
      } else if (isNDArrayLike(data)) {
        var array = data.data;
        if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$4) {
          image.type = typedArrayCode$1(array);
        }
        var shape = data.shape;
        var stride = data.stride;
        var shapeX, shapeY, shapeC, strideX, strideY, strideC;
        if (shape.length === 3) {
          shapeC = shape[2];
          strideC = stride[2];
        } else {
          check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D');
          shapeC = 1;
          strideC = 1;
        }
        shapeX = shape[0];
        shapeY = shape[1];
        strideX = stride[0];
        strideY = stride[1];
        image.alignment = 1;
        image.width = shapeX;
        image.height = shapeY;
        image.channels = shapeC;
        image.format = image.internalformat = CHANNELS_FORMAT[shapeC];
        image.needsFree = true;
        transposeData(image, array, strideX, strideY, strideC, data.offset);
      } else if (isCanvasElement(data) || isContext2D(data)) {
        if (isCanvasElement(data)) {
          image.element = data;
        } else {
          image.element = data.canvas;
        }
        image.width = image.element.width;
        image.height = image.element.height;
        image.channels = 4;
      } else if (isImageElement(data)) {
        image.element = data;
        image.width = data.naturalWidth;
        image.height = data.naturalHeight;
        image.channels = 4;
      } else if (isVideoElement(data)) {
        image.element = data;
        image.width = data.videoWidth;
        image.height = data.videoHeight;
        image.channels = 4;
      } else if (isRectArray(data)) {
        var w = image.width || data[0].length;
        var h = image.height || data.length;
        var c = image.channels;
        if (isArrayLike(data[0][0])) {
          c = c || data[0][0].length;
        } else {
          c = c || 1;
        }
        var arrayShape = flattenUtils.shape(data);
        var n = 1;
        for (var dd = 0; dd < arrayShape.length; ++dd) {
          n *= arrayShape[dd];
        }
        var allocData = preConvert(image, n);
        flattenUtils.flatten(data, arrayShape, '', allocData);
        postConvert(image, allocData);
        image.alignment = 1;
        image.width = w;
        image.height = h;
        image.channels = c;
        image.format = image.internalformat = CHANNELS_FORMAT[c];
        image.needsFree = true;
      }

      if (image.type === GL_FLOAT$3) {
        check$1(limits.extensions.indexOf('oes_texture_float') >= 0, 'oes_texture_float extension not enabled');
      } else if (image.type === GL_HALF_FLOAT_OES$1) {
        check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0, 'oes_texture_half_float extension not enabled');
      }

      // do compressed texture  validation here.
    }

    function setImage(info, target, miplevel) {
      var element = info.element;
      var data = info.data;
      var internalformat = info.internalformat;
      var format = info.format;
      var type = info.type;
      var width = info.width;
      var height = info.height;

      setFlags(info);

      if (element) {
        gl.texImage2D(target, miplevel, format, format, type, element);
      } else if (info.compressed) {
        gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data);
      } else if (info.needsCopy) {
        reglPoll();
        gl.copyTexImage2D(target, miplevel, format, info.xOffset, info.yOffset, width, height, 0);
      } else {
        gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data);
      }
    }

    function setSubImage(info, target, x, y, miplevel) {
      var element = info.element;
      var data = info.data;
      var internalformat = info.internalformat;
      var format = info.format;
      var type = info.type;
      var width = info.width;
      var height = info.height;

      setFlags(info);

      if (element) {
        gl.texSubImage2D(target, miplevel, x, y, format, type, element);
      } else if (info.compressed) {
        gl.compressedTexSubImage2D(target, miplevel, x, y, internalformat, width, height, data);
      } else if (info.needsCopy) {
        reglPoll();
        gl.copyTexSubImage2D(target, miplevel, x, y, info.xOffset, info.yOffset, width, height);
      } else {
        gl.texSubImage2D(target, miplevel, x, y, width, height, format, type, data);
      }
    }

    // texImage pool
    var imagePool = [];

    function allocImage() {
      return imagePool.pop() || new TexImage();
    }

    function freeImage(image) {
      if (image.needsFree) {
        pool.freeType(image.data);
      }
      TexImage.call(image);
      imagePool.push(image);
    }

    // -------------------------------------------------------
    // Mip map
    // -------------------------------------------------------
    function MipMap() {
      TexFlags.call(this);

      this.genMipmaps = false;
      this.mipmapHint = GL_DONT_CARE;
      this.mipmask = 0;
      this.images = Array(16);
    }

    function parseMipMapFromShape(mipmap, width, height) {
      var img = mipmap.images[0] = allocImage();
      mipmap.mipmask = 1;
      img.width = mipmap.width = width;
      img.height = mipmap.height = height;
      img.channels = mipmap.channels = 4;
    }

    function parseMipMapFromObject(mipmap, options) {
      var imgData = null;
      if (isPixelData(options)) {
        imgData = mipmap.images[0] = allocImage();
        copyFlags(imgData, mipmap);
        parseImage(imgData, options);
        mipmap.mipmask = 1;
      } else {
        parseFlags(mipmap, options);
        if (Array.isArray(options.mipmap)) {
          var mipData = options.mipmap;
          for (var i = 0; i < mipData.length; ++i) {
            imgData = mipmap.images[i] = allocImage();
            copyFlags(imgData, mipmap);
            imgData.width >>= i;
            imgData.height >>= i;
            parseImage(imgData, mipData[i]);
            mipmap.mipmask |= 1 << i;
          }
        } else {
          imgData = mipmap.images[0] = allocImage();
          copyFlags(imgData, mipmap);
          parseImage(imgData, options);
          mipmap.mipmask = 1;
        }
      }
      copyFlags(mipmap, mipmap.images[0]);

      // For textures of the compressed format WEBGL_compressed_texture_s3tc
      // we must have that
      //
      // "When level equals zero width and height must be a multiple of 4.
      // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. "
      //
      // but we do not yet support having multiple mipmap levels for compressed textures,
      // so we only test for level zero.

      if (mipmap.compressed && mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT) {
        check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0, 'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4');
      }
    }

    function setMipMap(mipmap, target) {
      var images = mipmap.images;
      for (var i = 0; i < images.length; ++i) {
        if (!images[i]) {
          return;
        }
        setImage(images[i], target, i);
      }
    }

    var mipPool = [];

    function allocMipMap() {
      var result = mipPool.pop() || new MipMap();
      TexFlags.call(result);
      result.mipmask = 0;
      for (var i = 0; i < 16; ++i) {
        result.images[i] = null;
      }
      return result;
    }

    function freeMipMap(mipmap) {
      var images = mipmap.images;
      for (var i = 0; i < images.length; ++i) {
        if (images[i]) {
          freeImage(images[i]);
        }
        images[i] = null;
      }
      mipPool.push(mipmap);
    }

    // -------------------------------------------------------
    // Tex info
    // -------------------------------------------------------
    function TexInfo() {
      this.minFilter = GL_NEAREST$1;
      this.magFilter = GL_NEAREST$1;

      this.wrapS = GL_CLAMP_TO_EDGE$1;
      this.wrapT = GL_CLAMP_TO_EDGE$1;

      this.anisotropic = 1;

      this.genMipmaps = false;
      this.mipmapHint = GL_DONT_CARE;
    }

    function parseTexInfo(info, options) {
      if ('min' in options) {
        var minFilter = options.min;
        check$1.parameter(minFilter, minFilters);
        info.minFilter = minFilters[minFilter];
        if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0) {
          info.genMipmaps = true;
        }
      }

      if ('mag' in options) {
        var magFilter = options.mag;
        check$1.parameter(magFilter, magFilters);
        info.magFilter = magFilters[magFilter];
      }

      var wrapS = info.wrapS;
      var wrapT = info.wrapT;
      if ('wrap' in options) {
        var wrap = options.wrap;
        if (typeof wrap === 'string') {
          check$1.parameter(wrap, wrapModes);
          wrapS = wrapT = wrapModes[wrap];
        } else if (Array.isArray(wrap)) {
          check$1.parameter(wrap[0], wrapModes);
          check$1.parameter(wrap[1], wrapModes);
          wrapS = wrapModes[wrap[0]];
          wrapT = wrapModes[wrap[1]];
        }
      } else {
        if ('wrapS' in options) {
          var optWrapS = options.wrapS;
          check$1.parameter(optWrapS, wrapModes);
          wrapS = wrapModes[optWrapS];
        }
        if ('wrapT' in options) {
          var optWrapT = options.wrapT;
          check$1.parameter(optWrapT, wrapModes);
          wrapT = wrapModes[optWrapT];
        }
      }
      info.wrapS = wrapS;
      info.wrapT = wrapT;

      if ('anisotropic' in options) {
        var anisotropic = options.anisotropic;
        check$1(typeof anisotropic === 'number' && anisotropic >= 1 && anisotropic <= limits.maxAnisotropic, 'aniso samples must be between 1 and ');
        info.anisotropic = options.anisotropic;
      }

      if ('mipmap' in options) {
        var hasMipMap = false;
        switch (typeof options.mipmap) {
          case 'string':
            check$1.parameter(options.mipmap, mipmapHint, 'invalid mipmap hint');
            info.mipmapHint = mipmapHint[options.mipmap];
            info.genMipmaps = true;
            hasMipMap = true;
            break;

          case 'boolean':
            hasMipMap = info.genMipmaps = options.mipmap;
            break;

          case 'object':
            check$1(Array.isArray(options.mipmap), 'invalid mipmap type');
            info.genMipmaps = false;
            hasMipMap = true;
            break;

          default:
            check$1.raise('invalid mipmap type');
        }
        if (hasMipMap && !('min' in options)) {
          info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1;
        }
      }
    }

    function setTexInfo(info, target) {
      gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter);
      gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter);
      gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS);
      gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT);
      if (extensions.ext_texture_filter_anisotropic) {
        gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic);
      }
      if (info.genMipmaps) {
        gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint);
        gl.generateMipmap(target);
      }
    }

    // -------------------------------------------------------
    // Full texture object
    // -------------------------------------------------------
    var textureCount = 0;
    var textureSet = {};
    var numTexUnits = limits.maxTextureUnits;
    var textureUnits = Array(numTexUnits).map(function () {
      return null;
    });

    function REGLTexture(target) {
      TexFlags.call(this);
      this.mipmask = 0;
      this.internalformat = GL_RGBA;

      this.id = textureCount++;

      this.refCount = 1;

      this.target = target;
      this.texture = gl.createTexture();

      this.unit = -1;
      this.bindCount = 0;

      this.texInfo = new TexInfo();

      if (config.profile) {
        this.stats = { size: 0 };
      }
    }

    function tempBind(texture) {
      gl.activeTexture(GL_TEXTURE0);
      gl.bindTexture(texture.target, texture.texture);
    }

    function tempRestore() {
      var prev = textureUnits[0];
      if (prev) {
        gl.bindTexture(prev.target, prev.texture);
      } else {
        gl.bindTexture(GL_TEXTURE_2D, null);
      }
    }

    function destroy(texture) {
      var handle = texture.texture;
      check$1(handle, 'must not double destroy texture');
      var unit = texture.unit;
      var target = texture.target;
      if (unit >= 0) {
        gl.activeTexture(GL_TEXTURE0 + unit);
        gl.bindTexture(target, null);
        textureUnits[unit] = null;
      }
      gl.deleteTexture(handle);
      texture.texture = null;
      texture.params = null;
      texture.pixels = null;
      texture.refCount = 0;
      delete textureSet[texture.id];
      stats.textureCount--;
    }

    extend(REGLTexture.prototype, {
      bind: function () {
        var texture = this;
        texture.bindCount += 1;
        var unit = texture.unit;
        if (unit < 0) {
          for (var i = 0; i < numTexUnits; ++i) {
            var other = textureUnits[i];
            if (other) {
              if (other.bindCount > 0) {
                continue;
              }
              other.unit = -1;
            }
            textureUnits[i] = texture;
            unit = i;
            break;
          }
          if (unit >= numTexUnits) {
            check$1.raise('insufficient number of texture units');
          }
          if (config.profile && stats.maxTextureUnits < unit + 1) {
            stats.maxTextureUnits = unit + 1; // +1, since the units are zero-based
          }
          texture.unit = unit;
          gl.activeTexture(GL_TEXTURE0 + unit);
          gl.bindTexture(texture.target, texture.texture);
        }
        return unit;
      },

      unbind: function () {
        this.bindCount -= 1;
      },

      decRef: function () {
        if (--this.refCount <= 0) {
          destroy(this);
        }
      }
    });

    function createTexture2D(a, b) {
      var texture = new REGLTexture(GL_TEXTURE_2D);
      textureSet[texture.id] = texture;
      stats.textureCount++;

      function reglTexture2D(a, b) {
        var texInfo = texture.texInfo;
        TexInfo.call(texInfo);
        var mipData = allocMipMap();

        if (typeof a === 'number') {
          if (typeof b === 'number') {
            parseMipMapFromShape(mipData, a | 0, b | 0);
          } else {
            parseMipMapFromShape(mipData, a | 0, a | 0);
          }
        } else if (a) {
          check$1.type(a, 'object', 'invalid arguments to regl.texture');
          parseTexInfo(texInfo, a);
          parseMipMapFromObject(mipData, a);
        } else {
          // empty textures get assigned a default shape of 1x1
          parseMipMapFromShape(mipData, 1, 1);
        }

        if (texInfo.genMipmaps) {
          mipData.mipmask = (mipData.width << 1) - 1;
        }
        texture.mipmask = mipData.mipmask;

        copyFlags(texture, mipData);

        check$1.texture2D(texInfo, mipData, limits);
        texture.internalformat = mipData.internalformat;

        reglTexture2D.width = mipData.width;
        reglTexture2D.height = mipData.height;

        tempBind(texture);
        setMipMap(mipData, GL_TEXTURE_2D);
        setTexInfo(texInfo, GL_TEXTURE_2D);
        tempRestore();

        freeMipMap(mipData);

        if (config.profile) {
          texture.stats.size = getTextureSize(texture.internalformat, texture.type, mipData.width, mipData.height, texInfo.genMipmaps, false);
        }
        reglTexture2D.format = textureFormatsInvert[texture.internalformat];
        reglTexture2D.type = textureTypesInvert[texture.type];

        reglTexture2D.mag = magFiltersInvert[texInfo.magFilter];
        reglTexture2D.min = minFiltersInvert[texInfo.minFilter];

        reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS];
        reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT];

        return reglTexture2D;
      }

      function subimage(image, x_, y_, level_) {
        check$1(!!image, 'must specify image data');

        var x = x_ | 0;
        var y = y_ | 0;
        var level = level_ | 0;

        var imageData = allocImage();
        copyFlags(imageData, texture);
        imageData.width = 0;
        imageData.height = 0;
        parseImage(imageData, image);
        imageData.width = imageData.width || (texture.width >> level) - x;
        imageData.height = imageData.height || (texture.height >> level) - y;

        check$1(texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat, 'incompatible format for texture.subimage');
        check$1(x >= 0 && y >= 0 && x + imageData.width <= texture.width && y + imageData.height <= texture.height, 'texture.subimage write out of bounds');
        check$1(texture.mipmask & 1 << level, 'missing mipmap data');
        check$1(imageData.data || imageData.element || imageData.needsCopy, 'missing image data');

        tempBind(texture);
        setSubImage(imageData, GL_TEXTURE_2D, x, y, level);
        tempRestore();

        freeImage(imageData);

        return reglTexture2D;
      }

      function resize(w_, h_) {
        var w = w_ | 0;
        var h = h_ | 0 || w;
        if (w === texture.width && h === texture.height) {
          return reglTexture2D;
        }

        reglTexture2D.width = texture.width = w;
        reglTexture2D.height = texture.height = h;

        tempBind(texture);
        for (var i = 0; texture.mipmask >> i; ++i) {
          gl.texImage2D(GL_TEXTURE_2D, i, texture.format, w >> i, h >> i, 0, texture.format, texture.type, null);
        }
        tempRestore();

        // also, recompute the texture size.
        if (config.profile) {
          texture.stats.size = getTextureSize(texture.internalformat, texture.type, w, h, false, false);
        }

        return reglTexture2D;
      }

      reglTexture2D(a, b);

      reglTexture2D.subimage = subimage;
      reglTexture2D.resize = resize;
      reglTexture2D._reglType = 'texture2d';
      reglTexture2D._texture = texture;
      if (config.profile) {
        reglTexture2D.stats = texture.stats;
      }
      reglTexture2D.destroy = function () {
        texture.decRef();
      };

      return reglTexture2D;
    }

    function createTextureCube(a0, a1, a2, a3, a4, a5) {
      var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP);
      textureSet[texture.id] = texture;
      stats.cubeCount++;

      var faces = new Array(6);

      function reglTextureCube(a0, a1, a2, a3, a4, a5) {
        var i;
        var texInfo = texture.texInfo;
        TexInfo.call(texInfo);
        for (i = 0; i < 6; ++i) {
          faces[i] = allocMipMap();
        }

        if (typeof a0 === 'number' || !a0) {
          var s = a0 | 0 || 1;
          for (i = 0; i < 6; ++i) {
            parseMipMapFromShape(faces[i], s, s);
          }
        } else if (typeof a0 === 'object') {
          if (a1) {
            parseMipMapFromObject(faces[0], a0);
            parseMipMapFromObject(faces[1], a1);
            parseMipMapFromObject(faces[2], a2);
            parseMipMapFromObject(faces[3], a3);
            parseMipMapFromObject(faces[4], a4);
            parseMipMapFromObject(faces[5], a5);
          } else {
            parseTexInfo(texInfo, a0);
            parseFlags(texture, a0);
            if ('faces' in a0) {
              var face_input = a0.faces;
              check$1(Array.isArray(face_input) && face_input.length === 6, 'cube faces must be a length 6 array');
              for (i = 0; i < 6; ++i) {
                check$1(typeof face_input[i] === 'object' && !!face_input[i], 'invalid input for cube map face');
                copyFlags(faces[i], texture);
                parseMipMapFromObject(faces[i], face_input[i]);
              }
            } else {
              for (i = 0; i < 6; ++i) {
                parseMipMapFromObject(faces[i], a0);
              }
            }
          }
        } else {
          check$1.raise('invalid arguments to cube map');
        }

        copyFlags(texture, faces[0]);
        if (texInfo.genMipmaps) {
          texture.mipmask = (faces[0].width << 1) - 1;
        } else {
          texture.mipmask = faces[0].mipmask;
        }

        check$1.textureCube(texture, texInfo, faces, limits);
        texture.internalformat = faces[0].internalformat;

        reglTextureCube.width = faces[0].width;
        reglTextureCube.height = faces[0].height;

        tempBind(texture);
        for (i = 0; i < 6; ++i) {
          setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X + i);
        }
        setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP);
        tempRestore();

        if (config.profile) {
          texture.stats.size = getTextureSize(texture.internalformat, texture.type, reglTextureCube.width, reglTextureCube.height, texInfo.genMipmaps, true);
        }

        reglTextureCube.format = textureFormatsInvert[texture.internalformat];
        reglTextureCube.type = textureTypesInvert[texture.type];

        reglTextureCube.mag = magFiltersInvert[texInfo.magFilter];
        reglTextureCube.min = minFiltersInvert[texInfo.minFilter];

        reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS];
        reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT];

        for (i = 0; i < 6; ++i) {
          freeMipMap(faces[i]);
        }

        return reglTextureCube;
      }

      function subimage(face, image, x_, y_, level_) {
        check$1(!!image, 'must specify image data');
        check$1(typeof face === 'number' && face === (face | 0) && face >= 0 && face < 6, 'invalid face');

        var x = x_ | 0;
        var y = y_ | 0;
        var level = level_ | 0;

        var imageData = allocImage();
        copyFlags(imageData, texture);
        imageData.width = 0;
        imageData.height = 0;
        parseImage(imageData, image);
        imageData.width = imageData.width || (texture.width >> level) - x;
        imageData.height = imageData.height || (texture.height >> level) - y;

        check$1(texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat, 'incompatible format for texture.subimage');
        check$1(x >= 0 && y >= 0 && x + imageData.width <= texture.width && y + imageData.height <= texture.height, 'texture.subimage write out of bounds');
        check$1(texture.mipmask & 1 << level, 'missing mipmap data');
        check$1(imageData.data || imageData.element || imageData.needsCopy, 'missing image data');

        tempBind(texture);
        setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, x, y, level);
        tempRestore();

        freeImage(imageData);

        return reglTextureCube;
      }

      function resize(radius_) {
        var radius = radius_ | 0;
        if (radius === texture.width) {
          return;
        }

        reglTextureCube.width = texture.width = radius;
        reglTextureCube.height = texture.height = radius;

        tempBind(texture);
        for (var i = 0; i < 6; ++i) {
          for (var j = 0; texture.mipmask >> j; ++j) {
            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, j, texture.format, radius >> j, radius >> j, 0, texture.format, texture.type, null);
          }
        }
        tempRestore();

        if (config.profile) {
          texture.stats.size = getTextureSize(texture.internalformat, texture.type, reglTextureCube.width, reglTextureCube.height, false, true);
        }

        return reglTextureCube;
      }

      reglTextureCube(a0, a1, a2, a3, a4, a5);

      reglTextureCube.subimage = subimage;
      reglTextureCube.resize = resize;
      reglTextureCube._reglType = 'textureCube';
      reglTextureCube._texture = texture;
      if (config.profile) {
        reglTextureCube.stats = texture.stats;
      }
      reglTextureCube.destroy = function () {
        texture.decRef();
      };

      return reglTextureCube;
    }

    // Called when regl is destroyed
    function destroyTextures() {
      for (var i = 0; i < numTexUnits; ++i) {
        gl.activeTexture(GL_TEXTURE0 + i);
        gl.bindTexture(GL_TEXTURE_2D, null);
        textureUnits[i] = null;
      }
      values(textureSet).forEach(destroy);

      stats.cubeCount = 0;
      stats.textureCount = 0;
    }

    if (config.profile) {
      stats.getTotalTextureSize = function () {
        var total = 0;
        Object.keys(textureSet).forEach(function (key) {
          total += textureSet[key].stats.size;
        });
        return total;
      };
    }

    function restoreTextures() {
      values(textureSet).forEach(function (texture) {
        texture.texture = gl.createTexture();
        gl.bindTexture(texture.target, texture.texture);
        for (var i = 0; i < 32; ++i) {
          if ((texture.mipmask & 1 << i) === 0) {
            continue;
          }
          if (texture.target === GL_TEXTURE_2D) {
            gl.texImage2D(GL_TEXTURE_2D, i, texture.internalformat, texture.width >> i, texture.height >> i, 0, texture.internalformat, texture.type, null);
          } else {
            for (var j = 0; j < 6; ++j) {
              gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + j, i, texture.internalformat, texture.width >> i, texture.height >> i, 0, texture.internalformat, texture.type, null);
            }
          }
        }
        setTexInfo(texture.texInfo, texture.target);
      });
    }

    return {
      create2D: createTexture2D,
      createCube: createTextureCube,
      clear: destroyTextures,
      getTexture: function (wrapper) {
        return null;
      },
      restore: restoreTextures
    };
  }

  var GL_RENDERBUFFER = 0x8D41;

  var GL_RGBA4$1 = 0x8056;
  var GL_RGB5_A1$1 = 0x8057;
  var GL_RGB565$1 = 0x8D62;
  var GL_DEPTH_COMPONENT16 = 0x81A5;
  var GL_STENCIL_INDEX8 = 0x8D48;
  var GL_DEPTH_STENCIL$1 = 0x84F9;

  var GL_SRGB8_ALPHA8_EXT = 0x8C43;

  var GL_RGBA32F_EXT = 0x8814;

  var GL_RGBA16F_EXT = 0x881A;
  var GL_RGB16F_EXT = 0x881B;

  var FORMAT_SIZES = [];

  FORMAT_SIZES[GL_RGBA4$1] = 2;
  FORMAT_SIZES[GL_RGB5_A1$1] = 2;
  FORMAT_SIZES[GL_RGB565$1] = 2;

  FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2;
  FORMAT_SIZES[GL_STENCIL_INDEX8] = 1;
  FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4;

  FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4;
  FORMAT_SIZES[GL_RGBA32F_EXT] = 16;
  FORMAT_SIZES[GL_RGBA16F_EXT] = 8;
  FORMAT_SIZES[GL_RGB16F_EXT] = 6;

  function getRenderbufferSize(format, width, height) {
    return FORMAT_SIZES[format] * width * height;
  }

  var wrapRenderbuffers = function (gl, extensions, limits, stats, config) {
    var formatTypes = {
      'rgba4': GL_RGBA4$1,
      'rgb565': GL_RGB565$1,
      'rgb5 a1': GL_RGB5_A1$1,
      'depth': GL_DEPTH_COMPONENT16,
      'stencil': GL_STENCIL_INDEX8,
      'depth stencil': GL_DEPTH_STENCIL$1
    };

    if (extensions.ext_srgb) {
      formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT;
    }

    if (extensions.ext_color_buffer_half_float) {
      formatTypes['rgba16f'] = GL_RGBA16F_EXT;
      formatTypes['rgb16f'] = GL_RGB16F_EXT;
    }

    if (extensions.webgl_color_buffer_float) {
      formatTypes['rgba32f'] = GL_RGBA32F_EXT;
    }

    var formatTypesInvert = [];
    Object.keys(formatTypes).forEach(function (key) {
      var val = formatTypes[key];
      formatTypesInvert[val] = key;
    });

    var renderbufferCount = 0;
    var renderbufferSet = {};

    function REGLRenderbuffer(renderbuffer) {
      this.id = renderbufferCount++;
      this.refCount = 1;

      this.renderbuffer = renderbuffer;

      this.format = GL_RGBA4$1;
      this.width = 0;
      this.height = 0;

      if (config.profile) {
        this.stats = { size: 0 };
      }
    }

    REGLRenderbuffer.prototype.decRef = function () {
      if (--this.refCount <= 0) {
        destroy(this);
      }
    };

    function destroy(rb) {
      var handle = rb.renderbuffer;
      check$1(handle, 'must not double destroy renderbuffer');
      gl.bindRenderbuffer(GL_RENDERBUFFER, null);
      gl.deleteRenderbuffer(handle);
      rb.renderbuffer = null;
      rb.refCount = 0;
      delete renderbufferSet[rb.id];
      stats.renderbufferCount--;
    }

    function createRenderbuffer(a, b) {
      var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer());
      renderbufferSet[renderbuffer.id] = renderbuffer;
      stats.renderbufferCount++;

      function reglRenderbuffer(a, b) {
        var w = 0;
        var h = 0;
        var format = GL_RGBA4$1;

        if (typeof a === 'object' && a) {
          var options = a;
          if ('shape' in options) {
            var shape = options.shape;
            check$1(Array.isArray(shape) && shape.length >= 2, 'invalid renderbuffer shape');
            w = shape[0] | 0;
            h = shape[1] | 0;
          } else {
            if ('radius' in options) {
              w = h = options.radius | 0;
            }
            if ('width' in options) {
              w = options.width | 0;
            }
            if ('height' in options) {
              h = options.height | 0;
            }
          }
          if ('format' in options) {
            check$1.parameter(options.format, formatTypes, 'invalid renderbuffer format');
            format = formatTypes[options.format];
          }
        } else if (typeof a === 'number') {
          w = a | 0;
          if (typeof b === 'number') {
            h = b | 0;
          } else {
            h = w;
          }
        } else if (!a) {
          w = h = 1;
        } else {
          check$1.raise('invalid arguments to renderbuffer constructor');
        }

        // check shape
        check$1(w > 0 && h > 0 && w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize, 'invalid renderbuffer size');

        if (w === renderbuffer.width && h === renderbuffer.height && format === renderbuffer.format) {
          return;
        }

        reglRenderbuffer.width = renderbuffer.width = w;
        reglRenderbuffer.height = renderbuffer.height = h;
        renderbuffer.format = format;

        gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
        gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h);

        if (config.profile) {
          renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
        }
        reglRenderbuffer.format = formatTypesInvert[renderbuffer.format];

        return reglRenderbuffer;
      }

      function resize(w_, h_) {
        var w = w_ | 0;
        var h = h_ | 0 || w;

        if (w === renderbuffer.width && h === renderbuffer.height) {
          return reglRenderbuffer;
        }

        // check shape
        check$1(w > 0 && h > 0 && w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize, 'invalid renderbuffer size');

        reglRenderbuffer.width = renderbuffer.width = w;
        reglRenderbuffer.height = renderbuffer.height = h;

        gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
        gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h);

        // also, recompute size.
        if (config.profile) {
          renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
        }

        return reglRenderbuffer;
      }

      reglRenderbuffer(a, b);

      reglRenderbuffer.resize = resize;
      reglRenderbuffer._reglType = 'renderbuffer';
      reglRenderbuffer._renderbuffer = renderbuffer;
      if (config.profile) {
        reglRenderbuffer.stats = renderbuffer.stats;
      }
      reglRenderbuffer.destroy = function () {
        renderbuffer.decRef();
      };

      return reglRenderbuffer;
    }

    if (config.profile) {
      stats.getTotalRenderbufferSize = function () {
        var total = 0;
        Object.keys(renderbufferSet).forEach(function (key) {
          total += renderbufferSet[key].stats.size;
        });
        return total;
      };
    }

    function restoreRenderbuffers() {
      values(renderbufferSet).forEach(function (rb) {
        rb.renderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer);
        gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height);
      });
      gl.bindRenderbuffer(GL_RENDERBUFFER, null);
    }

    return {
      create: createRenderbuffer,
      clear: function () {
        values(renderbufferSet).forEach(destroy);
      },
      restore: restoreRenderbuffers
    };
  };

  // We store these constants so that the minifier can inline them
  var GL_FRAMEBUFFER = 0x8D40;
  var GL_RENDERBUFFER$1 = 0x8D41;

  var GL_TEXTURE_2D$1 = 0x0DE1;
  var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515;

  var GL_COLOR_ATTACHMENT0 = 0x8CE0;
  var GL_DEPTH_ATTACHMENT = 0x8D00;
  var GL_STENCIL_ATTACHMENT = 0x8D20;
  var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;

  var GL_FRAMEBUFFER_COMPLETE = 0x8CD5;
  var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
  var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
  var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
  var GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

  var GL_HALF_FLOAT_OES$2 = 0x8D61;
  var GL_UNSIGNED_BYTE$5 = 0x1401;
  var GL_FLOAT$4 = 0x1406;

  var GL_RGBA$1 = 0x1908;

  var GL_DEPTH_COMPONENT$1 = 0x1902;

  var colorTextureFormatEnums = [GL_RGBA$1];

  // for every texture format, store
  // the number of channels
  var textureFormatChannels = [];
  textureFormatChannels[GL_RGBA$1] = 4;

  // for every texture type, store
  // the size in bytes.
  var textureTypeSizes = [];
  textureTypeSizes[GL_UNSIGNED_BYTE$5] = 1;
  textureTypeSizes[GL_FLOAT$4] = 4;
  textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2;

  var GL_RGBA4$2 = 0x8056;
  var GL_RGB5_A1$2 = 0x8057;
  var GL_RGB565$2 = 0x8D62;
  var GL_DEPTH_COMPONENT16$1 = 0x81A5;
  var GL_STENCIL_INDEX8$1 = 0x8D48;
  var GL_DEPTH_STENCIL$2 = 0x84F9;

  var GL_SRGB8_ALPHA8_EXT$1 = 0x8C43;

  var GL_RGBA32F_EXT$1 = 0x8814;

  var GL_RGBA16F_EXT$1 = 0x881A;
  var GL_RGB16F_EXT$1 = 0x881B;

  var colorRenderbufferFormatEnums = [GL_RGBA4$2, GL_RGB5_A1$2, GL_RGB565$2, GL_SRGB8_ALPHA8_EXT$1, GL_RGBA16F_EXT$1, GL_RGB16F_EXT$1, GL_RGBA32F_EXT$1];

  var statusCode = {};
  statusCode[GL_FRAMEBUFFER_COMPLETE] = 'complete';
  statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment';
  statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions';
  statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment';
  statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported';

  function wrapFBOState(gl, extensions, limits, textureState, renderbufferState, stats) {
    var framebufferState = {
      cur: null,
      next: null,
      dirty: false,
      setFBO: null
    };

    var colorTextureFormats = ['rgba'];
    var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1'];

    if (extensions.ext_srgb) {
      colorRenderbufferFormats.push('srgba');
    }

    if (extensions.ext_color_buffer_half_float) {
      colorRenderbufferFormats.push('rgba16f', 'rgb16f');
    }

    if (extensions.webgl_color_buffer_float) {
      colorRenderbufferFormats.push('rgba32f');
    }

    var colorTypes = ['uint8'];
    if (extensions.oes_texture_half_float) {
      colorTypes.push('half float', 'float16');
    }
    if (extensions.oes_texture_float) {
      colorTypes.push('float', 'float32');
    }

    function FramebufferAttachment(target, texture, renderbuffer) {
      this.target = target;
      this.texture = texture;
      this.renderbuffer = renderbuffer;

      var w = 0;
      var h = 0;
      if (texture) {
        w = texture.width;
        h = texture.height;
      } else if (renderbuffer) {
        w = renderbuffer.width;
        h = renderbuffer.height;
      }
      this.width = w;
      this.height = h;
    }

    function decRef(attachment) {
      if (attachment) {
        if (attachment.texture) {
          attachment.texture._texture.decRef();
        }
        if (attachment.renderbuffer) {
          attachment.renderbuffer._renderbuffer.decRef();
        }
      }
    }

    function incRefAndCheckShape(attachment, width, height) {
      if (!attachment) {
        return;
      }
      if (attachment.texture) {
        var texture = attachment.texture._texture;
        var tw = Math.max(1, texture.width);
        var th = Math.max(1, texture.height);
        check$1(tw === width && th === height, 'inconsistent width/height for supplied texture');
        texture.refCount += 1;
      } else {
        var renderbuffer = attachment.renderbuffer._renderbuffer;
        check$1(renderbuffer.width === width && renderbuffer.height === height, 'inconsistent width/height for renderbuffer');
        renderbuffer.refCount += 1;
      }
    }

    function attach(location, attachment) {
      if (attachment) {
        if (attachment.texture) {
          gl.framebufferTexture2D(GL_FRAMEBUFFER, location, attachment.target, attachment.texture._texture.texture, 0);
        } else {
          gl.framebufferRenderbuffer(GL_FRAMEBUFFER, location, GL_RENDERBUFFER$1, attachment.renderbuffer._renderbuffer.renderbuffer);
        }
      }
    }

    function parseAttachment(attachment) {
      var target = GL_TEXTURE_2D$1;
      var texture = null;
      var renderbuffer = null;

      var data = attachment;
      if (typeof attachment === 'object') {
        data = attachment.data;
        if ('target' in attachment) {
          target = attachment.target | 0;
        }
      }

      check$1.type(data, 'function', 'invalid attachment data');

      var type = data._reglType;
      if (type === 'texture2d') {
        texture = data;
        check$1(target === GL_TEXTURE_2D$1);
      } else if (type === 'textureCube') {
        texture = data;
        check$1(target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 && target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + 6, 'invalid cube map target');
      } else if (type === 'renderbuffer') {
        renderbuffer = data;
        target = GL_RENDERBUFFER$1;
      } else {
        check$1.raise('invalid regl object for attachment');
      }

      return new FramebufferAttachment(target, texture, renderbuffer);
    }

    function allocAttachment(width, height, isTexture, format, type) {
      if (isTexture) {
        var texture = textureState.create2D({
          width: width,
          height: height,
          format: format,
          type: type
        });
        texture._texture.refCount = 0;
        return new FramebufferAttachment(GL_TEXTURE_2D$1, texture, null);
      } else {
        var rb = renderbufferState.create({
          width: width,
          height: height,
          format: format
        });
        rb._renderbuffer.refCount = 0;
        return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb);
      }
    }

    function unwrapAttachment(attachment) {
      return attachment && (attachment.texture || attachment.renderbuffer);
    }

    function resizeAttachment(attachment, w, h) {
      if (attachment) {
        if (attachment.texture) {
          attachment.texture.resize(w, h);
        } else if (attachment.renderbuffer) {
          attachment.renderbuffer.resize(w, h);
        }
      }
    }

    var framebufferCount = 0;
    var framebufferSet = {};

    function REGLFramebuffer() {
      this.id = framebufferCount++;
      framebufferSet[this.id] = this;

      this.framebuffer = gl.createFramebuffer();
      this.width = 0;
      this.height = 0;

      this.colorAttachments = [];
      this.depthAttachment = null;
      this.stencilAttachment = null;
      this.depthStencilAttachment = null;
    }

    function decFBORefs(framebuffer) {
      framebuffer.colorAttachments.forEach(decRef);
      decRef(framebuffer.depthAttachment);
      decRef(framebuffer.stencilAttachment);
      decRef(framebuffer.depthStencilAttachment);
    }

    function destroy(framebuffer) {
      var handle = framebuffer.framebuffer;
      check$1(handle, 'must not double destroy framebuffer');
      gl.deleteFramebuffer(handle);
      framebuffer.framebuffer = null;
      stats.framebufferCount--;
      delete framebufferSet[framebuffer.id];
    }

    function updateFramebuffer(framebuffer) {
      var i;

      gl.bindFramebuffer(GL_FRAMEBUFFER, framebuffer.framebuffer);
      var colorAttachments = framebuffer.colorAttachments;
      for (i = 0; i < colorAttachments.length; ++i) {
        attach(GL_COLOR_ATTACHMENT0 + i, colorAttachments[i]);
      }
      for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
        gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D$1, null, 0);
      }

      gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D$1, null, 0);
      gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D$1, null, 0);
      gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D$1, null, 0);

      attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment);
      attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment);
      attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment);

      // Check status code
      var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER);
      if (status !== GL_FRAMEBUFFER_COMPLETE) {
        check$1.raise('framebuffer configuration not supported, status = ' + statusCode[status]);
      }

      gl.bindFramebuffer(GL_FRAMEBUFFER, framebufferState.next);
      framebufferState.cur = framebufferState.next;

      // FIXME: Clear error code here.  This is a work around for a bug in
      // headless-gl
      gl.getError();
    }

    function createFBO(a0, a1) {
      var framebuffer = new REGLFramebuffer();
      stats.framebufferCount++;

      function reglFramebuffer(a, b) {
        var i;

        check$1(framebufferState.next !== framebuffer, 'can not update framebuffer which is currently in use');

        var extDrawBuffers = extensions.webgl_draw_buffers;

        var width = 0;
        var height = 0;

        var needsDepth = true;
        var needsStencil = true;

        var colorBuffer = null;
        var colorTexture = true;
        var colorFormat = 'rgba';
        var colorType = 'uint8';
        var colorCount = 1;

        var depthBuffer = null;
        var stencilBuffer = null;
        var depthStencilBuffer = null;
        var depthStencilTexture = false;

        if (typeof a === 'number') {
          width = a | 0;
          height = b | 0 || width;
        } else if (!a) {
          width = height = 1;
        } else {
          check$1.type(a, 'object', 'invalid arguments for framebuffer');
          var options = a;

          if ('shape' in options) {
            var shape = options.shape;
            check$1(Array.isArray(shape) && shape.length >= 2, 'invalid shape for framebuffer');
            width = shape[0];
            height = shape[1];
          } else {
            if ('radius' in options) {
              width = height = options.radius;
            }
            if ('width' in options) {
              width = options.width;
            }
            if ('height' in options) {
              height = options.height;
            }
          }

          if ('color' in options || 'colors' in options) {
            colorBuffer = options.color || options.colors;
            if (Array.isArray(colorBuffer)) {
              check$1(colorBuffer.length === 1 || extDrawBuffers, 'multiple render targets not supported');
            }
          }

          if (!colorBuffer) {
            if ('colorCount' in options) {
              colorCount = options.colorCount | 0;
              check$1(colorCount > 0, 'invalid color buffer count');
            }

            if ('colorTexture' in options) {
              colorTexture = !!options.colorTexture;
              colorFormat = 'rgba4';
            }

            if ('colorType' in options) {
              colorType = options.colorType;
              if (!colorTexture) {
                if (colorType === 'half float' || colorType === 'float16') {
                  check$1(extensions.ext_color_buffer_half_float, 'you must enable EXT_color_buffer_half_float to use 16-bit render buffers');
                  colorFormat = 'rgba16f';
                } else if (colorType === 'float' || colorType === 'float32') {
                  check$1(extensions.webgl_color_buffer_float, 'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers');
                  colorFormat = 'rgba32f';
                }
              } else {
                check$1(extensions.oes_texture_float || !(colorType === 'float' || colorType === 'float32'), 'you must enable OES_texture_float in order to use floating point framebuffer objects');
                check$1(extensions.oes_texture_half_float || !(colorType === 'half float' || colorType === 'float16'), 'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects');
              }
              check$1.oneOf(colorType, colorTypes, 'invalid color type');
            }

            if ('colorFormat' in options) {
              colorFormat = options.colorFormat;
              if (colorTextureFormats.indexOf(colorFormat) >= 0) {
                colorTexture = true;
              } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
                colorTexture = false;
              } else {
                if (colorTexture) {
                  check$1.oneOf(options.colorFormat, colorTextureFormats, 'invalid color format for texture');
                } else {
                  check$1.oneOf(options.colorFormat, colorRenderbufferFormats, 'invalid color format for renderbuffer');
                }
              }
            }
          }

          if ('depthTexture' in options || 'depthStencilTexture' in options) {
            depthStencilTexture = !!(options.depthTexture || options.depthStencilTexture);
            check$1(!depthStencilTexture || extensions.webgl_depth_texture, 'webgl_depth_texture extension not supported');
          }

          if ('depth' in options) {
            if (typeof options.depth === 'boolean') {
              needsDepth = options.depth;
            } else {
              depthBuffer = options.depth;
              needsStencil = false;
            }
          }

          if ('stencil' in options) {
            if (typeof options.stencil === 'boolean') {
              needsStencil = options.stencil;
            } else {
              stencilBuffer = options.stencil;
              needsDepth = false;
            }
          }

          if ('depthStencil' in options) {
            if (typeof options.depthStencil === 'boolean') {
              needsDepth = needsStencil = options.depthStencil;
            } else {
              depthStencilBuffer = options.depthStencil;
              needsDepth = false;
              needsStencil = false;
            }
          }
        }

        // parse attachments
        var colorAttachments = null;
        var depthAttachment = null;
        var stencilAttachment = null;
        var depthStencilAttachment = null;

        // Set up color attachments
        if (Array.isArray(colorBuffer)) {
          colorAttachments = colorBuffer.map(parseAttachment);
        } else if (colorBuffer) {
          colorAttachments = [parseAttachment(colorBuffer)];
        } else {
          colorAttachments = new Array(colorCount);
          for (i = 0; i < colorCount; ++i) {
            colorAttachments[i] = allocAttachment(width, height, colorTexture, colorFormat, colorType);
          }
        }

        check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1, 'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.');
        check$1(colorAttachments.length <= limits.maxColorAttachments, 'too many color attachments, not supported');

        width = width || colorAttachments[0].width;
        height = height || colorAttachments[0].height;

        if (depthBuffer) {
          depthAttachment = parseAttachment(depthBuffer);
        } else if (needsDepth && !needsStencil) {
          depthAttachment = allocAttachment(width, height, depthStencilTexture, 'depth', 'uint32');
        }

        if (stencilBuffer) {
          stencilAttachment = parseAttachment(stencilBuffer);
        } else if (needsStencil && !needsDepth) {
          stencilAttachment = allocAttachment(width, height, false, 'stencil', 'uint8');
        }

        if (depthStencilBuffer) {
          depthStencilAttachment = parseAttachment(depthStencilBuffer);
        } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
          depthStencilAttachment = allocAttachment(width, height, depthStencilTexture, 'depth stencil', 'depth stencil');
        }

        check$1(!!depthBuffer + !!stencilBuffer + !!depthStencilBuffer <= 1, 'invalid framebuffer configuration, can specify exactly one depth/stencil attachment');

        var commonColorAttachmentSize = null;

        for (i = 0; i < colorAttachments.length; ++i) {
          incRefAndCheckShape(colorAttachments[i], width, height);
          check$1(!colorAttachments[i] || colorAttachments[i].texture && colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0 || colorAttachments[i].renderbuffer && colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0, 'framebuffer color attachment ' + i + ' is invalid');

          if (colorAttachments[i] && colorAttachments[i].texture) {
            var colorAttachmentSize = textureFormatChannels[colorAttachments[i].texture._texture.format] * textureTypeSizes[colorAttachments[i].texture._texture.type];

            if (commonColorAttachmentSize === null) {
              commonColorAttachmentSize = colorAttachmentSize;
            } else {
              // We need to make sure that all color attachments have the same number of bitplanes
              // (that is, the same numer of bits per pixel)
              // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.
              check$1(commonColorAttachmentSize === colorAttachmentSize, 'all color attachments much have the same number of bits per pixel.');
            }
          }
        }
        incRefAndCheckShape(depthAttachment, width, height);
        check$1(!depthAttachment || depthAttachment.texture && depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1 || depthAttachment.renderbuffer && depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1, 'invalid depth attachment for framebuffer object');
        incRefAndCheckShape(stencilAttachment, width, height);
        check$1(!stencilAttachment || stencilAttachment.renderbuffer && stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1, 'invalid stencil attachment for framebuffer object');
        incRefAndCheckShape(depthStencilAttachment, width, height);
        check$1(!depthStencilAttachment || depthStencilAttachment.texture && depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2 || depthStencilAttachment.renderbuffer && depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2, 'invalid depth-stencil attachment for framebuffer object');

        // decrement references
        decFBORefs(framebuffer);

        framebuffer.width = width;
        framebuffer.height = height;

        framebuffer.colorAttachments = colorAttachments;
        framebuffer.depthAttachment = depthAttachment;
        framebuffer.stencilAttachment = stencilAttachment;
        framebuffer.depthStencilAttachment = depthStencilAttachment;

        reglFramebuffer.color = colorAttachments.map(unwrapAttachment);
        reglFramebuffer.depth = unwrapAttachment(depthAttachment);
        reglFramebuffer.stencil = unwrapAttachment(stencilAttachment);
        reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment);

        reglFramebuffer.width = framebuffer.width;
        reglFramebuffer.height = framebuffer.height;

        updateFramebuffer(framebuffer);

        return reglFramebuffer;
      }

      function resize(w_, h_) {
        check$1(framebufferState.next !== framebuffer, 'can not resize a framebuffer which is currently in use');

        var w = w_ | 0;
        var h = h_ | 0 || w;
        if (w === framebuffer.width && h === framebuffer.height) {
          return reglFramebuffer;
        }

        // resize all buffers
        var colorAttachments = framebuffer.colorAttachments;
        for (var i = 0; i < colorAttachments.length; ++i) {
          resizeAttachment(colorAttachments[i], w, h);
        }
        resizeAttachment(framebuffer.depthAttachment, w, h);
        resizeAttachment(framebuffer.stencilAttachment, w, h);
        resizeAttachment(framebuffer.depthStencilAttachment, w, h);

        framebuffer.width = reglFramebuffer.width = w;
        framebuffer.height = reglFramebuffer.height = h;

        updateFramebuffer(framebuffer);

        return reglFramebuffer;
      }

      reglFramebuffer(a0, a1);

      return extend(reglFramebuffer, {
        resize: resize,
        _reglType: 'framebuffer',
        _framebuffer: framebuffer,
        destroy: function () {
          destroy(framebuffer);
          decFBORefs(framebuffer);
        },
        use: function (block) {
          framebufferState.setFBO({
            framebuffer: reglFramebuffer
          }, block);
        }
      });
    }

    function createCubeFBO(options) {
      var faces = Array(6);

      function reglFramebufferCube(a) {
        var i;

        check$1(faces.indexOf(framebufferState.next) < 0, 'can not update framebuffer which is currently in use');

        var extDrawBuffers = extensions.webgl_draw_buffers;

        var params = {
          color: null
        };

        var radius = 0;

        var colorBuffer = null;
        var colorFormat = 'rgba';
        var colorType = 'uint8';
        var colorCount = 1;

        if (typeof a === 'number') {
          radius = a | 0;
        } else if (!a) {
          radius = 1;
        } else {
          check$1.type(a, 'object', 'invalid arguments for framebuffer');
          var options = a;

          if ('shape' in options) {
            var shape = options.shape;
            check$1(Array.isArray(shape) && shape.length >= 2, 'invalid shape for framebuffer');
            check$1(shape[0] === shape[1], 'cube framebuffer must be square');
            radius = shape[0];
          } else {
            if ('radius' in options) {
              radius = options.radius | 0;
            }
            if ('width' in options) {
              radius = options.width | 0;
              if ('height' in options) {
                check$1(options.height === radius, 'must be square');
              }
            } else if ('height' in options) {
              radius = options.height | 0;
            }
          }

          if ('color' in options || 'colors' in options) {
            colorBuffer = options.color || options.colors;
            if (Array.isArray(colorBuffer)) {
              check$1(colorBuffer.length === 1 || extDrawBuffers, 'multiple render targets not supported');
            }
          }

          if (!colorBuffer) {
            if ('colorCount' in options) {
              colorCount = options.colorCount | 0;
              check$1(colorCount > 0, 'invalid color buffer count');
            }

            if ('colorType' in options) {
              check$1.oneOf(options.colorType, colorTypes, 'invalid color type');
              colorType = options.colorType;
            }

            if ('colorFormat' in options) {
              colorFormat = options.colorFormat;
              check$1.oneOf(options.colorFormat, colorTextureFormats, 'invalid color format for texture');
            }
          }

          if ('depth' in options) {
            params.depth = options.depth;
          }

          if ('stencil' in options) {
            params.stencil = options.stencil;
          }

          if ('depthStencil' in options) {
            params.depthStencil = options.depthStencil;
          }
        }

        var colorCubes;
        if (colorBuffer) {
          if (Array.isArray(colorBuffer)) {
            colorCubes = [];
            for (i = 0; i < colorBuffer.length; ++i) {
              colorCubes[i] = colorBuffer[i];
            }
          } else {
            colorCubes = [colorBuffer];
          }
        } else {
          colorCubes = Array(colorCount);
          var cubeMapParams = {
            radius: radius,
            format: colorFormat,
            type: colorType
          };
          for (i = 0; i < colorCount; ++i) {
            colorCubes[i] = textureState.createCube(cubeMapParams);
          }
        }

        // Check color cubes
        params.color = Array(colorCubes.length);
        for (i = 0; i < colorCubes.length; ++i) {
          var cube = colorCubes[i];
          check$1(typeof cube === 'function' && cube._reglType === 'textureCube', 'invalid cube map');
          radius = radius || cube.width;
          check$1(cube.width === radius && cube.height === radius, 'invalid cube map shape');
          params.color[i] = {
            target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$1,
            data: colorCubes[i]
          };
        }

        for (i = 0; i < 6; ++i) {
          for (var j = 0; j < colorCubes.length; ++j) {
            params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i;
          }
          // reuse depth-stencil attachments across all cube maps
          if (i > 0) {
            params.depth = faces[0].depth;
            params.stencil = faces[0].stencil;
            params.depthStencil = faces[0].depthStencil;
          }
          if (faces[i]) {
            faces[i](params);
          } else {
            faces[i] = createFBO(params);
          }
        }

        return extend(reglFramebufferCube, {
          width: radius,
          height: radius,
          color: colorCubes
        });
      }

      function resize(radius_) {
        var i;
        var radius = radius_ | 0;
        check$1(radius > 0 && radius <= limits.maxCubeMapSize, 'invalid radius for cube fbo');

        if (radius === reglFramebufferCube.width) {
          return reglFramebufferCube;
        }

        var colors = reglFramebufferCube.color;
        for (i = 0; i < colors.length; ++i) {
          colors[i].resize(radius);
        }

        for (i = 0; i < 6; ++i) {
          faces[i].resize(radius);
        }

        reglFramebufferCube.width = reglFramebufferCube.height = radius;

        return reglFramebufferCube;
      }

      reglFramebufferCube(options);

      return extend(reglFramebufferCube, {
        faces: faces,
        resize: resize,
        _reglType: 'framebufferCube',
        destroy: function () {
          faces.forEach(function (f) {
            f.destroy();
          });
        }
      });
    }

    function restoreFramebuffers() {
      values(framebufferSet).forEach(function (fb) {
        fb.framebuffer = gl.createFramebuffer();
        updateFramebuffer(fb);
      });
    }

    return extend(framebufferState, {
      getFramebuffer: function (object) {
        if (typeof object === 'function' && object._reglType === 'framebuffer') {
          var fbo = object._framebuffer;
          if (fbo instanceof REGLFramebuffer) {
            return fbo;
          }
        }
        return null;
      },
      create: createFBO,
      createCube: createCubeFBO,
      clear: function () {
        values(framebufferSet).forEach(destroy);
      },
      restore: restoreFramebuffers
    });
  }

  var GL_FLOAT$5 = 5126;

  function AttributeRecord() {
    this.state = 0;

    this.x = 0.0;
    this.y = 0.0;
    this.z = 0.0;
    this.w = 0.0;

    this.buffer = null;
    this.size = 0;
    this.normalized = false;
    this.type = GL_FLOAT$5;
    this.offset = 0;
    this.stride = 0;
    this.divisor = 0;
  }

  function wrapAttributeState(gl, extensions, limits, bufferState, stringStore) {
    var NUM_ATTRIBUTES = limits.maxAttributes;
    var attributeBindings = new Array(NUM_ATTRIBUTES);
    for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
      attributeBindings[i] = new AttributeRecord();
    }

    return {
      Record: AttributeRecord,
      scope: {},
      state: attributeBindings
    };
  }

  var GL_FRAGMENT_SHADER = 35632;
  var GL_VERTEX_SHADER = 35633;

  var GL_ACTIVE_UNIFORMS = 0x8B86;
  var GL_ACTIVE_ATTRIBUTES = 0x8B89;

  function wrapShaderState(gl, stringStore, stats, config) {
    // ===================================================
    // glsl compilation and linking
    // ===================================================
    var fragShaders = {};
    var vertShaders = {};

    function ActiveInfo(name, id, location, info) {
      this.name = name;
      this.id = id;
      this.location = location;
      this.info = info;
    }

    function insertActiveInfo(list, info) {
      for (var i = 0; i < list.length; ++i) {
        if (list[i].id === info.id) {
          list[i].location = info.location;
          return;
        }
      }
      list.push(info);
    }

    function getShader(type, id, command) {
      var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders;
      var shader = cache[id];

      if (!shader) {
        var source = stringStore.str(id);
        shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        check$1.shaderError(gl, shader, source, type, command);
        cache[id] = shader;
      }

      return shader;
    }

    // ===================================================
    // program linking
    // ===================================================
    var programCache = {};
    var programList = [];

    var PROGRAM_COUNTER = 0;

    function REGLProgram(fragId, vertId) {
      this.id = PROGRAM_COUNTER++;
      this.fragId = fragId;
      this.vertId = vertId;
      this.program = null;
      this.uniforms = [];
      this.attributes = [];

      if (config.profile) {
        this.stats = {
          uniformsCount: 0,
          attributesCount: 0
        };
      }
    }

    function linkProgram(desc, command) {
      var i, info;

      // -------------------------------
      // compile & link
      // -------------------------------
      var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);
      var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);

      var program = desc.program = gl.createProgram();
      gl.attachShader(program, fragShader);
      gl.attachShader(program, vertShader);
      gl.linkProgram(program);
      check$1.linkError(gl, program, stringStore.str(desc.fragId), stringStore.str(desc.vertId), command);

      // -------------------------------
      // grab uniforms
      // -------------------------------
      var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS);
      if (config.profile) {
        desc.stats.uniformsCount = numUniforms;
      }
      var uniforms = desc.uniforms;
      for (i = 0; i < numUniforms; ++i) {
        info = gl.getActiveUniform(program, i);
        if (info) {
          if (info.size > 1) {
            for (var j = 0; j < info.size; ++j) {
              var name = info.name.replace('[0]', '[' + j + ']');
              insertActiveInfo(uniforms, new ActiveInfo(name, stringStore.id(name), gl.getUniformLocation(program, name), info));
            }
          } else {
            insertActiveInfo(uniforms, new ActiveInfo(info.name, stringStore.id(info.name), gl.getUniformLocation(program, info.name), info));
          }
        }
      }

      // -------------------------------
      // grab attributes
      // -------------------------------
      var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES);
      if (config.profile) {
        desc.stats.attributesCount = numAttributes;
      }

      var attributes = desc.attributes;
      for (i = 0; i < numAttributes; ++i) {
        info = gl.getActiveAttrib(program, i);
        if (info) {
          insertActiveInfo(attributes, new ActiveInfo(info.name, stringStore.id(info.name), gl.getAttribLocation(program, info.name), info));
        }
      }
    }

    if (config.profile) {
      stats.getMaxUniformsCount = function () {
        var m = 0;
        programList.forEach(function (desc) {
          if (desc.stats.uniformsCount > m) {
            m = desc.stats.uniformsCount;
          }
        });
        return m;
      };

      stats.getMaxAttributesCount = function () {
        var m = 0;
        programList.forEach(function (desc) {
          if (desc.stats.attributesCount > m) {
            m = desc.stats.attributesCount;
          }
        });
        return m;
      };
    }

    function restoreShaders() {
      fragShaders = {};
      vertShaders = {};
      for (var i = 0; i < programList.length; ++i) {
        linkProgram(programList[i]);
      }
    }

    return {
      clear: function () {
        var deleteShader = gl.deleteShader.bind(gl);
        values(fragShaders).forEach(deleteShader);
        fragShaders = {};
        values(vertShaders).forEach(deleteShader);
        vertShaders = {};

        programList.forEach(function (desc) {
          gl.deleteProgram(desc.program);
        });
        programList.length = 0;
        programCache = {};

        stats.shaderCount = 0;
      },

      program: function (vertId, fragId, command) {
        check$1.command(vertId >= 0, 'missing vertex shader', command);
        check$1.command(fragId >= 0, 'missing fragment shader', command);

        var cache = programCache[fragId];
        if (!cache) {
          cache = programCache[fragId] = {};
        }
        var program = cache[vertId];
        if (!program) {
          program = new REGLProgram(fragId, vertId);
          stats.shaderCount++;

          linkProgram(program, command);
          cache[vertId] = program;
          programList.push(program);
        }
        return program;
      },

      restore: restoreShaders,

      shader: getShader,

      frag: -1,
      vert: -1
    };
  }

  var GL_RGBA$2 = 6408;
  var GL_UNSIGNED_BYTE$6 = 5121;
  var GL_PACK_ALIGNMENT = 0x0D05;
  var GL_FLOAT$6 = 0x1406; // 5126

  function wrapReadPixels(gl, framebufferState, reglPoll, context, glAttributes, extensions) {
    function readPixelsImpl(input) {
      var type;
      if (framebufferState.next === null) {
        check$1(glAttributes.preserveDrawingBuffer, 'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer');
        type = GL_UNSIGNED_BYTE$6;
      } else {
        check$1(framebufferState.next.colorAttachments[0].texture !== null, 'You cannot read from a renderbuffer');
        type = framebufferState.next.colorAttachments[0].texture._texture.type;

        if (extensions.oes_texture_float) {
          check$1(type === GL_UNSIGNED_BYTE$6 || type === GL_FLOAT$6, 'Reading from a framebuffer is only allowed for the types \'uint8\' and \'float\'');
        } else {
          check$1(type === GL_UNSIGNED_BYTE$6, 'Reading from a framebuffer is only allowed for the type \'uint8\'');
        }
      }

      var x = 0;
      var y = 0;
      var width = context.framebufferWidth;
      var height = context.framebufferHeight;
      var data = null;

      if (isTypedArray(input)) {
        data = input;
      } else if (input) {
        check$1.type(input, 'object', 'invalid arguments to regl.read()');
        x = input.x | 0;
        y = input.y | 0;
        check$1(x >= 0 && x < context.framebufferWidth, 'invalid x offset for regl.read');
        check$1(y >= 0 && y < context.framebufferHeight, 'invalid y offset for regl.read');
        width = (input.width || context.framebufferWidth - x) | 0;
        height = (input.height || context.framebufferHeight - y) | 0;
        data = input.data || null;
      }

      // sanity check input.data
      if (data) {
        if (type === GL_UNSIGNED_BYTE$6) {
          check$1(data instanceof Uint8Array, 'buffer must be \'Uint8Array\' when reading from a framebuffer of type \'uint8\'');
        } else if (type === GL_FLOAT$6) {
          check$1(data instanceof Float32Array, 'buffer must be \'Float32Array\' when reading from a framebuffer of type \'float\'');
        }
      }

      check$1(width > 0 && width + x <= context.framebufferWidth, 'invalid width for read pixels');
      check$1(height > 0 && height + y <= context.framebufferHeight, 'invalid height for read pixels');

      // Update WebGL state
      reglPoll();

      // Compute size
      var size = width * height * 4;

      // Allocate data
      if (!data) {
        if (type === GL_UNSIGNED_BYTE$6) {
          data = new Uint8Array(size);
        } else if (type === GL_FLOAT$6) {
          data = data || new Float32Array(size);
        }
      }

      // Type check
      check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray');
      check$1(data.byteLength >= size, 'data buffer for regl.read() too small');

      // Run read pixels
      gl.pixelStorei(GL_PACK_ALIGNMENT, 4);
      gl.readPixels(x, y, width, height, GL_RGBA$2, type, data);

      return data;
    }

    function readPixelsFBO(options) {
      var result;
      framebufferState.setFBO({
        framebuffer: options.framebuffer
      }, function () {
        result = readPixelsImpl(options);
      });
      return result;
    }

    function readPixels(options) {
      if (!options || !('framebuffer' in options)) {
        return readPixelsImpl(options);
      } else {
        return readPixelsFBO(options);
      }
    }

    return readPixels;
  }

  function slice(x) {
    return Array.prototype.slice.call(x);
  }

  function join(x) {
    return slice(x).join('');
  }

  function createEnvironment() {
    // Unique variable id counter
    var varCounter = 0;

    // Linked values are passed from this scope into the generated code block
    // Calling link() passes a value into the generated scope and returns
    // the variable name which it is bound to
    var linkedNames = [];
    var linkedValues = [];
    function link(value) {
      for (var i = 0; i < linkedValues.length; ++i) {
        if (linkedValues[i] === value) {
          return linkedNames[i];
        }
      }

      var name = 'g' + varCounter++;
      linkedNames.push(name);
      linkedValues.push(value);
      return name;
    }

    // create a code block
    function block() {
      var code = [];
      function push() {
        code.push.apply(code, slice(arguments));
      }

      var vars = [];
      function def() {
        var name = 'v' + varCounter++;
        vars.push(name);

        if (arguments.length > 0) {
          code.push(name, '=');
          code.push.apply(code, slice(arguments));
          code.push(';');
        }

        return name;
      }

      return extend(push, {
        def: def,
        toString: function () {
          return join([vars.length > 0 ? 'var ' + vars + ';' : '', join(code)]);
        }
      });
    }

    function scope() {
      var entry = block();
      var exit = block();

      var entryToString = entry.toString;
      var exitToString = exit.toString;

      function save(object, prop) {
        exit(object, prop, '=', entry.def(object, prop), ';');
      }

      return extend(function () {
        entry.apply(entry, slice(arguments));
      }, {
        def: entry.def,
        entry: entry,
        exit: exit,
        save: save,
        set: function (object, prop, value) {
          save(object, prop);
          entry(object, prop, '=', value, ';');
        },
        toString: function () {
          return entryToString() + exitToString();
        }
      });
    }

    function conditional() {
      var pred = join(arguments);
      var thenBlock = scope();
      var elseBlock = scope();

      var thenToString = thenBlock.toString;
      var elseToString = elseBlock.toString;

      return extend(thenBlock, {
        then: function () {
          thenBlock.apply(thenBlock, slice(arguments));
          return this;
        },
        else: function () {
          elseBlock.apply(elseBlock, slice(arguments));
          return this;
        },
        toString: function () {
          var elseClause = elseToString();
          if (elseClause) {
            elseClause = 'else{' + elseClause + '}';
          }
          return join(['if(', pred, '){', thenToString(), '}', elseClause]);
        }
      });
    }

    // procedure list
    var globalBlock = block();
    var procedures = {};
    function proc(name, count) {
      var args = [];
      function arg() {
        var name = 'a' + args.length;
        args.push(name);
        return name;
      }

      count = count || 0;
      for (var i = 0; i < count; ++i) {
        arg();
      }

      var body = scope();
      var bodyToString = body.toString;

      var result = procedures[name] = extend(body, {
        arg: arg,
        toString: function () {
          return join(['function(', args.join(), '){', bodyToString(), '}']);
        }
      });

      return result;
    }

    function compile() {
      var code = ['"use strict";', globalBlock, 'return {'];
      Object.keys(procedures).forEach(function (name) {
        code.push('"', name, '":', procedures[name].toString(), ',');
      });
      code.push('}');
      var src = join(code).replace(/;/g, ';\n').replace(/}/g, '}\n').replace(/{/g, '{\n');
      var proc = Function.apply(null, linkedNames.concat(src));
      return proc.apply(null, linkedValues);
    }

    return {
      global: globalBlock,
      link: link,
      block: block,
      proc: proc,
      scope: scope,
      cond: conditional,
      compile: compile
    };
  }

  // "cute" names for vector components
  var CUTE_COMPONENTS = 'xyzw'.split('');

  var GL_UNSIGNED_BYTE$7 = 5121;

  var ATTRIB_STATE_POINTER = 1;
  var ATTRIB_STATE_CONSTANT = 2;

  var DYN_FUNC$1 = 0;
  var DYN_PROP$1 = 1;
  var DYN_CONTEXT$1 = 2;
  var DYN_STATE$1 = 3;
  var DYN_THUNK = 4;

  var S_DITHER = 'dither';
  var S_BLEND_ENABLE = 'blend.enable';
  var S_BLEND_COLOR = 'blend.color';
  var S_BLEND_EQUATION = 'blend.equation';
  var S_BLEND_FUNC = 'blend.func';
  var S_DEPTH_ENABLE = 'depth.enable';
  var S_DEPTH_FUNC = 'depth.func';
  var S_DEPTH_RANGE = 'depth.range';
  var S_DEPTH_MASK = 'depth.mask';
  var S_COLOR_MASK = 'colorMask';
  var S_CULL_ENABLE = 'cull.enable';
  var S_CULL_FACE = 'cull.face';
  var S_FRONT_FACE = 'frontFace';
  var S_LINE_WIDTH = 'lineWidth';
  var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable';
  var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset';
  var S_SAMPLE_ALPHA = 'sample.alpha';
  var S_SAMPLE_ENABLE = 'sample.enable';
  var S_SAMPLE_COVERAGE = 'sample.coverage';
  var S_STENCIL_ENABLE = 'stencil.enable';
  var S_STENCIL_MASK = 'stencil.mask';
  var S_STENCIL_FUNC = 'stencil.func';
  var S_STENCIL_OPFRONT = 'stencil.opFront';
  var S_STENCIL_OPBACK = 'stencil.opBack';
  var S_SCISSOR_ENABLE = 'scissor.enable';
  var S_SCISSOR_BOX = 'scissor.box';
  var S_VIEWPORT = 'viewport';

  var S_PROFILE = 'profile';

  var S_FRAMEBUFFER = 'framebuffer';
  var S_VERT = 'vert';
  var S_FRAG = 'frag';
  var S_ELEMENTS = 'elements';
  var S_PRIMITIVE = 'primitive';
  var S_COUNT = 'count';
  var S_OFFSET = 'offset';
  var S_INSTANCES = 'instances';

  var SUFFIX_WIDTH = 'Width';
  var SUFFIX_HEIGHT = 'Height';

  var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH;
  var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT;
  var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH;
  var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT;
  var S_DRAWINGBUFFER = 'drawingBuffer';
  var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH;
  var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT;

  var NESTED_OPTIONS = [S_BLEND_FUNC, S_BLEND_EQUATION, S_STENCIL_FUNC, S_STENCIL_OPFRONT, S_STENCIL_OPBACK, S_SAMPLE_COVERAGE, S_VIEWPORT, S_SCISSOR_BOX, S_POLYGON_OFFSET_OFFSET];

  var GL_ARRAY_BUFFER$1 = 34962;
  var GL_ELEMENT_ARRAY_BUFFER$1 = 34963;

  var GL_FRAGMENT_SHADER$1 = 35632;
  var GL_VERTEX_SHADER$1 = 35633;

  var GL_TEXTURE_2D$2 = 0x0DE1;
  var GL_TEXTURE_CUBE_MAP$1 = 0x8513;

  var GL_CULL_FACE = 0x0B44;
  var GL_BLEND = 0x0BE2;
  var GL_DITHER = 0x0BD0;
  var GL_STENCIL_TEST = 0x0B90;
  var GL_DEPTH_TEST = 0x0B71;
  var GL_SCISSOR_TEST = 0x0C11;
  var GL_POLYGON_OFFSET_FILL = 0x8037;
  var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
  var GL_SAMPLE_COVERAGE = 0x80A0;

  var GL_FLOAT$7 = 5126;
  var GL_FLOAT_VEC2 = 35664;
  var GL_FLOAT_VEC3 = 35665;
  var GL_FLOAT_VEC4 = 35666;
  var GL_INT$3 = 5124;
  var GL_INT_VEC2 = 35667;
  var GL_INT_VEC3 = 35668;
  var GL_INT_VEC4 = 35669;
  var GL_BOOL = 35670;
  var GL_BOOL_VEC2 = 35671;
  var GL_BOOL_VEC3 = 35672;
  var GL_BOOL_VEC4 = 35673;
  var GL_FLOAT_MAT2 = 35674;
  var GL_FLOAT_MAT3 = 35675;
  var GL_FLOAT_MAT4 = 35676;
  var GL_SAMPLER_2D = 35678;
  var GL_SAMPLER_CUBE = 35680;

  var GL_TRIANGLES$1 = 4;

  var GL_FRONT = 1028;
  var GL_BACK = 1029;
  var GL_CW = 0x0900;
  var GL_CCW = 0x0901;
  var GL_MIN_EXT = 0x8007;
  var GL_MAX_EXT = 0x8008;
  var GL_ALWAYS = 519;
  var GL_KEEP = 7680;
  var GL_ZERO = 0;
  var GL_ONE = 1;
  var GL_FUNC_ADD = 0x8006;
  var GL_LESS = 513;

  var GL_FRAMEBUFFER$1 = 0x8D40;
  var GL_COLOR_ATTACHMENT0$1 = 0x8CE0;

  var blendFuncs = {
    '0': 0,
    '1': 1,
    'zero': 0,
    'one': 1,
    'src color': 768,
    'one minus src color': 769,
    'src alpha': 770,
    'one minus src alpha': 771,
    'dst color': 774,
    'one minus dst color': 775,
    'dst alpha': 772,
    'one minus dst alpha': 773,
    'constant color': 32769,
    'one minus constant color': 32770,
    'constant alpha': 32771,
    'one minus constant alpha': 32772,
    'src alpha saturate': 776
  };

  // There are invalid values for srcRGB and dstRGB. See:
  // https://www.khronos.org/registry/webgl/specs/1.0/#6.13
  // https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56
  var invalidBlendCombinations = ['constant color, constant alpha', 'one minus constant color, constant alpha', 'constant color, one minus constant alpha', 'one minus constant color, one minus constant alpha', 'constant alpha, constant color', 'constant alpha, one minus constant color', 'one minus constant alpha, constant color', 'one minus constant alpha, one minus constant color'];

  var compareFuncs = {
    'never': 512,
    'less': 513,
    '<': 513,
    'equal': 514,
    '=': 514,
    '==': 514,
    '===': 514,
    'lequal': 515,
    '<=': 515,
    'greater': 516,
    '>': 516,
    'notequal': 517,
    '!=': 517,
    '!==': 517,
    'gequal': 518,
    '>=': 518,
    'always': 519
  };

  var stencilOps = {
    '0': 0,
    'zero': 0,
    'keep': 7680,
    'replace': 7681,
    'increment': 7682,
    'decrement': 7683,
    'increment wrap': 34055,
    'decrement wrap': 34056,
    'invert': 5386
  };

  var shaderType = {
    'frag': GL_FRAGMENT_SHADER$1,
    'vert': GL_VERTEX_SHADER$1
  };

  var orientationType = {
    'cw': GL_CW,
    'ccw': GL_CCW
  };

  function isBufferArgs(x) {
    return Array.isArray(x) || isTypedArray(x) || isNDArrayLike(x);
  }

  // Make sure viewport is processed first
  function sortState(state) {
    return state.sort(function (a, b) {
      if (a === S_VIEWPORT) {
        return -1;
      } else if (b === S_VIEWPORT) {
        return 1;
      }
      return a < b ? -1 : 1;
    });
  }

  function Declaration(thisDep, contextDep, propDep, append) {
    this.thisDep = thisDep;
    this.contextDep = contextDep;
    this.propDep = propDep;
    this.append = append;
  }

  function isStatic(decl) {
    return decl && !(decl.thisDep || decl.contextDep || decl.propDep);
  }

  function createStaticDecl(append) {
    return new Declaration(false, false, false, append);
  }

  function createDynamicDecl(dyn, append) {
    var type = dyn.type;
    if (type === DYN_FUNC$1) {
      var numArgs = dyn.data.length;
      return new Declaration(true, numArgs >= 1, numArgs >= 2, append);
    } else if (type === DYN_THUNK) {
      var data = dyn.data;
      return new Declaration(data.thisDep, data.contextDep, data.propDep, append);
    } else {
      return new Declaration(type === DYN_STATE$1, type === DYN_CONTEXT$1, type === DYN_PROP$1, append);
    }
  }

  var SCOPE_DECL = new Declaration(false, false, false, function () {});

  function reglCore(gl, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer, config) {
    var AttributeRecord = attributeState.Record;

    var blendEquations = {
      'add': 32774,
      'subtract': 32778,
      'reverse subtract': 32779
    };
    if (extensions.ext_blend_minmax) {
      blendEquations.min = GL_MIN_EXT;
      blendEquations.max = GL_MAX_EXT;
    }

    var extInstancing = extensions.angle_instanced_arrays;
    var extDrawBuffers = extensions.webgl_draw_buffers;

    // ===================================================
    // ===================================================
    // WEBGL STATE
    // ===================================================
    // ===================================================
    var currentState = {
      dirty: true,
      profile: config.profile
    };
    var nextState = {};
    var GL_STATE_NAMES = [];
    var GL_FLAGS = {};
    var GL_VARIABLES = {};

    function propName(name) {
      return name.replace('.', '_');
    }

    function stateFlag(sname, cap, init) {
      var name = propName(sname);
      GL_STATE_NAMES.push(sname);
      nextState[name] = currentState[name] = !!init;
      GL_FLAGS[name] = cap;
    }

    function stateVariable(sname, func, init) {
      var name = propName(sname);
      GL_STATE_NAMES.push(sname);
      if (Array.isArray(init)) {
        currentState[name] = init.slice();
        nextState[name] = init.slice();
      } else {
        currentState[name] = nextState[name] = init;
      }
      GL_VARIABLES[name] = func;
    }

    // Dithering
    stateFlag(S_DITHER, GL_DITHER);

    // Blending
    stateFlag(S_BLEND_ENABLE, GL_BLEND);
    stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0]);
    stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate', [GL_FUNC_ADD, GL_FUNC_ADD]);
    stateVariable(S_BLEND_FUNC, 'blendFuncSeparate', [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO]);

    // Depth
    stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true);
    stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS);
    stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1]);
    stateVariable(S_DEPTH_MASK, 'depthMask', true);

    // Color mask
    stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true]);

    // Face culling
    stateFlag(S_CULL_ENABLE, GL_CULL_FACE);
    stateVariable(S_CULL_FACE, 'cullFace', GL_BACK);

    // Front face orientation
    stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW);

    // Line width
    stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1);

    // Polygon offset
    stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL);
    stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0]);

    // Sample coverage
    stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE);
    stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE);
    stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false]);

    // Stencil
    stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST);
    stateVariable(S_STENCIL_MASK, 'stencilMask', -1);
    stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1]);
    stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate', [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP]);
    stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate', [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP]);

    // Scissor
    stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST);
    stateVariable(S_SCISSOR_BOX, 'scissor', [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]);

    // Viewport
    stateVariable(S_VIEWPORT, S_VIEWPORT, [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]);

    // ===================================================
    // ===================================================
    // ENVIRONMENT
    // ===================================================
    // ===================================================
    var sharedState = {
      gl: gl,
      context: contextState,
      strings: stringStore,
      next: nextState,
      current: currentState,
      draw: drawState,
      elements: elementState,
      buffer: bufferState,
      shader: shaderState,
      attributes: attributeState.state,
      uniforms: uniformState,
      framebuffer: framebufferState,
      extensions: extensions,

      timer: timer,
      isBufferArgs: isBufferArgs
    };

    var sharedConstants = {
      primTypes: primTypes,
      compareFuncs: compareFuncs,
      blendFuncs: blendFuncs,
      blendEquations: blendEquations,
      stencilOps: stencilOps,
      glTypes: glTypes,
      orientationType: orientationType
    };

    check$1.optional(function () {
      sharedState.isArrayLike = isArrayLike;
    });

    if (extDrawBuffers) {
      sharedConstants.backBuffer = [GL_BACK];
      sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
        if (i === 0) {
          return [0];
        }
        return loop(i, function (j) {
          return GL_COLOR_ATTACHMENT0$1 + j;
        });
      });
    }

    var drawCallCounter = 0;
    function createREGLEnvironment() {
      var env = createEnvironment();
      var link = env.link;
      var global = env.global;
      env.id = drawCallCounter++;

      env.batchId = '0';

      // link shared state
      var SHARED = link(sharedState);
      var shared = env.shared = {
        props: 'a0'
      };
      Object.keys(sharedState).forEach(function (prop) {
        shared[prop] = global.def(SHARED, '.', prop);
      });

      // Inject runtime assertion stuff for debug builds
      check$1.optional(function () {
        env.CHECK = link(check$1);
        env.commandStr = check$1.guessCommand();
        env.command = link(env.commandStr);
        env.assert = function (block, pred, message) {
          block('if(!(', pred, '))', this.CHECK, '.commandRaise(', link(message), ',', this.command, ');');
        };

        sharedConstants.invalidBlendCombinations = invalidBlendCombinations;
      });

      // Copy GL state variables over
      var nextVars = env.next = {};
      var currentVars = env.current = {};
      Object.keys(GL_VARIABLES).forEach(function (variable) {
        if (Array.isArray(currentState[variable])) {
          nextVars[variable] = global.def(shared.next, '.', variable);
          currentVars[variable] = global.def(shared.current, '.', variable);
        }
      });

      // Initialize shared constants
      var constants = env.constants = {};
      Object.keys(sharedConstants).forEach(function (name) {
        constants[name] = global.def(JSON.stringify(sharedConstants[name]));
      });

      // Helper function for calling a block
      env.invoke = function (block, x) {
        switch (x.type) {
          case DYN_FUNC$1:
            var argList = ['this', shared.context, shared.props, env.batchId];
            return block.def(link(x.data), '.call(', argList.slice(0, Math.max(x.data.length + 1, 4)), ')');
          case DYN_PROP$1:
            return block.def(shared.props, x.data);
          case DYN_CONTEXT$1:
            return block.def(shared.context, x.data);
          case DYN_STATE$1:
            return block.def('this', x.data);
          case DYN_THUNK:
            x.data.append(env, block);
            return x.data.ref;
        }
      };

      env.attribCache = {};

      var scopeAttribs = {};
      env.scopeAttrib = function (name) {
        var id = stringStore.id(name);
        if (id in scopeAttribs) {
          return scopeAttribs[id];
        }
        var binding = attributeState.scope[id];
        if (!binding) {
          binding = attributeState.scope[id] = new AttributeRecord();
        }
        var result = scopeAttribs[id] = link(binding);
        return result;
      };

      return env;
    }

    // ===================================================
    // ===================================================
    // PARSING
    // ===================================================
    // ===================================================
    function parseProfile(options) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      var profileEnable;
      if (S_PROFILE in staticOptions) {
        var value = !!staticOptions[S_PROFILE];
        profileEnable = createStaticDecl(function (env, scope) {
          return value;
        });
        profileEnable.enable = value;
      } else if (S_PROFILE in dynamicOptions) {
        var dyn = dynamicOptions[S_PROFILE];
        profileEnable = createDynamicDecl(dyn, function (env, scope) {
          return env.invoke(scope, dyn);
        });
      }

      return profileEnable;
    }

    function parseFramebuffer(options, env) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      if (S_FRAMEBUFFER in staticOptions) {
        var framebuffer = staticOptions[S_FRAMEBUFFER];
        if (framebuffer) {
          framebuffer = framebufferState.getFramebuffer(framebuffer);
          check$1.command(framebuffer, 'invalid framebuffer object');
          return createStaticDecl(function (env, block) {
            var FRAMEBUFFER = env.link(framebuffer);
            var shared = env.shared;
            block.set(shared.framebuffer, '.next', FRAMEBUFFER);
            var CONTEXT = shared.context;
            block.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, FRAMEBUFFER + '.width');
            block.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, FRAMEBUFFER + '.height');
            return FRAMEBUFFER;
          });
        } else {
          return createStaticDecl(function (env, scope) {
            var shared = env.shared;
            scope.set(shared.framebuffer, '.next', 'null');
            var CONTEXT = shared.context;
            scope.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);
            scope.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);
            return 'null';
          });
        }
      } else if (S_FRAMEBUFFER in dynamicOptions) {
        var dyn = dynamicOptions[S_FRAMEBUFFER];
        return createDynamicDecl(dyn, function (env, scope) {
          var FRAMEBUFFER_FUNC = env.invoke(scope, dyn);
          var shared = env.shared;
          var FRAMEBUFFER_STATE = shared.framebuffer;
          var FRAMEBUFFER = scope.def(FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')');

          check$1.optional(function () {
            env.assert(scope, '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER, 'invalid framebuffer object');
          });

          scope.set(FRAMEBUFFER_STATE, '.next', FRAMEBUFFER);
          var CONTEXT = shared.context;
          scope.set(CONTEXT, '.' + S_FRAMEBUFFER_WIDTH, FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' + CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);
          scope.set(CONTEXT, '.' + S_FRAMEBUFFER_HEIGHT, FRAMEBUFFER + '?' + FRAMEBUFFER + '.height:' + CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);
          return FRAMEBUFFER;
        });
      } else {
        return null;
      }
    }

    function parseViewportScissor(options, framebuffer, env) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      function parseBox(param) {
        if (param in staticOptions) {
          var box = staticOptions[param];
          check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr);

          var isStatic = true;
          var x = box.x | 0;
          var y = box.y | 0;
          var w, h;
          if ('width' in box) {
            w = box.width | 0;
            check$1.command(w >= 0, 'invalid ' + param, env.commandStr);
          } else {
            isStatic = false;
          }
          if ('height' in box) {
            h = box.height | 0;
            check$1.command(h >= 0, 'invalid ' + param, env.commandStr);
          } else {
            isStatic = false;
          }

          return new Declaration(!isStatic && framebuffer && framebuffer.thisDep, !isStatic && framebuffer && framebuffer.contextDep, !isStatic && framebuffer && framebuffer.propDep, function (env, scope) {
            var CONTEXT = env.shared.context;
            var BOX_W = w;
            if (!('width' in box)) {
              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x);
            }
            var BOX_H = h;
            if (!('height' in box)) {
              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y);
            }
            return [x, y, BOX_W, BOX_H];
          });
        } else if (param in dynamicOptions) {
          var dynBox = dynamicOptions[param];
          var result = createDynamicDecl(dynBox, function (env, scope) {
            var BOX = env.invoke(scope, dynBox);

            check$1.optional(function () {
              env.assert(scope, BOX + '&&typeof ' + BOX + '==="object"', 'invalid ' + param);
            });

            var CONTEXT = env.shared.context;
            var BOX_X = scope.def(BOX, '.x|0');
            var BOX_Y = scope.def(BOX, '.y|0');
            var BOX_W = scope.def('"width" in ', BOX, '?', BOX, '.width|0:', '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')');
            var BOX_H = scope.def('"height" in ', BOX, '?', BOX, '.height|0:', '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')');

            check$1.optional(function () {
              env.assert(scope, BOX_W + '>=0&&' + BOX_H + '>=0', 'invalid ' + param);
            });

            return [BOX_X, BOX_Y, BOX_W, BOX_H];
          });
          if (framebuffer) {
            result.thisDep = result.thisDep || framebuffer.thisDep;
            result.contextDep = result.contextDep || framebuffer.contextDep;
            result.propDep = result.propDep || framebuffer.propDep;
          }
          return result;
        } else if (framebuffer) {
          return new Declaration(framebuffer.thisDep, framebuffer.contextDep, framebuffer.propDep, function (env, scope) {
            var CONTEXT = env.shared.context;
            return [0, 0, scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH), scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)];
          });
        } else {
          return null;
        }
      }

      var viewport = parseBox(S_VIEWPORT);

      if (viewport) {
        var prevViewport = viewport;
        viewport = new Declaration(viewport.thisDep, viewport.contextDep, viewport.propDep, function (env, scope) {
          var VIEWPORT = prevViewport.append(env, scope);
          var CONTEXT = env.shared.context;
          scope.set(CONTEXT, '.' + S_VIEWPORT_WIDTH, VIEWPORT[2]);
          scope.set(CONTEXT, '.' + S_VIEWPORT_HEIGHT, VIEWPORT[3]);
          return VIEWPORT;
        });
      }

      return {
        viewport: viewport,
        scissor_box: parseBox(S_SCISSOR_BOX)
      };
    }

    function parseProgram(options) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      function parseShader(name) {
        if (name in staticOptions) {
          var id = stringStore.id(staticOptions[name]);
          check$1.optional(function () {
            shaderState.shader(shaderType[name], id, check$1.guessCommand());
          });
          var result = createStaticDecl(function () {
            return id;
          });
          result.id = id;
          return result;
        } else if (name in dynamicOptions) {
          var dyn = dynamicOptions[name];
          return createDynamicDecl(dyn, function (env, scope) {
            var str = env.invoke(scope, dyn);
            var id = scope.def(env.shared.strings, '.id(', str, ')');
            check$1.optional(function () {
              scope(env.shared.shader, '.shader(', shaderType[name], ',', id, ',', env.command, ');');
            });
            return id;
          });
        }
        return null;
      }

      var frag = parseShader(S_FRAG);
      var vert = parseShader(S_VERT);

      var program = null;
      var progVar;
      if (isStatic(frag) && isStatic(vert)) {
        program = shaderState.program(vert.id, frag.id);
        progVar = createStaticDecl(function (env, scope) {
          return env.link(program);
        });
      } else {
        progVar = new Declaration(frag && frag.thisDep || vert && vert.thisDep, frag && frag.contextDep || vert && vert.contextDep, frag && frag.propDep || vert && vert.propDep, function (env, scope) {
          var SHADER_STATE = env.shared.shader;
          var fragId;
          if (frag) {
            fragId = frag.append(env, scope);
          } else {
            fragId = scope.def(SHADER_STATE, '.', S_FRAG);
          }
          var vertId;
          if (vert) {
            vertId = vert.append(env, scope);
          } else {
            vertId = scope.def(SHADER_STATE, '.', S_VERT);
          }
          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId;
          check$1.optional(function () {
            progDef += ',' + env.command;
          });
          return scope.def(progDef + ')');
        });
      }

      return {
        frag: frag,
        vert: vert,
        progVar: progVar,
        program: program
      };
    }

    function parseDraw(options, env) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      function parseElements() {
        if (S_ELEMENTS in staticOptions) {
          var elements = staticOptions[S_ELEMENTS];
          if (isBufferArgs(elements)) {
            elements = elementState.getElements(elementState.create(elements, true));
          } else if (elements) {
            elements = elementState.getElements(elements);
            check$1.command(elements, 'invalid elements', env.commandStr);
          }
          var result = createStaticDecl(function (env, scope) {
            if (elements) {
              var result = env.link(elements);
              env.ELEMENTS = result;
              return result;
            }
            env.ELEMENTS = null;
            return null;
          });
          result.value = elements;
          return result;
        } else if (S_ELEMENTS in dynamicOptions) {
          var dyn = dynamicOptions[S_ELEMENTS];
          return createDynamicDecl(dyn, function (env, scope) {
            var shared = env.shared;

            var IS_BUFFER_ARGS = shared.isBufferArgs;
            var ELEMENT_STATE = shared.elements;

            var elementDefn = env.invoke(scope, dyn);
            var elements = scope.def('null');
            var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')');

            var ifte = env.cond(elementStream).then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');').else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');');

            check$1.optional(function () {
              env.assert(ifte.else, '!' + elementDefn + '||' + elements, 'invalid elements');
            });

            scope.entry(ifte);
            scope.exit(env.cond(elementStream).then(ELEMENT_STATE, '.destroyStream(', elements, ');'));

            env.ELEMENTS = elements;

            return elements;
          });
        }

        return null;
      }

      var elements = parseElements();

      function parsePrimitive() {
        if (S_PRIMITIVE in staticOptions) {
          var primitive = staticOptions[S_PRIMITIVE];
          check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr);
          return createStaticDecl(function (env, scope) {
            return primTypes[primitive];
          });
        } else if (S_PRIMITIVE in dynamicOptions) {
          var dynPrimitive = dynamicOptions[S_PRIMITIVE];
          return createDynamicDecl(dynPrimitive, function (env, scope) {
            var PRIM_TYPES = env.constants.primTypes;
            var prim = env.invoke(scope, dynPrimitive);
            check$1.optional(function () {
              env.assert(scope, prim + ' in ' + PRIM_TYPES, 'invalid primitive, must be one of ' + Object.keys(primTypes));
            });
            return scope.def(PRIM_TYPES, '[', prim, ']');
          });
        } else if (elements) {
          if (isStatic(elements)) {
            if (elements.value) {
              return createStaticDecl(function (env, scope) {
                return scope.def(env.ELEMENTS, '.primType');
              });
            } else {
              return createStaticDecl(function () {
                return GL_TRIANGLES$1;
              });
            }
          } else {
            return new Declaration(elements.thisDep, elements.contextDep, elements.propDep, function (env, scope) {
              var elements = env.ELEMENTS;
              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1);
            });
          }
        }
        return null;
      }

      function parseParam(param, isOffset) {
        if (param in staticOptions) {
          var value = staticOptions[param] | 0;
          check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr);
          return createStaticDecl(function (env, scope) {
            if (isOffset) {
              env.OFFSET = value;
            }
            return value;
          });
        } else if (param in dynamicOptions) {
          var dynValue = dynamicOptions[param];
          return createDynamicDecl(dynValue, function (env, scope) {
            var result = env.invoke(scope, dynValue);
            if (isOffset) {
              env.OFFSET = result;
              check$1.optional(function () {
                env.assert(scope, result + '>=0', 'invalid ' + param);
              });
            }
            return result;
          });
        } else if (isOffset && elements) {
          return createStaticDecl(function (env, scope) {
            env.OFFSET = '0';
            return 0;
          });
        }
        return null;
      }

      var OFFSET = parseParam(S_OFFSET, true);

      function parseVertCount() {
        if (S_COUNT in staticOptions) {
          var count = staticOptions[S_COUNT] | 0;
          check$1.command(typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr);
          return createStaticDecl(function () {
            return count;
          });
        } else if (S_COUNT in dynamicOptions) {
          var dynCount = dynamicOptions[S_COUNT];
          return createDynamicDecl(dynCount, function (env, scope) {
            var result = env.invoke(scope, dynCount);
            check$1.optional(function () {
              env.assert(scope, 'typeof ' + result + '==="number"&&' + result + '>=0&&' + result + '===(' + result + '|0)', 'invalid vertex count');
            });
            return result;
          });
        } else if (elements) {
          if (isStatic(elements)) {
            if (elements) {
              if (OFFSET) {
                return new Declaration(OFFSET.thisDep, OFFSET.contextDep, OFFSET.propDep, function (env, scope) {
                  var result = scope.def(env.ELEMENTS, '.vertCount-', env.OFFSET);

                  check$1.optional(function () {
                    env.assert(scope, result + '>=0', 'invalid vertex offset/element buffer too small');
                  });

                  return result;
                });
              } else {
                return createStaticDecl(function (env, scope) {
                  return scope.def(env.ELEMENTS, '.vertCount');
                });
              }
            } else {
              var result = createStaticDecl(function () {
                return -1;
              });
              check$1.optional(function () {
                result.MISSING = true;
              });
              return result;
            }
          } else {
            var variable = new Declaration(elements.thisDep || OFFSET.thisDep, elements.contextDep || OFFSET.contextDep, elements.propDep || OFFSET.propDep, function (env, scope) {
              var elements = env.ELEMENTS;
              if (env.OFFSET) {
                return scope.def(elements, '?', elements, '.vertCount-', env.OFFSET, ':-1');
              }
              return scope.def(elements, '?', elements, '.vertCount:-1');
            });
            check$1.optional(function () {
              variable.DYNAMIC = true;
            });
            return variable;
          }
        }
        return null;
      }

      return {
        elements: elements,
        primitive: parsePrimitive(),
        count: parseVertCount(),
        instances: parseParam(S_INSTANCES, false),
        offset: OFFSET
      };
    }

    function parseGLState(options, env) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      var STATE = {};

      GL_STATE_NAMES.forEach(function (prop) {
        var param = propName(prop);

        function parseParam(parseStatic, parseDynamic) {
          if (prop in staticOptions) {
            var value = parseStatic(staticOptions[prop]);
            STATE[param] = createStaticDecl(function () {
              return value;
            });
          } else if (prop in dynamicOptions) {
            var dyn = dynamicOptions[prop];
            STATE[param] = createDynamicDecl(dyn, function (env, scope) {
              return parseDynamic(env, scope, env.invoke(scope, dyn));
            });
          }
        }

        switch (prop) {
          case S_CULL_ENABLE:
          case S_BLEND_ENABLE:
          case S_DITHER:
          case S_STENCIL_ENABLE:
          case S_DEPTH_ENABLE:
          case S_SCISSOR_ENABLE:
          case S_POLYGON_OFFSET_ENABLE:
          case S_SAMPLE_ALPHA:
          case S_SAMPLE_ENABLE:
          case S_DEPTH_MASK:
            return parseParam(function (value) {
              check$1.commandType(value, 'boolean', prop, env.commandStr);
              return value;
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, 'typeof ' + value + '==="boolean"', 'invalid flag ' + prop, env.commandStr);
              });
              return value;
            });

          case S_DEPTH_FUNC:
            return parseParam(function (value) {
              check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr);
              return compareFuncs[value];
            }, function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs;
              check$1.optional(function () {
                env.assert(scope, value + ' in ' + COMPARE_FUNCS, 'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs));
              });
              return scope.def(COMPARE_FUNCS, '[', value, ']');
            });

          case S_DEPTH_RANGE:
            return parseParam(function (value) {
              check$1.command(isArrayLike(value) && value.length === 2 && typeof value[0] === 'number' && typeof value[1] === 'number' && value[0] <= value[1], 'depth range is 2d array', env.commandStr);
              return value;
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, env.shared.isArrayLike + '(' + value + ')&&' + value + '.length===2&&' + 'typeof ' + value + '[0]==="number"&&' + 'typeof ' + value + '[1]==="number"&&' + value + '[0]<=' + value + '[1]', 'depth range must be a 2d array');
              });

              var Z_NEAR = scope.def('+', value, '[0]');
              var Z_FAR = scope.def('+', value, '[1]');
              return [Z_NEAR, Z_FAR];
            });

          case S_BLEND_FUNC:
            return parseParam(function (value) {
              check$1.commandType(value, 'object', 'blend.func', env.commandStr);
              var srcRGB = 'srcRGB' in value ? value.srcRGB : value.src;
              var srcAlpha = 'srcAlpha' in value ? value.srcAlpha : value.src;
              var dstRGB = 'dstRGB' in value ? value.dstRGB : value.dst;
              var dstAlpha = 'dstAlpha' in value ? value.dstAlpha : value.dst;
              check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr);
              check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr);
              check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr);
              check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr);

              check$1.command(invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1, 'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr);

              return [blendFuncs[srcRGB], blendFuncs[dstRGB], blendFuncs[srcAlpha], blendFuncs[dstAlpha]];
            }, function (env, scope, value) {
              var BLEND_FUNCS = env.constants.blendFuncs;

              check$1.optional(function () {
                env.assert(scope, value + '&&typeof ' + value + '==="object"', 'invalid blend func, must be an object');
              });

              function read(prefix, suffix) {
                var func = scope.def('"', prefix, suffix, '" in ', value, '?', value, '.', prefix, suffix, ':', value, '.', prefix);

                check$1.optional(function () {
                  env.assert(scope, func + ' in ' + BLEND_FUNCS, 'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs));
                });

                return func;
              }

              var srcRGB = read('src', 'RGB');
              var dstRGB = read('dst', 'RGB');

              check$1.optional(function () {
                var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations;

                env.assert(scope, INVALID_BLEND_COMBINATIONS + '.indexOf(' + srcRGB + '+", "+' + dstRGB + ') === -1 ', 'unallowed blending combination for (srcRGB, dstRGB)');
              });

              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']');
              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']');
              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']');
              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']');

              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA];
            });

          case S_BLEND_EQUATION:
            return parseParam(function (value) {
              if (typeof value === 'string') {
                check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr);
                return [blendEquations[value], blendEquations[value]];
              } else if (typeof value === 'object') {
                check$1.commandParameter(value.rgb, blendEquations, prop + '.rgb', env.commandStr);
                check$1.commandParameter(value.alpha, blendEquations, prop + '.alpha', env.commandStr);
                return [blendEquations[value.rgb], blendEquations[value.alpha]];
              } else {
                check$1.commandRaise('invalid blend.equation', env.commandStr);
              }
            }, function (env, scope, value) {
              var BLEND_EQUATIONS = env.constants.blendEquations;

              var RGB = scope.def();
              var ALPHA = scope.def();

              var ifte = env.cond('typeof ', value, '==="string"');

              check$1.optional(function () {
                function checkProp(block, name, value) {
                  env.assert(block, value + ' in ' + BLEND_EQUATIONS, 'invalid ' + name + ', must be one of ' + Object.keys(blendEquations));
                }
                checkProp(ifte.then, prop, value);

                env.assert(ifte.else, value + '&&typeof ' + value + '==="object"', 'invalid ' + prop);
                checkProp(ifte.else, prop + '.rgb', value + '.rgb');
                checkProp(ifte.else, prop + '.alpha', value + '.alpha');
              });

              ifte.then(RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];');
              ifte.else(RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];', ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];');

              scope(ifte);

              return [RGB, ALPHA];
            });

          case S_BLEND_COLOR:
            return parseParam(function (value) {
              check$1.command(isArrayLike(value) && value.length === 4, 'blend.color must be a 4d array', env.commandStr);
              return loop(4, function (i) {
                return +value[i];
              });
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, env.shared.isArrayLike + '(' + value + ')&&' + value + '.length===4', 'blend.color must be a 4d array');
              });
              return loop(4, function (i) {
                return scope.def('+', value, '[', i, ']');
              });
            });

          case S_STENCIL_MASK:
            return parseParam(function (value) {
              check$1.commandType(value, 'number', param, env.commandStr);
              return value | 0;
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, 'typeof ' + value + '==="number"', 'invalid stencil.mask');
              });
              return scope.def(value, '|0');
            });

          case S_STENCIL_FUNC:
            return parseParam(function (value) {
              check$1.commandType(value, 'object', param, env.commandStr);
              var cmp = value.cmp || 'keep';
              var ref = value.ref || 0;
              var mask = 'mask' in value ? value.mask : -1;
              check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr);
              check$1.commandType(ref, 'number', prop + '.ref', env.commandStr);
              check$1.commandType(mask, 'number', prop + '.mask', env.commandStr);
              return [compareFuncs[cmp], ref, mask];
            }, function (env, scope, value) {
              var COMPARE_FUNCS = env.constants.compareFuncs;
              check$1.optional(function () {
                function assert() {
                  env.assert(scope, Array.prototype.join.call(arguments, ''), 'invalid stencil.func');
                }
                assert(value + '&&typeof ', value, '==="object"');
                assert('!("cmp" in ', value, ')||(', value, '.cmp in ', COMPARE_FUNCS, ')');
              });
              var cmp = scope.def('"cmp" in ', value, '?', COMPARE_FUNCS, '[', value, '.cmp]', ':', GL_KEEP);
              var ref = scope.def(value, '.ref|0');
              var mask = scope.def('"mask" in ', value, '?', value, '.mask|0:-1');
              return [cmp, ref, mask];
            });

          case S_STENCIL_OPFRONT:
          case S_STENCIL_OPBACK:
            return parseParam(function (value) {
              check$1.commandType(value, 'object', param, env.commandStr);
              var fail = value.fail || 'keep';
              var zfail = value.zfail || 'keep';
              var zpass = value.zpass || 'keep';
              check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr);
              check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr);
              check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr);
              return [prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT, stencilOps[fail], stencilOps[zfail], stencilOps[zpass]];
            }, function (env, scope, value) {
              var STENCIL_OPS = env.constants.stencilOps;

              check$1.optional(function () {
                env.assert(scope, value + '&&typeof ' + value + '==="object"', 'invalid ' + prop);
              });

              function read(name) {
                check$1.optional(function () {
                  env.assert(scope, '!("' + name + '" in ' + value + ')||' + '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')', 'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps));
                });

                return scope.def('"', name, '" in ', value, '?', STENCIL_OPS, '[', value, '.', name, ']:', GL_KEEP);
              }

              return [prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT, read('fail'), read('zfail'), read('zpass')];
            });

          case S_POLYGON_OFFSET_OFFSET:
            return parseParam(function (value) {
              check$1.commandType(value, 'object', param, env.commandStr);
              var factor = value.factor | 0;
              var units = value.units | 0;
              check$1.commandType(factor, 'number', param + '.factor', env.commandStr);
              check$1.commandType(units, 'number', param + '.units', env.commandStr);
              return [factor, units];
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, value + '&&typeof ' + value + '==="object"', 'invalid ' + prop);
              });

              var FACTOR = scope.def(value, '.factor|0');
              var UNITS = scope.def(value, '.units|0');

              return [FACTOR, UNITS];
            });

          case S_CULL_FACE:
            return parseParam(function (value) {
              var face = 0;
              if (value === 'front') {
                face = GL_FRONT;
              } else if (value === 'back') {
                face = GL_BACK;
              }
              check$1.command(!!face, param, env.commandStr);
              return face;
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, value + '==="front"||' + value + '==="back"', 'invalid cull.face');
              });
              return scope.def(value, '==="front"?', GL_FRONT, ':', GL_BACK);
            });

          case S_LINE_WIDTH:
            return parseParam(function (value) {
              check$1.command(typeof value === 'number' && value >= limits.lineWidthDims[0] && value <= limits.lineWidthDims[1], 'invalid line width, must positive number between ' + limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr);
              return value;
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, 'typeof ' + value + '==="number"&&' + value + '>=' + limits.lineWidthDims[0] + '&&' + value + '<=' + limits.lineWidthDims[1], 'invalid line width');
              });

              return value;
            });

          case S_FRONT_FACE:
            return parseParam(function (value) {
              check$1.commandParameter(value, orientationType, param, env.commandStr);
              return orientationType[value];
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, value + '==="cw"||' + value + '==="ccw"', 'invalid frontFace, must be one of cw,ccw');
              });
              return scope.def(value + '==="cw"?' + GL_CW + ':' + GL_CCW);
            });

          case S_COLOR_MASK:
            return parseParam(function (value) {
              check$1.command(isArrayLike(value) && value.length === 4, 'color.mask must be length 4 array', env.commandStr);
              return value.map(function (v) {
                return !!v;
              });
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, env.shared.isArrayLike + '(' + value + ')&&' + value + '.length===4', 'invalid color.mask');
              });
              return loop(4, function (i) {
                return '!!' + value + '[' + i + ']';
              });
            });

          case S_SAMPLE_COVERAGE:
            return parseParam(function (value) {
              check$1.command(typeof value === 'object' && value, param, env.commandStr);
              var sampleValue = 'value' in value ? value.value : 1;
              var sampleInvert = !!value.invert;
              check$1.command(typeof sampleValue === 'number' && sampleValue >= 0 && sampleValue <= 1, 'sample.coverage.value must be a number between 0 and 1', env.commandStr);
              return [sampleValue, sampleInvert];
            }, function (env, scope, value) {
              check$1.optional(function () {
                env.assert(scope, value + '&&typeof ' + value + '==="object"', 'invalid sample.coverage');
              });
              var VALUE = scope.def('"value" in ', value, '?+', value, '.value:1');
              var INVERT = scope.def('!!', value, '.invert');
              return [VALUE, INVERT];
            });
        }
      });

      return STATE;
    }

    function parseUniforms(uniforms, env) {
      var staticUniforms = uniforms.static;
      var dynamicUniforms = uniforms.dynamic;

      var UNIFORMS = {};

      Object.keys(staticUniforms).forEach(function (name) {
        var value = staticUniforms[name];
        var result;
        if (typeof value === 'number' || typeof value === 'boolean') {
          result = createStaticDecl(function () {
            return value;
          });
        } else if (typeof value === 'function') {
          var reglType = value._reglType;
          if (reglType === 'texture2d' || reglType === 'textureCube') {
            result = createStaticDecl(function (env) {
              return env.link(value);
            });
          } else if (reglType === 'framebuffer' || reglType === 'framebufferCube') {
            check$1.command(value.color.length > 0, 'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr);
            result = createStaticDecl(function (env) {
              return env.link(value.color[0]);
            });
          } else {
            check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr);
          }
        } else if (isArrayLike(value)) {
          result = createStaticDecl(function (env) {
            var ITEM = env.global.def('[', loop(value.length, function (i) {
              check$1.command(typeof value[i] === 'number' || typeof value[i] === 'boolean', 'invalid uniform ' + name, env.commandStr);
              return value[i];
            }), ']');
            return ITEM;
          });
        } else {
          check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr);
        }
        result.value = value;
        UNIFORMS[name] = result;
      });

      Object.keys(dynamicUniforms).forEach(function (key) {
        var dyn = dynamicUniforms[key];
        UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {
          return env.invoke(scope, dyn);
        });
      });

      return UNIFORMS;
    }

    function parseAttributes(attributes, env) {
      var staticAttributes = attributes.static;
      var dynamicAttributes = attributes.dynamic;

      var attributeDefs = {};

      Object.keys(staticAttributes).forEach(function (attribute) {
        var value = staticAttributes[attribute];
        var id = stringStore.id(attribute);

        var record = new AttributeRecord();
        if (isBufferArgs(value)) {
          record.state = ATTRIB_STATE_POINTER;
          record.buffer = bufferState.getBuffer(bufferState.create(value, GL_ARRAY_BUFFER$1, false, true));
          record.type = 0;
        } else {
          var buffer = bufferState.getBuffer(value);
          if (buffer) {
            record.state = ATTRIB_STATE_POINTER;
            record.buffer = buffer;
            record.type = 0;
          } else {
            check$1.command(typeof value === 'object' && value, 'invalid data for attribute ' + attribute, env.commandStr);
            if (value.constant) {
              var constant = value.constant;
              record.buffer = 'null';
              record.state = ATTRIB_STATE_CONSTANT;
              if (typeof constant === 'number') {
                record.x = constant;
              } else {
                check$1.command(isArrayLike(constant) && constant.length > 0 && constant.length <= 4, 'invalid constant for attribute ' + attribute, env.commandStr);
                CUTE_COMPONENTS.forEach(function (c, i) {
                  if (i < constant.length) {
                    record[c] = constant[i];
                  }
                });
              }
            } else {
              if (isBufferArgs(value.buffer)) {
                buffer = bufferState.getBuffer(bufferState.create(value.buffer, GL_ARRAY_BUFFER$1, false, true));
              } else {
                buffer = bufferState.getBuffer(value.buffer);
              }
              check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr);

              var offset = value.offset | 0;
              check$1.command(offset >= 0, 'invalid offset for attribute "' + attribute + '"', env.commandStr);

              var stride = value.stride | 0;
              check$1.command(stride >= 0 && stride < 256, 'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr);

              var size = value.size | 0;
              check$1.command(!('size' in value) || size > 0 && size <= 4, 'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr);

              var normalized = !!value.normalized;

              var type = 0;
              if ('type' in value) {
                check$1.commandParameter(value.type, glTypes, 'invalid type for attribute ' + attribute, env.commandStr);
                type = glTypes[value.type];
              }

              var divisor = value.divisor | 0;
              if ('divisor' in value) {
                check$1.command(divisor === 0 || extInstancing, 'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr);
                check$1.command(divisor >= 0, 'invalid divisor for attribute "' + attribute + '"', env.commandStr);
              }

              check$1.optional(function () {
                var command = env.commandStr;

                var VALID_KEYS = ['buffer', 'offset', 'divisor', 'normalized', 'type', 'size', 'stride'];

                Object.keys(value).forEach(function (prop) {
                  check$1.command(VALID_KEYS.indexOf(prop) >= 0, 'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ')', command);
                });
              });

              record.buffer = buffer;
              record.state = ATTRIB_STATE_POINTER;
              record.size = size;
              record.normalized = normalized;
              record.type = type || buffer.dtype;
              record.offset = offset;
              record.stride = stride;
              record.divisor = divisor;
            }
          }
        }

        attributeDefs[attribute] = createStaticDecl(function (env, scope) {
          var cache = env.attribCache;
          if (id in cache) {
            return cache[id];
          }
          var result = {
            isStream: false
          };
          Object.keys(record).forEach(function (key) {
            result[key] = record[key];
          });
          if (record.buffer) {
            result.buffer = env.link(record.buffer);
            result.type = result.type || result.buffer + '.dtype';
          }
          cache[id] = result;
          return result;
        });
      });

      Object.keys(dynamicAttributes).forEach(function (attribute) {
        var dyn = dynamicAttributes[attribute];

        function appendAttributeCode(env, block) {
          var VALUE = env.invoke(block, dyn);

          var shared = env.shared;

          var IS_BUFFER_ARGS = shared.isBufferArgs;
          var BUFFER_STATE = shared.buffer;

          // Perform validation on attribute
          check$1.optional(function () {
            env.assert(block, VALUE + '&&(typeof ' + VALUE + '==="object"||typeof ' + VALUE + '==="function")&&(' + IS_BUFFER_ARGS + '(' + VALUE + ')||' + BUFFER_STATE + '.getBuffer(' + VALUE + ')||' + BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' + IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' + '("constant" in ' + VALUE + '&&(typeof ' + VALUE + '.constant==="number"||' + shared.isArrayLike + '(' + VALUE + '.constant))))', 'invalid dynamic attribute "' + attribute + '"');
          });

          // allocate names for result
          var result = {
            isStream: block.def(false)
          };
          var defaultRecord = new AttributeRecord();
          defaultRecord.state = ATTRIB_STATE_POINTER;
          Object.keys(defaultRecord).forEach(function (key) {
            result[key] = block.def('' + defaultRecord[key]);
          });

          var BUFFER = result.buffer;
          var TYPE = result.type;
          block('if(', IS_BUFFER_ARGS, '(', VALUE, ')){', result.isStream, '=true;', BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$1, ',', VALUE, ');', TYPE, '=', BUFFER, '.dtype;', '}else{', BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');', 'if(', BUFFER, '){', TYPE, '=', BUFFER, '.dtype;', '}else if("constant" in ', VALUE, '){', result.state, '=', ATTRIB_STATE_CONSTANT, ';', 'if(typeof ' + VALUE + '.constant === "number"){', result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;', CUTE_COMPONENTS.slice(1).map(function (n) {
            return result[n];
          }).join('='), '=0;', '}else{', CUTE_COMPONENTS.map(function (name, i) {
            return result[name] + '=' + VALUE + '.constant.length>=' + i + '?' + VALUE + '.constant[' + i + ']:0;';
          }).join(''), '}}else{', 'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){', BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$1, ',', VALUE, '.buffer);', '}else{', BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);', '}', TYPE, '="type" in ', VALUE, '?', shared.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;', result.normalized, '=!!', VALUE, '.normalized;');
          function emitReadRecord(name) {
            block(result[name], '=', VALUE, '.', name, '|0;');
          }
          emitReadRecord('size');
          emitReadRecord('offset');
          emitReadRecord('stride');
          emitReadRecord('divisor');

          block('}}');

          block.exit('if(', result.isStream, '){', BUFFER_STATE, '.destroyStream(', BUFFER, ');', '}');

          return result;
        }

        attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode);
      });

      return attributeDefs;
    }

    function parseContext(context) {
      var staticContext = context.static;
      var dynamicContext = context.dynamic;
      var result = {};

      Object.keys(staticContext).forEach(function (name) {
        var value = staticContext[name];
        result[name] = createStaticDecl(function (env, scope) {
          if (typeof value === 'number' || typeof value === 'boolean') {
            return '' + value;
          } else {
            return env.link(value);
          }
        });
      });

      Object.keys(dynamicContext).forEach(function (name) {
        var dyn = dynamicContext[name];
        result[name] = createDynamicDecl(dyn, function (env, scope) {
          return env.invoke(scope, dyn);
        });
      });

      return result;
    }

    function parseArguments(options, attributes, uniforms, context, env) {
      var staticOptions = options.static;
      var dynamicOptions = options.dynamic;

      check$1.optional(function () {
        var KEY_NAMES = [S_FRAMEBUFFER, S_VERT, S_FRAG, S_ELEMENTS, S_PRIMITIVE, S_OFFSET, S_COUNT, S_INSTANCES, S_PROFILE].concat(GL_STATE_NAMES);

        function checkKeys(dict) {
          Object.keys(dict).forEach(function (key) {
            check$1.command(KEY_NAMES.indexOf(key) >= 0, 'unknown parameter "' + key + '"', env.commandStr);
          });
        }

        checkKeys(staticOptions);
        checkKeys(dynamicOptions);
      });

      var framebuffer = parseFramebuffer(options, env);
      var viewportAndScissor = parseViewportScissor(options, framebuffer, env);
      var draw = parseDraw(options, env);
      var state = parseGLState(options, env);
      var shader = parseProgram(options, env);

      function copyBox(name) {
        var defn = viewportAndScissor[name];
        if (defn) {
          state[name] = defn;
        }
      }
      copyBox(S_VIEWPORT);
      copyBox(propName(S_SCISSOR_BOX));

      var dirty = Object.keys(state).length > 0;

      var result = {
        framebuffer: framebuffer,
        draw: draw,
        shader: shader,
        state: state,
        dirty: dirty
      };

      result.profile = parseProfile(options, env);
      result.uniforms = parseUniforms(uniforms, env);
      result.attributes = parseAttributes(attributes, env);
      result.context = parseContext(context, env);
      return result;
    }

    // ===================================================
    // ===================================================
    // COMMON UPDATE FUNCTIONS
    // ===================================================
    // ===================================================
    function emitContext(env, scope, context) {
      var shared = env.shared;
      var CONTEXT = shared.context;

      var contextEnter = env.scope();

      Object.keys(context).forEach(function (name) {
        scope.save(CONTEXT, '.' + name);
        var defn = context[name];
        contextEnter(CONTEXT, '.', name, '=', defn.append(env, scope), ';');
      });

      scope(contextEnter);
    }

    // ===================================================
    // ===================================================
    // COMMON DRAWING FUNCTIONS
    // ===================================================
    // ===================================================
    function emitPollFramebuffer(env, scope, framebuffer, skipCheck) {
      var shared = env.shared;

      var GL = shared.gl;
      var FRAMEBUFFER_STATE = shared.framebuffer;
      var EXT_DRAW_BUFFERS;
      if (extDrawBuffers) {
        EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers');
      }

      var constants = env.constants;

      var DRAW_BUFFERS = constants.drawBuffer;
      var BACK_BUFFER = constants.backBuffer;

      var NEXT;
      if (framebuffer) {
        NEXT = framebuffer.append(env, scope);
      } else {
        NEXT = scope.def(FRAMEBUFFER_STATE, '.next');
      }

      if (!skipCheck) {
        scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){');
      }
      scope('if(', NEXT, '){', GL, '.bindFramebuffer(', GL_FRAMEBUFFER$1, ',', NEXT, '.framebuffer);');
      if (extDrawBuffers) {
        scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);');
      }
      scope('}else{', GL, '.bindFramebuffer(', GL_FRAMEBUFFER$1, ',null);');
      if (extDrawBuffers) {
        scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');');
      }
      scope('}', FRAMEBUFFER_STATE, '.cur=', NEXT, ';');
      if (!skipCheck) {
        scope('}');
      }
    }

    function emitPollState(env, scope, args) {
      var shared = env.shared;

      var GL = shared.gl;

      var CURRENT_VARS = env.current;
      var NEXT_VARS = env.next;
      var CURRENT_STATE = shared.current;
      var NEXT_STATE = shared.next;

      var block = env.cond(CURRENT_STATE, '.dirty');

      GL_STATE_NAMES.forEach(function (prop) {
        var param = propName(prop);
        if (param in args.state) {
          return;
        }

        var NEXT, CURRENT;
        if (param in NEXT_VARS) {
          NEXT = NEXT_VARS[param];
          CURRENT = CURRENT_VARS[param];
          var parts = loop(currentState[param].length, function (i) {
            return block.def(NEXT, '[', i, ']');
          });
          block(env.cond(parts.map(function (p, i) {
            return p + '!==' + CURRENT + '[' + i + ']';
          }).join('||')).then(GL, '.', GL_VARIABLES[param], '(', parts, ');', parts.map(function (p, i) {
            return CURRENT + '[' + i + ']=' + p;
          }).join(';'), ';'));
        } else {
          NEXT = block.def(NEXT_STATE, '.', param);
          var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param);
          block(ifte);
          if (param in GL_FLAGS) {
            ifte(env.cond(NEXT).then(GL, '.enable(', GL_FLAGS[param], ');').else(GL, '.disable(', GL_FLAGS[param], ');'), CURRENT_STATE, '.', param, '=', NEXT, ';');
          } else {
            ifte(GL, '.', GL_VARIABLES[param], '(', NEXT, ');', CURRENT_STATE, '.', param, '=', NEXT, ';');
          }
        }
      });
      if (Object.keys(args.state).length === 0) {
        block(CURRENT_STATE, '.dirty=false;');
      }
      scope(block);
    }

    function emitSetOptions(env, scope, options, filter) {
      var shared = env.shared;
      var CURRENT_VARS = env.current;
      var CURRENT_STATE = shared.current;
      var GL = shared.gl;
      sortState(Object.keys(options)).forEach(function (param) {
        var defn = options[param];
        if (filter && !filter(defn)) {
          return;
        }
        var variable = defn.append(env, scope);
        if (GL_FLAGS[param]) {
          var flag = GL_FLAGS[param];
          if (isStatic(defn)) {
            if (variable) {
              scope(GL, '.enable(', flag, ');');
            } else {
              scope(GL, '.disable(', flag, ');');
            }
          } else {
            scope(env.cond(variable).then(GL, '.enable(', flag, ');').else(GL, '.disable(', flag, ');'));
          }
          scope(CURRENT_STATE, '.', param, '=', variable, ';');
        } else if (isArrayLike(variable)) {
          var CURRENT = CURRENT_VARS[param];
          scope(GL, '.', GL_VARIABLES[param], '(', variable, ');', variable.map(function (v, i) {
            return CURRENT + '[' + i + ']=' + v;
          }).join(';'), ';');
        } else {
          scope(GL, '.', GL_VARIABLES[param], '(', variable, ');', CURRENT_STATE, '.', param, '=', variable, ';');
        }
      });
    }

    function injectExtensions(env, scope) {
      if (extInstancing) {
        env.instancing = scope.def(env.shared.extensions, '.angle_instanced_arrays');
      }
    }

    function emitProfile(env, scope, args, useScope, incrementCounter) {
      var shared = env.shared;
      var STATS = env.stats;
      var CURRENT_STATE = shared.current;
      var TIMER = shared.timer;
      var profileArg = args.profile;

      function perfCounter() {
        if (typeof performance === 'undefined') {
          return 'Date.now()';
        } else {
          return 'performance.now()';
        }
      }

      var CPU_START, QUERY_COUNTER;
      function emitProfileStart(block) {
        CPU_START = scope.def();
        block(CPU_START, '=', perfCounter(), ';');
        if (typeof incrementCounter === 'string') {
          block(STATS, '.count+=', incrementCounter, ';');
        } else {
          block(STATS, '.count++;');
        }
        if (timer) {
          if (useScope) {
            QUERY_COUNTER = scope.def();
            block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();');
          } else {
            block(TIMER, '.beginQuery(', STATS, ');');
          }
        }
      }

      function emitProfileEnd(block) {
        block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';');
        if (timer) {
          if (useScope) {
            block(TIMER, '.pushScopeStats(', QUERY_COUNTER, ',', TIMER, '.getNumPendingQueries(),', STATS, ');');
          } else {
            block(TIMER, '.endQuery();');
          }
        }
      }

      function scopeProfile(value) {
        var prev = scope.def(CURRENT_STATE, '.profile');
        scope(CURRENT_STATE, '.profile=', value, ';');
        scope.exit(CURRENT_STATE, '.profile=', prev, ';');
      }

      var USE_PROFILE;
      if (profileArg) {
        if (isStatic(profileArg)) {
          if (profileArg.enable) {
            emitProfileStart(scope);
            emitProfileEnd(scope.exit);
            scopeProfile('true');
          } else {
            scopeProfile('false');
          }
          return;
        }
        USE_PROFILE = profileArg.append(env, scope);
        scopeProfile(USE_PROFILE);
      } else {
        USE_PROFILE = scope.def(CURRENT_STATE, '.profile');
      }

      var start = env.block();
      emitProfileStart(start);
      scope('if(', USE_PROFILE, '){', start, '}');
      var end = env.block();
      emitProfileEnd(end);
      scope.exit('if(', USE_PROFILE, '){', end, '}');
    }

    function emitAttributes(env, scope, args, attributes, filter) {
      var shared = env.shared;

      function typeLength(x) {
        switch (x) {
          case GL_FLOAT_VEC2:
          case GL_INT_VEC2:
          case GL_BOOL_VEC2:
            return 2;
          case GL_FLOAT_VEC3:
          case GL_INT_VEC3:
          case GL_BOOL_VEC3:
            return 3;
          case GL_FLOAT_VEC4:
          case GL_INT_VEC4:
          case GL_BOOL_VEC4:
            return 4;
          default:
            return 1;
        }
      }

      function emitBindAttribute(ATTRIBUTE, size, record) {
        var GL = shared.gl;

        var LOCATION = scope.def(ATTRIBUTE, '.location');
        var BINDING = scope.def(shared.attributes, '[', LOCATION, ']');

        var STATE = record.state;
        var BUFFER = record.buffer;
        var CONST_COMPONENTS = [record.x, record.y, record.z, record.w];

        var COMMON_KEYS = ['buffer', 'normalized', 'offset', 'stride'];

        function emitBuffer() {
          scope('if(!', BINDING, '.buffer){', GL, '.enableVertexAttribArray(', LOCATION, ');}');

          var TYPE = record.type;
          var SIZE;
          if (!record.size) {
            SIZE = size;
          } else {
            SIZE = scope.def(record.size, '||', size);
          }

          scope('if(', BINDING, '.type!==', TYPE, '||', BINDING, '.size!==', SIZE, '||', COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '!==' + record[key];
          }).join('||'), '){', GL, '.bindBuffer(', GL_ARRAY_BUFFER$1, ',', BUFFER, '.buffer);', GL, '.vertexAttribPointer(', [LOCATION, SIZE, TYPE, record.normalized, record.stride, record.offset], ');', BINDING, '.type=', TYPE, ';', BINDING, '.size=', SIZE, ';', COMMON_KEYS.map(function (key) {
            return BINDING + '.' + key + '=' + record[key] + ';';
          }).join(''), '}');

          if (extInstancing) {
            var DIVISOR = record.divisor;
            scope('if(', BINDING, '.divisor!==', DIVISOR, '){', env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');', BINDING, '.divisor=', DIVISOR, ';}');
          }
        }

        function emitConstant() {
          scope('if(', BINDING, '.buffer){', GL, '.disableVertexAttribArray(', LOCATION, ');', '}if(', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i];
          }).join('||'), '){', GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');', CUTE_COMPONENTS.map(function (c, i) {
            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';';
          }).join(''), '}');
        }

        if (STATE === ATTRIB_STATE_POINTER) {
          emitBuffer();
        } else if (STATE === ATTRIB_STATE_CONSTANT) {
          emitConstant();
        } else {
          scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){');
          emitBuffer();
          scope('}else{');
          emitConstant();
          scope('}');
        }
      }

      attributes.forEach(function (attribute) {
        var name = attribute.name;
        var arg = args.attributes[name];
        var record;
        if (arg) {
          if (!filter(arg)) {
            return;
          }
          record = arg.append(env, scope);
        } else {
          if (!filter(SCOPE_DECL)) {
            return;
          }
          var scopeAttrib = env.scopeAttrib(name);
          check$1.optional(function () {
            env.assert(scope, scopeAttrib + '.state', 'missing attribute ' + name);
          });
          record = {};
          Object.keys(new AttributeRecord()).forEach(function (key) {
            record[key] = scope.def(scopeAttrib, '.', key);
          });
        }
        emitBindAttribute(env.link(attribute), typeLength(attribute.info.type), record);
      });
    }

    function emitUniforms(env, scope, args, uniforms, filter) {
      var shared = env.shared;
      var GL = shared.gl;

      var infix;
      for (var i = 0; i < uniforms.length; ++i) {
        var uniform = uniforms[i];
        var name = uniform.name;
        var type = uniform.info.type;
        var arg = args.uniforms[name];
        var UNIFORM = env.link(uniform);
        var LOCATION = UNIFORM + '.location';

        var VALUE;
        if (arg) {
          if (!filter(arg)) {
            continue;
          }
          if (isStatic(arg)) {
            var value = arg.value;
            check$1.command(value !== null && typeof value !== 'undefined', 'missing uniform "' + name + '"', env.commandStr);
            if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
              check$1.command(typeof value === 'function' && (type === GL_SAMPLER_2D && (value._reglType === 'texture2d' || value._reglType === 'framebuffer') || type === GL_SAMPLER_CUBE && (value._reglType === 'textureCube' || value._reglType === 'framebufferCube')), 'invalid texture for uniform ' + name, env.commandStr);
              var TEX_VALUE = env.link(value._texture || value.color[0]._texture);
              scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());');
              scope.exit(TEX_VALUE, '.unbind();');
            } else if (type === GL_FLOAT_MAT2 || type === GL_FLOAT_MAT3 || type === GL_FLOAT_MAT4) {
              check$1.optional(function () {
                check$1.command(isArrayLike(value), 'invalid matrix for uniform ' + name, env.commandStr);
                check$1.command(type === GL_FLOAT_MAT2 && value.length === 4 || type === GL_FLOAT_MAT3 && value.length === 9 || type === GL_FLOAT_MAT4 && value.length === 16, 'invalid length for matrix uniform ' + name, env.commandStr);
              });
              var MAT_VALUE = env.global.def('new Float32Array([' + Array.prototype.slice.call(value) + '])');
              var dim = 2;
              if (type === GL_FLOAT_MAT3) {
                dim = 3;
              } else if (type === GL_FLOAT_MAT4) {
                dim = 4;
              }
              scope(GL, '.uniformMatrix', dim, 'fv(', LOCATION, ',false,', MAT_VALUE, ');');
            } else {
              switch (type) {
                case GL_FLOAT$7:
                  check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr);
                  infix = '1f';
                  break;
                case GL_FLOAT_VEC2:
                  check$1.command(isArrayLike(value) && value.length === 2, 'uniform ' + name, env.commandStr);
                  infix = '2f';
                  break;
                case GL_FLOAT_VEC3:
                  check$1.command(isArrayLike(value) && value.length === 3, 'uniform ' + name, env.commandStr);
                  infix = '3f';
                  break;
                case GL_FLOAT_VEC4:
                  check$1.command(isArrayLike(value) && value.length === 4, 'uniform ' + name, env.commandStr);
                  infix = '4f';
                  break;
                case GL_BOOL:
                  check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr);
                  infix = '1i';
                  break;
                case GL_INT$3:
                  check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr);
                  infix = '1i';
                  break;
                case GL_BOOL_VEC2:
                  check$1.command(isArrayLike(value) && value.length === 2, 'uniform ' + name, env.commandStr);
                  infix = '2i';
                  break;
                case GL_INT_VEC2:
                  check$1.command(isArrayLike(value) && value.length === 2, 'uniform ' + name, env.commandStr);
                  infix = '2i';
                  break;
                case GL_BOOL_VEC3:
                  check$1.command(isArrayLike(value) && value.length === 3, 'uniform ' + name, env.commandStr);
                  infix = '3i';
                  break;
                case GL_INT_VEC3:
                  check$1.command(isArrayLike(value) && value.length === 3, 'uniform ' + name, env.commandStr);
                  infix = '3i';
                  break;
                case GL_BOOL_VEC4:
                  check$1.command(isArrayLike(value) && value.length === 4, 'uniform ' + name, env.commandStr);
                  infix = '4i';
                  break;
                case GL_INT_VEC4:
                  check$1.command(isArrayLike(value) && value.length === 4, 'uniform ' + name, env.commandStr);
                  infix = '4i';
                  break;
              }
              scope(GL, '.uniform', infix, '(', LOCATION, ',', isArrayLike(value) ? Array.prototype.slice.call(value) : value, ');');
            }
            continue;
          } else {
            VALUE = arg.append(env, scope);
          }
        } else {
          if (!filter(SCOPE_DECL)) {
            continue;
          }
          VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']');
        }

        if (type === GL_SAMPLER_2D) {
          scope('if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){', VALUE, '=', VALUE, '.color[0];', '}');
        } else if (type === GL_SAMPLER_CUBE) {
          scope('if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){', VALUE, '=', VALUE, '.color[0];', '}');
        }

        // perform type validation
        check$1.optional(function () {
          function check(pred, message) {
            env.assert(scope, pred, 'bad data or missing for uniform "' + name + '".  ' + message);
          }

          function checkType(type) {
            check('typeof ' + VALUE + '==="' + type + '"', 'invalid type, expected ' + type);
          }

          function checkVector(n, type) {
            check(shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length===' + n, 'invalid vector, should have length ' + n, env.commandStr);
          }

          function checkTexture(target) {
            check('typeof ' + VALUE + '==="function"&&' + VALUE + '._reglType==="texture' + (target === GL_TEXTURE_2D$2 ? '2d' : 'Cube') + '"', 'invalid texture type', env.commandStr);
          }

          switch (type) {
            case GL_INT$3:
              checkType('number');
              break;
            case GL_INT_VEC2:
              checkVector(2, 'number');
              break;
            case GL_INT_VEC3:
              checkVector(3, 'number');
              break;
            case GL_INT_VEC4:
              checkVector(4, 'number');
              break;
            case GL_FLOAT$7:
              checkType('number');
              break;
            case GL_FLOAT_VEC2:
              checkVector(2, 'number');
              break;
            case GL_FLOAT_VEC3:
              checkVector(3, 'number');
              break;
            case GL_FLOAT_VEC4:
              checkVector(4, 'number');
              break;
            case GL_BOOL:
              checkType('boolean');
              break;
            case GL_BOOL_VEC2:
              checkVector(2, 'boolean');
              break;
            case GL_BOOL_VEC3:
              checkVector(3, 'boolean');
              break;
            case GL_BOOL_VEC4:
              checkVector(4, 'boolean');
              break;
            case GL_FLOAT_MAT2:
              checkVector(4, 'number');
              break;
            case GL_FLOAT_MAT3:
              checkVector(9, 'number');
              break;
            case GL_FLOAT_MAT4:
              checkVector(16, 'number');
              break;
            case GL_SAMPLER_2D:
              checkTexture(GL_TEXTURE_2D$2);
              break;
            case GL_SAMPLER_CUBE:
              checkTexture(GL_TEXTURE_CUBE_MAP$1);
              break;
          }
        });

        var unroll = 1;
        switch (type) {
          case GL_SAMPLER_2D:
          case GL_SAMPLER_CUBE:
            var TEX = scope.def(VALUE, '._texture');
            scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());');
            scope.exit(TEX, '.unbind();');
            continue;

          case GL_INT$3:
          case GL_BOOL:
            infix = '1i';
            break;

          case GL_INT_VEC2:
          case GL_BOOL_VEC2:
            infix = '2i';
            unroll = 2;
            break;

          case GL_INT_VEC3:
          case GL_BOOL_VEC3:
            infix = '3i';
            unroll = 3;
            break;

          case GL_INT_VEC4:
          case GL_BOOL_VEC4:
            infix = '4i';
            unroll = 4;
            break;

          case GL_FLOAT$7:
            infix = '1f';
            break;

          case GL_FLOAT_VEC2:
            infix = '2f';
            unroll = 2;
            break;

          case GL_FLOAT_VEC3:
            infix = '3f';
            unroll = 3;
            break;

          case GL_FLOAT_VEC4:
            infix = '4f';
            unroll = 4;
            break;

          case GL_FLOAT_MAT2:
            infix = 'Matrix2fv';
            break;

          case GL_FLOAT_MAT3:
            infix = 'Matrix3fv';
            break;

          case GL_FLOAT_MAT4:
            infix = 'Matrix4fv';
            break;
        }

        scope(GL, '.uniform', infix, '(', LOCATION, ',');
        if (infix.charAt(0) === 'M') {
          var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2);
          var STORAGE = env.global.def('new Float32Array(', matSize, ')');
          scope('false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(', loop(matSize, function (i) {
            return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']';
          }), ',', STORAGE, ')');
        } else if (unroll > 1) {
          scope(loop(unroll, function (i) {
            return VALUE + '[' + i + ']';
          }));
        } else {
          scope(VALUE);
        }
        scope(');');
      }
    }

    function emitDraw(env, outer, inner, args) {
      var shared = env.shared;
      var GL = shared.gl;
      var DRAW_STATE = shared.draw;

      var drawOptions = args.draw;

      function emitElements() {
        var defn = drawOptions.elements;
        var ELEMENTS;
        var scope = outer;
        if (defn) {
          if (defn.contextDep && args.contextDynamic || defn.propDep) {
            scope = inner;
          }
          ELEMENTS = defn.append(env, scope);
        } else {
          ELEMENTS = scope.def(DRAW_STATE, '.', S_ELEMENTS);
        }
        if (ELEMENTS) {
          scope('if(' + ELEMENTS + ')' + GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$1 + ',' + ELEMENTS + '.buffer.buffer);');
        }
        return ELEMENTS;
      }

      function emitCount() {
        var defn = drawOptions.count;
        var COUNT;
        var scope = outer;
        if (defn) {
          if (defn.contextDep && args.contextDynamic || defn.propDep) {
            scope = inner;
          }
          COUNT = defn.append(env, scope);
          check$1.optional(function () {
            if (defn.MISSING) {
              env.assert(outer, 'false', 'missing vertex count');
            }
            if (defn.DYNAMIC) {
              env.assert(scope, COUNT + '>=0', 'missing vertex count');
            }
          });
        } else {
          COUNT = scope.def(DRAW_STATE, '.', S_COUNT);
          check$1.optional(function () {
            env.assert(scope, COUNT + '>=0', 'missing vertex count');
          });
        }
        return COUNT;
      }

      var ELEMENTS = emitElements();
      function emitValue(name) {
        var defn = drawOptions[name];
        if (defn) {
          if (defn.contextDep && args.contextDynamic || defn.propDep) {
            return defn.append(env, inner);
          } else {
            return defn.append(env, outer);
          }
        } else {
          return outer.def(DRAW_STATE, '.', name);
        }
      }

      var PRIMITIVE = emitValue(S_PRIMITIVE);
      var OFFSET = emitValue(S_OFFSET);

      var COUNT = emitCount();
      if (typeof COUNT === 'number') {
        if (COUNT === 0) {
          return;
        }
      } else {
        inner('if(', COUNT, '){');
        inner.exit('}');
      }

      var INSTANCES, EXT_INSTANCING;
      if (extInstancing) {
        INSTANCES = emitValue(S_INSTANCES);
        EXT_INSTANCING = env.instancing;
      }

      var ELEMENT_TYPE = ELEMENTS + '.type';

      var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements);

      function emitInstancing() {
        function drawElements() {
          inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [PRIMITIVE, COUNT, ELEMENT_TYPE, OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$7 + ')>>1)', INSTANCES], ');');
        }

        function drawArrays() {
          inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(', [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');');
        }

        if (ELEMENTS) {
          if (!elementsStatic) {
            inner('if(', ELEMENTS, '){');
            drawElements();
            inner('}else{');
            drawArrays();
            inner('}');
          } else {
            drawElements();
          }
        } else {
          drawArrays();
        }
      }

      function emitRegular() {
        function drawElements() {
          inner(GL + '.drawElements(' + [PRIMITIVE, COUNT, ELEMENT_TYPE, OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$7 + ')>>1)'] + ');');
        }

        function drawArrays() {
          inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');');
        }

        if (ELEMENTS) {
          if (!elementsStatic) {
            inner('if(', ELEMENTS, '){');
            drawElements();
            inner('}else{');
            drawArrays();
            inner('}');
          } else {
            drawElements();
          }
        } else {
          drawArrays();
        }
      }

      if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {
        if (typeof INSTANCES === 'string') {
          inner('if(', INSTANCES, '>0){');
          emitInstancing();
          inner('}else if(', INSTANCES, '<0){');
          emitRegular();
          inner('}');
        } else {
          emitInstancing();
        }
      } else {
        emitRegular();
      }
    }

    function createBody(emitBody, parentEnv, args, program, count) {
      var env = createREGLEnvironment();
      var scope = env.proc('body', count);
      check$1.optional(function () {
        env.commandStr = parentEnv.commandStr;
        env.command = env.link(parentEnv.commandStr);
      });
      if (extInstancing) {
        env.instancing = scope.def(env.shared.extensions, '.angle_instanced_arrays');
      }
      emitBody(env, scope, args, program);
      return env.compile().body;
    }

    // ===================================================
    // ===================================================
    // DRAW PROC
    // ===================================================
    // ===================================================
    function emitDrawBody(env, draw, args, program) {
      injectExtensions(env, draw);
      emitAttributes(env, draw, args, program.attributes, function () {
        return true;
      });
      emitUniforms(env, draw, args, program.uniforms, function () {
        return true;
      });
      emitDraw(env, draw, draw, args);
    }

    function emitDrawProc(env, args) {
      var draw = env.proc('draw', 1);

      injectExtensions(env, draw);

      emitContext(env, draw, args.context);
      emitPollFramebuffer(env, draw, args.framebuffer);

      emitPollState(env, draw, args);
      emitSetOptions(env, draw, args.state);

      emitProfile(env, draw, args, false, true);

      var program = args.shader.progVar.append(env, draw);
      draw(env.shared.gl, '.useProgram(', program, '.program);');

      if (args.shader.program) {
        emitDrawBody(env, draw, args, args.shader.program);
      } else {
        var drawCache = env.global.def('{}');
        var PROG_ID = draw.def(program, '.id');
        var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']');
        draw(env.cond(CACHED_PROC).then(CACHED_PROC, '.call(this,a0);').else(CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=', env.link(function (program) {
          return createBody(emitDrawBody, env, args, program, 1);
        }), '(', program, ');', CACHED_PROC, '.call(this,a0);'));
      }

      if (Object.keys(args.state).length > 0) {
        draw(env.shared.current, '.dirty=true;');
      }
    }

    // ===================================================
    // ===================================================
    // BATCH PROC
    // ===================================================
    // ===================================================

    function emitBatchDynamicShaderBody(env, scope, args, program) {
      env.batchId = 'a1';

      injectExtensions(env, scope);

      function all() {
        return true;
      }

      emitAttributes(env, scope, args, program.attributes, all);
      emitUniforms(env, scope, args, program.uniforms, all);
      emitDraw(env, scope, scope, args);
    }

    function emitBatchBody(env, scope, args, program) {
      injectExtensions(env, scope);

      var contextDynamic = args.contextDep;

      var BATCH_ID = scope.def();
      var PROP_LIST = 'a0';
      var NUM_PROPS = 'a1';
      var PROPS = scope.def();
      env.shared.props = PROPS;
      env.batchId = BATCH_ID;

      var outer = env.scope();
      var inner = env.scope();

      scope(outer.entry, 'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){', PROPS, '=', PROP_LIST, '[', BATCH_ID, '];', inner, '}', outer.exit);

      function isInnerDefn(defn) {
        return defn.contextDep && contextDynamic || defn.propDep;
      }

      function isOuterDefn(defn) {
        return !isInnerDefn(defn);
      }

      if (args.needsContext) {
        emitContext(env, inner, args.context);
      }
      if (args.needsFramebuffer) {
        emitPollFramebuffer(env, inner, args.framebuffer);
      }
      emitSetOptions(env, inner, args.state, isInnerDefn);

      if (args.profile && isInnerDefn(args.profile)) {
        emitProfile(env, inner, args, false, true);
      }

      if (!program) {
        var progCache = env.global.def('{}');
        var PROGRAM = args.shader.progVar.append(env, inner);
        var PROG_ID = inner.def(PROGRAM, '.id');
        var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']');
        inner(env.shared.gl, '.useProgram(', PROGRAM, '.program);', 'if(!', CACHED_PROC, '){', CACHED_PROC, '=', progCache, '[', PROG_ID, ']=', env.link(function (program) {
          return createBody(emitBatchDynamicShaderBody, env, args, program, 2);
        }), '(', PROGRAM, ');}', CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');');
      } else {
        emitAttributes(env, outer, args, program.attributes, isOuterDefn);
        emitAttributes(env, inner, args, program.attributes, isInnerDefn);
        emitUniforms(env, outer, args, program.uniforms, isOuterDefn);
        emitUniforms(env, inner, args, program.uniforms, isInnerDefn);
        emitDraw(env, outer, inner, args);
      }
    }

    function emitBatchProc(env, args) {
      var batch = env.proc('batch', 2);
      env.batchId = '0';

      injectExtensions(env, batch);

      // Check if any context variables depend on props
      var contextDynamic = false;
      var needsContext = true;
      Object.keys(args.context).forEach(function (name) {
        contextDynamic = contextDynamic || args.context[name].propDep;
      });
      if (!contextDynamic) {
        emitContext(env, batch, args.context);
        needsContext = false;
      }

      // framebuffer state affects framebufferWidth/height context vars
      var framebuffer = args.framebuffer;
      var needsFramebuffer = false;
      if (framebuffer) {
        if (framebuffer.propDep) {
          contextDynamic = needsFramebuffer = true;
        } else if (framebuffer.contextDep && contextDynamic) {
          needsFramebuffer = true;
        }
        if (!needsFramebuffer) {
          emitPollFramebuffer(env, batch, framebuffer);
        }
      } else {
        emitPollFramebuffer(env, batch, null);
      }

      // viewport is weird because it can affect context vars
      if (args.state.viewport && args.state.viewport.propDep) {
        contextDynamic = true;
      }

      function isInnerDefn(defn) {
        return defn.contextDep && contextDynamic || defn.propDep;
      }

      // set webgl options
      emitPollState(env, batch, args);
      emitSetOptions(env, batch, args.state, function (defn) {
        return !isInnerDefn(defn);
      });

      if (!args.profile || !isInnerDefn(args.profile)) {
        emitProfile(env, batch, args, false, 'a1');
      }

      // Save these values to args so that the batch body routine can use them
      args.contextDep = contextDynamic;
      args.needsContext = needsContext;
      args.needsFramebuffer = needsFramebuffer;

      // determine if shader is dynamic
      var progDefn = args.shader.progVar;
      if (progDefn.contextDep && contextDynamic || progDefn.propDep) {
        emitBatchBody(env, batch, args, null);
      } else {
        var PROGRAM = progDefn.append(env, batch);
        batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);');
        if (args.shader.program) {
          emitBatchBody(env, batch, args, args.shader.program);
        } else {
          var batchCache = env.global.def('{}');
          var PROG_ID = batch.def(PROGRAM, '.id');
          var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']');
          batch(env.cond(CACHED_PROC).then(CACHED_PROC, '.call(this,a0,a1);').else(CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=', env.link(function (program) {
            return createBody(emitBatchBody, env, args, program, 2);
          }), '(', PROGRAM, ');', CACHED_PROC, '.call(this,a0,a1);'));
        }
      }

      if (Object.keys(args.state).length > 0) {
        batch(env.shared.current, '.dirty=true;');
      }
    }

    // ===================================================
    // ===================================================
    // SCOPE COMMAND
    // ===================================================
    // ===================================================
    function emitScopeProc(env, args) {
      var scope = env.proc('scope', 3);
      env.batchId = 'a2';

      var shared = env.shared;
      var CURRENT_STATE = shared.current;

      emitContext(env, scope, args.context);

      if (args.framebuffer) {
        args.framebuffer.append(env, scope);
      }

      sortState(Object.keys(args.state)).forEach(function (name) {
        var defn = args.state[name];
        var value = defn.append(env, scope);
        if (isArrayLike(value)) {
          value.forEach(function (v, i) {
            scope.set(env.next[name], '[' + i + ']', v);
          });
        } else {
          scope.set(shared.next, '.' + name, value);
        }
      });

      emitProfile(env, scope, args, true, true);[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(function (opt) {
        var variable = args.draw[opt];
        if (!variable) {
          return;
        }
        scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope));
      });

      Object.keys(args.uniforms).forEach(function (opt) {
        scope.set(shared.uniforms, '[' + stringStore.id(opt) + ']', args.uniforms[opt].append(env, scope));
      });

      Object.keys(args.attributes).forEach(function (name) {
        var record = args.attributes[name].append(env, scope);
        var scopeAttrib = env.scopeAttrib(name);
        Object.keys(new AttributeRecord()).forEach(function (prop) {
          scope.set(scopeAttrib, '.' + prop, record[prop]);
        });
      });

      function saveShader(name) {
        var shader = args.shader[name];
        if (shader) {
          scope.set(shared.shader, '.' + name, shader.append(env, scope));
        }
      }
      saveShader(S_VERT);
      saveShader(S_FRAG);

      if (Object.keys(args.state).length > 0) {
        scope(CURRENT_STATE, '.dirty=true;');
        scope.exit(CURRENT_STATE, '.dirty=true;');
      }

      scope('a1(', env.shared.context, ',a0,', env.batchId, ');');
    }

    function isDynamicObject(object) {
      if (typeof object !== 'object' || isArrayLike(object)) {
        return;
      }
      var props = Object.keys(object);
      for (var i = 0; i < props.length; ++i) {
        if (dynamic.isDynamic(object[props[i]])) {
          return true;
        }
      }
      return false;
    }

    function splatObject(env, options, name) {
      var object = options.static[name];
      if (!object || !isDynamicObject(object)) {
        return;
      }

      var globals = env.global;
      var keys = Object.keys(object);
      var thisDep = false;
      var contextDep = false;
      var propDep = false;
      var objectRef = env.global.def('{}');
      keys.forEach(function (key) {
        var value = object[key];
        if (dynamic.isDynamic(value)) {
          if (typeof value === 'function') {
            value = object[key] = dynamic.unbox(value);
          }
          var deps = createDynamicDecl(value, null);
          thisDep = thisDep || deps.thisDep;
          propDep = propDep || deps.propDep;
          contextDep = contextDep || deps.contextDep;
        } else {
          globals(objectRef, '.', key, '=');
          switch (typeof value) {
            case 'number':
              globals(value);
              break;
            case 'string':
              globals('"', value, '"');
              break;
            case 'object':
              if (Array.isArray(value)) {
                globals('[', value.join(), ']');
              }
              break;
            default:
              globals(env.link(value));
              break;
          }
          globals(';');
        }
      });

      function appendBlock(env, block) {
        keys.forEach(function (key) {
          var value = object[key];
          if (!dynamic.isDynamic(value)) {
            return;
          }
          var ref = env.invoke(block, value);
          block(objectRef, '.', key, '=', ref, ';');
        });
      }

      options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
        thisDep: thisDep,
        contextDep: contextDep,
        propDep: propDep,
        ref: objectRef,
        append: appendBlock
      });
      delete options.static[name];
    }

    // ===========================================================================
    // ===========================================================================
    // MAIN DRAW COMMAND
    // ===========================================================================
    // ===========================================================================
    function compileCommand(options, attributes, uniforms, context, stats) {
      var env = createREGLEnvironment();

      // link stats, so that we can easily access it in the program.
      env.stats = env.link(stats);

      // splat options and attributes to allow for dynamic nested properties
      Object.keys(attributes.static).forEach(function (key) {
        splatObject(env, attributes, key);
      });
      NESTED_OPTIONS.forEach(function (name) {
        splatObject(env, options, name);
      });

      var args = parseArguments(options, attributes, uniforms, context, env);

      emitDrawProc(env, args);
      emitScopeProc(env, args);
      emitBatchProc(env, args);

      return env.compile();
    }

    // ===========================================================================
    // ===========================================================================
    // POLL / REFRESH
    // ===========================================================================
    // ===========================================================================
    return {
      next: nextState,
      current: currentState,
      procs: function () {
        var env = createREGLEnvironment();
        var poll = env.proc('poll');
        var refresh = env.proc('refresh');
        var common = env.block();
        poll(common);
        refresh(common);

        var shared = env.shared;
        var GL = shared.gl;
        var NEXT_STATE = shared.next;
        var CURRENT_STATE = shared.current;

        common(CURRENT_STATE, '.dirty=false;');

        emitPollFramebuffer(env, poll);
        emitPollFramebuffer(env, refresh, null, true);

        // Refresh updates all attribute state changes
        var extInstancing = gl.getExtension('angle_instanced_arrays');
        var INSTANCING;
        if (extInstancing) {
          INSTANCING = env.link(extInstancing);
        }
        for (var i = 0; i < limits.maxAttributes; ++i) {
          var BINDING = refresh.def(shared.attributes, '[', i, ']');
          var ifte = env.cond(BINDING, '.buffer');
          ifte.then(GL, '.enableVertexAttribArray(', i, ');', GL, '.bindBuffer(', GL_ARRAY_BUFFER$1, ',', BINDING, '.buffer.buffer);', GL, '.vertexAttribPointer(', i, ',', BINDING, '.size,', BINDING, '.type,', BINDING, '.normalized,', BINDING, '.stride,', BINDING, '.offset);').else(GL, '.disableVertexAttribArray(', i, ');', GL, '.vertexAttrib4f(', i, ',', BINDING, '.x,', BINDING, '.y,', BINDING, '.z,', BINDING, '.w);', BINDING, '.buffer=null;');
          refresh(ifte);
          if (extInstancing) {
            refresh(INSTANCING, '.vertexAttribDivisorANGLE(', i, ',', BINDING, '.divisor);');
          }
        }

        Object.keys(GL_FLAGS).forEach(function (flag) {
          var cap = GL_FLAGS[flag];
          var NEXT = common.def(NEXT_STATE, '.', flag);
          var block = env.block();
          block('if(', NEXT, '){', GL, '.enable(', cap, ')}else{', GL, '.disable(', cap, ')}', CURRENT_STATE, '.', flag, '=', NEXT, ';');
          refresh(block);
          poll('if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){', block, '}');
        });

        Object.keys(GL_VARIABLES).forEach(function (name) {
          var func = GL_VARIABLES[name];
          var init = currentState[name];
          var NEXT, CURRENT;
          var block = env.block();
          block(GL, '.', func, '(');
          if (isArrayLike(init)) {
            var n = init.length;
            NEXT = env.global.def(NEXT_STATE, '.', name);
            CURRENT = env.global.def(CURRENT_STATE, '.', name);
            block(loop(n, function (i) {
              return NEXT + '[' + i + ']';
            }), ');', loop(n, function (i) {
              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];';
            }).join(''));
            poll('if(', loop(n, function (i) {
              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']';
            }).join('||'), '){', block, '}');
          } else {
            NEXT = common.def(NEXT_STATE, '.', name);
            CURRENT = common.def(CURRENT_STATE, '.', name);
            block(NEXT, ');', CURRENT_STATE, '.', name, '=', NEXT, ';');
            poll('if(', NEXT, '!==', CURRENT, '){', block, '}');
          }
          refresh(block);
        });

        return env.compile();
      }(),
      compile: compileCommand
    };
  }

  function stats() {
    return {
      bufferCount: 0,
      elementsCount: 0,
      framebufferCount: 0,
      shaderCount: 0,
      textureCount: 0,
      cubeCount: 0,
      renderbufferCount: 0,

      maxTextureUnits: 0
    };
  }

  var GL_QUERY_RESULT_EXT = 0x8866;
  var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867;
  var GL_TIME_ELAPSED_EXT = 0x88BF;

  var createTimer = function (gl, extensions) {
    var extTimer = extensions.ext_disjoint_timer_query;

    if (!extTimer) {
      return null;
    }

    // QUERY POOL BEGIN
    var queryPool = [];
    function allocQuery() {
      return queryPool.pop() || extTimer.createQueryEXT();
    }
    function freeQuery(query) {
      queryPool.push(query);
    }
    // QUERY POOL END

    var pendingQueries = [];
    function beginQuery(stats) {
      var query = allocQuery();
      extTimer.beginQueryEXT(GL_TIME_ELAPSED_EXT, query);
      pendingQueries.push(query);
      pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats);
    }

    function endQuery() {
      extTimer.endQueryEXT(GL_TIME_ELAPSED_EXT);
    }

    //
    // Pending stats pool.
    //
    function PendingStats() {
      this.startQueryIndex = -1;
      this.endQueryIndex = -1;
      this.sum = 0;
      this.stats = null;
    }
    var pendingStatsPool = [];
    function allocPendingStats() {
      return pendingStatsPool.pop() || new PendingStats();
    }
    function freePendingStats(pendingStats) {
      pendingStatsPool.push(pendingStats);
    }
    // Pending stats pool end

    var pendingStats = [];
    function pushScopeStats(start, end, stats) {
      var ps = allocPendingStats();
      ps.startQueryIndex = start;
      ps.endQueryIndex = end;
      ps.sum = 0;
      ps.stats = stats;
      pendingStats.push(ps);
    }

    // we should call this at the beginning of the frame,
    // in order to update gpuTime
    var timeSum = [];
    var queryPtr = [];
    function update() {
      var ptr, i;

      var n = pendingQueries.length;
      if (n === 0) {
        return;
      }

      // Reserve space
      queryPtr.length = Math.max(queryPtr.length, n + 1);
      timeSum.length = Math.max(timeSum.length, n + 1);
      timeSum[0] = 0;
      queryPtr[0] = 0;

      // Update all pending timer queries
      var queryTime = 0;
      ptr = 0;
      for (i = 0; i < pendingQueries.length; ++i) {
        var query = pendingQueries[i];
        if (extTimer.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
          queryTime += extTimer.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT);
          freeQuery(query);
        } else {
          pendingQueries[ptr++] = query;
        }
        timeSum[i + 1] = queryTime;
        queryPtr[i + 1] = ptr;
      }
      pendingQueries.length = ptr;

      // Update all pending stat queries
      ptr = 0;
      for (i = 0; i < pendingStats.length; ++i) {
        var stats = pendingStats[i];
        var start = stats.startQueryIndex;
        var end = stats.endQueryIndex;
        stats.sum += timeSum[end] - timeSum[start];
        var startPtr = queryPtr[start];
        var endPtr = queryPtr[end];
        if (endPtr === startPtr) {
          stats.stats.gpuTime += stats.sum / 1e6;
          freePendingStats(stats);
        } else {
          stats.startQueryIndex = startPtr;
          stats.endQueryIndex = endPtr;
          pendingStats[ptr++] = stats;
        }
      }
      pendingStats.length = ptr;
    }

    return {
      beginQuery: beginQuery,
      endQuery: endQuery,
      pushScopeStats: pushScopeStats,
      update: update,
      getNumPendingQueries: function () {
        return pendingQueries.length;
      },
      clear: function () {
        queryPool.push.apply(queryPool, pendingQueries);
        for (var i = 0; i < queryPool.length; i++) {
          extTimer.deleteQueryEXT(queryPool[i]);
        }
        pendingQueries.length = 0;
        queryPool.length = 0;
      },
      restore: function () {
        pendingQueries.length = 0;
        queryPool.length = 0;
      }
    };
  };

  var GL_COLOR_BUFFER_BIT = 16384;
  var GL_DEPTH_BUFFER_BIT = 256;
  var GL_STENCIL_BUFFER_BIT = 1024;

  var GL_ARRAY_BUFFER = 34962;

  var CONTEXT_LOST_EVENT = 'webglcontextlost';
  var CONTEXT_RESTORED_EVENT = 'webglcontextrestored';

  var DYN_PROP = 1;
  var DYN_CONTEXT = 2;
  var DYN_STATE = 3;

  function find(haystack, needle) {
    for (var i = 0; i < haystack.length; ++i) {
      if (haystack[i] === needle) {
        return i;
      }
    }
    return -1;
  }

  function wrapREGL(args) {
    var config = parseArgs(args);
    if (!config) {
      return null;
    }

    var gl = config.gl;
    var glAttributes = gl.getContextAttributes();
    var contextLost = gl.isContextLost();

    var extensionState = createExtensionCache(gl, config);
    if (!extensionState) {
      return null;
    }

    var stringStore = createStringStore();
    var stats$$1 = stats();
    var extensions = extensionState.extensions;
    var timer = createTimer(gl, extensions);

    var START_TIME = clock();
    var WIDTH = gl.drawingBufferWidth;
    var HEIGHT = gl.drawingBufferHeight;

    var contextState = {
      tick: 0,
      time: 0,
      viewportWidth: WIDTH,
      viewportHeight: HEIGHT,
      framebufferWidth: WIDTH,
      framebufferHeight: HEIGHT,
      drawingBufferWidth: WIDTH,
      drawingBufferHeight: HEIGHT,
      pixelRatio: config.pixelRatio
    };
    var uniformState = {};
    var drawState = {
      elements: null,
      primitive: 4, // GL_TRIANGLES
      count: -1,
      offset: 0,
      instances: -1
    };

    var limits = wrapLimits(gl, extensions);
    var bufferState = wrapBufferState(gl, stats$$1, config);
    var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1);
    var attributeState = wrapAttributeState(gl, extensions, limits, bufferState, stringStore);
    var shaderState = wrapShaderState(gl, stringStore, stats$$1, config);
    var textureState = createTextureSet(gl, extensions, limits, function () {
      core.procs.poll();
    }, contextState, stats$$1, config);
    var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config);
    var framebufferState = wrapFBOState(gl, extensions, limits, textureState, renderbufferState, stats$$1);
    var core = reglCore(gl, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer, config);
    var readPixels = wrapReadPixels(gl, framebufferState, core.procs.poll, contextState, glAttributes, extensions);

    var nextState = core.next;
    var canvas = gl.canvas;

    var rafCallbacks = [];
    var lossCallbacks = [];
    var restoreCallbacks = [];
    var destroyCallbacks = [config.onDestroy];

    var activeRAF = null;
    function handleRAF() {
      if (rafCallbacks.length === 0) {
        if (timer) {
          timer.update();
        }
        activeRAF = null;
        return;
      }

      // schedule next animation frame
      activeRAF = raf.next(handleRAF);

      // poll for changes
      poll();

      // fire a callback for all pending rafs
      for (var i = rafCallbacks.length - 1; i >= 0; --i) {
        var cb = rafCallbacks[i];
        if (cb) {
          cb(contextState, null, 0);
        }
      }

      // flush all pending webgl calls
      gl.flush();

      // poll GPU timers *after* gl.flush so we don't delay command dispatch
      if (timer) {
        timer.update();
      }
    }

    function startRAF() {
      if (!activeRAF && rafCallbacks.length > 0) {
        activeRAF = raf.next(handleRAF);
      }
    }

    function stopRAF() {
      if (activeRAF) {
        raf.cancel(handleRAF);
        activeRAF = null;
      }
    }

    function handleContextLoss(event) {
      event.preventDefault();

      // set context lost flag
      contextLost = true;

      // pause request animation frame
      stopRAF();

      // lose context
      lossCallbacks.forEach(function (cb) {
        cb();
      });
    }

    function handleContextRestored(event) {
      // clear error code
      gl.getError();

      // clear context lost flag
      contextLost = false;

      // refresh state
      extensionState.restore();
      shaderState.restore();
      bufferState.restore();
      textureState.restore();
      renderbufferState.restore();
      framebufferState.restore();
      if (timer) {
        timer.restore();
      }

      // refresh state
      core.procs.refresh();

      // restart RAF
      startRAF();

      // restore context
      restoreCallbacks.forEach(function (cb) {
        cb();
      });
    }

    if (canvas) {
      canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false);
      canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false);
    }

    function destroy() {
      rafCallbacks.length = 0;
      stopRAF();

      if (canvas) {
        canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss);
        canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored);
      }

      shaderState.clear();
      framebufferState.clear();
      renderbufferState.clear();
      textureState.clear();
      elementState.clear();
      bufferState.clear();

      if (timer) {
        timer.clear();
      }

      destroyCallbacks.forEach(function (cb) {
        cb();
      });
    }

    function compileProcedure(options) {
      check$1(!!options, 'invalid args to regl({...})');
      check$1.type(options, 'object', 'invalid args to regl({...})');

      function flattenNestedOptions(options) {
        var result = extend({}, options);
        delete result.uniforms;
        delete result.attributes;
        delete result.context;

        if ('stencil' in result && result.stencil.op) {
          result.stencil.opBack = result.stencil.opFront = result.stencil.op;
          delete result.stencil.op;
        }

        function merge(name) {
          if (name in result) {
            var child = result[name];
            delete result[name];
            Object.keys(child).forEach(function (prop) {
              result[name + '.' + prop] = child[prop];
            });
          }
        }
        merge('blend');
        merge('depth');
        merge('cull');
        merge('stencil');
        merge('polygonOffset');
        merge('scissor');
        merge('sample');

        return result;
      }

      function separateDynamic(object) {
        var staticItems = {};
        var dynamicItems = {};
        Object.keys(object).forEach(function (option) {
          var value = object[option];
          if (dynamic.isDynamic(value)) {
            dynamicItems[option] = dynamic.unbox(value, option);
          } else {
            staticItems[option] = value;
          }
        });
        return {
          dynamic: dynamicItems,
          static: staticItems
        };
      }

      // Treat context variables separate from other dynamic variables
      var context = separateDynamic(options.context || {});
      var uniforms = separateDynamic(options.uniforms || {});
      var attributes = separateDynamic(options.attributes || {});
      var opts = separateDynamic(flattenNestedOptions(options));

      var stats$$1 = {
        gpuTime: 0.0,
        cpuTime: 0.0,
        count: 0
      };

      var compiled = core.compile(opts, attributes, uniforms, context, stats$$1);

      var draw = compiled.draw;
      var batch = compiled.batch;
      var scope = compiled.scope;

      // FIXME: we should modify code generation for batch commands so this
      // isn't necessary
      var EMPTY_ARRAY = [];
      function reserve(count) {
        while (EMPTY_ARRAY.length < count) {
          EMPTY_ARRAY.push(null);
        }
        return EMPTY_ARRAY;
      }

      function REGLCommand(args, body) {
        var i;
        if (contextLost) {
          check$1.raise('context lost');
        }
        if (typeof args === 'function') {
          return scope.call(this, null, args, 0);
        } else if (typeof body === 'function') {
          if (typeof args === 'number') {
            for (i = 0; i < args; ++i) {
              scope.call(this, null, body, i);
            }
            return;
          } else if (Array.isArray(args)) {
            for (i = 0; i < args.length; ++i) {
              scope.call(this, args[i], body, i);
            }
            return;
          } else {
            return scope.call(this, args, body, 0);
          }
        } else if (typeof args === 'number') {
          if (args > 0) {
            return batch.call(this, reserve(args | 0), args | 0);
          }
        } else if (Array.isArray(args)) {
          if (args.length) {
            return batch.call(this, args, args.length);
          }
        } else {
          return draw.call(this, args);
        }
      }

      return extend(REGLCommand, {
        stats: stats$$1
      });
    }

    var setFBO = framebufferState.setFBO = compileProcedure({
      framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')
    });

    function clearImpl(_, options) {
      var clearFlags = 0;
      core.procs.poll();

      var c = options.color;
      if (c) {
        gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0);
        clearFlags |= GL_COLOR_BUFFER_BIT;
      }
      if ('depth' in options) {
        gl.clearDepth(+options.depth);
        clearFlags |= GL_DEPTH_BUFFER_BIT;
      }
      if ('stencil' in options) {
        gl.clearStencil(options.stencil | 0);
        clearFlags |= GL_STENCIL_BUFFER_BIT;
      }

      check$1(!!clearFlags, 'called regl.clear with no buffer specified');
      gl.clear(clearFlags);
    }

    function clear(options) {
      check$1(typeof options === 'object' && options, 'regl.clear() takes an object as input');
      if ('framebuffer' in options) {
        if (options.framebuffer && options.framebuffer_reglType === 'framebufferCube') {
          for (var i = 0; i < 6; ++i) {
            setFBO(extend({
              framebuffer: options.framebuffer.faces[i]
            }, options), clearImpl);
          }
        } else {
          setFBO(options, clearImpl);
        }
      } else {
        clearImpl(null, options);
      }
    }

    function frame(cb) {
      check$1.type(cb, 'function', 'regl.frame() callback must be a function');
      rafCallbacks.push(cb);

      function cancel() {
        // FIXME:  should we check something other than equals cb here?
        // what if a user calls frame twice with the same callback...
        //
        var i = find(rafCallbacks, cb);
        check$1(i >= 0, 'cannot cancel a frame twice');
        function pendingCancel() {
          var index = find(rafCallbacks, pendingCancel);
          rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1];
          rafCallbacks.length -= 1;
          if (rafCallbacks.length <= 0) {
            stopRAF();
          }
        }
        rafCallbacks[i] = pendingCancel;
      }

      startRAF();

      return {
        cancel: cancel
      };
    }

    // poll viewport
    function pollViewport() {
      var viewport = nextState.viewport;
      var scissorBox = nextState.scissor_box;
      viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0;
      contextState.viewportWidth = contextState.framebufferWidth = contextState.drawingBufferWidth = viewport[2] = scissorBox[2] = gl.drawingBufferWidth;
      contextState.viewportHeight = contextState.framebufferHeight = contextState.drawingBufferHeight = viewport[3] = scissorBox[3] = gl.drawingBufferHeight;
    }

    function poll() {
      contextState.tick += 1;
      contextState.time = now();
      pollViewport();
      core.procs.poll();
    }

    function refresh() {
      pollViewport();
      core.procs.refresh();
      if (timer) {
        timer.update();
      }
    }

    function now() {
      return (clock() - START_TIME) / 1000.0;
    }

    refresh();

    function addListener(event, callback) {
      check$1.type(callback, 'function', 'listener callback must be a function');

      var callbacks;
      switch (event) {
        case 'frame':
          return frame(callback);
        case 'lost':
          callbacks = lossCallbacks;
          break;
        case 'restore':
          callbacks = restoreCallbacks;
          break;
        case 'destroy':
          callbacks = destroyCallbacks;
          break;
        default:
          check$1.raise('invalid event, must be one of frame,lost,restore,destroy');
      }

      callbacks.push(callback);
      return {
        cancel: function () {
          for (var i = 0; i < callbacks.length; ++i) {
            if (callbacks[i] === callback) {
              callbacks[i] = callbacks[callbacks.length - 1];
              callbacks.pop();
              return;
            }
          }
        }
      };
    }

    var regl = extend(compileProcedure, {
      // Clear current FBO
      clear: clear,

      // Short cuts for dynamic variables
      prop: dynamic.define.bind(null, DYN_PROP),
      context: dynamic.define.bind(null, DYN_CONTEXT),
      this: dynamic.define.bind(null, DYN_STATE),

      // executes an empty draw command
      draw: compileProcedure({}),

      // Resources
      buffer: function (options) {
        return bufferState.create(options, GL_ARRAY_BUFFER, false, false);
      },
      elements: function (options) {
        return elementState.create(options, false);
      },
      texture: textureState.create2D,
      cube: textureState.createCube,
      renderbuffer: renderbufferState.create,
      framebuffer: framebufferState.create,
      framebufferCube: framebufferState.createCube,

      // Expose context attributes
      attributes: glAttributes,

      // Frame rendering
      frame: frame,
      on: addListener,

      // System limits
      limits: limits,
      hasExtension: function (name) {
        return limits.extensions.indexOf(name.toLowerCase()) >= 0;
      },

      // Read pixels
      read: readPixels,

      // Destroy regl and all associated resources
      destroy: destroy,

      // Direct GL state manipulation
      _gl: gl,
      _refresh: refresh,

      poll: function () {
        poll();
        if (timer) {
          timer.update();
        }
      },

      // Current time
      now: now,

      // regl Statistics Information
      stats: stats$$1
    });

    config.onDone(null, regl);

    return regl;
  }

  return wrapREGL;
});


},{}],84:[function(require,module,exports){
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

/**
 * Results cache
 */

var res = '';
var cache;

/**
 * Expose `repeat`
 */

module.exports = repeat;

/**
 * Repeat the given `string` the specified `number`
 * of times.
 *
 * **Example:**
 *
 * ```js
 * var repeat = require('repeat-string');
 * repeat('A', 5);
 * //=> AAAAA
 * ```
 *
 * @param {String} `string` The string to repeat
 * @param {Number} `number` The number of times to repeat the string
 * @return {String} Repeated string
 * @api public
 */

function repeat(str, num) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }

  // cover common, quick use cases
  if (num === 1) return str;
  if (num === 2) return str + str;

  var max = str.length * num;
  if (cache !== str || typeof cache === 'undefined') {
    cache = str;
    res = '';
  } else if (res.length >= max) {
    return res.substr(0, max);
  }

  while (max > res.length && num > 1) {
    if (num & 1) {
      res += str;
    }

    num >>= 1;
    str += str;
  }

  res += str;
  res = res.substr(0, max);
  return res;
}

},{}],85:[function(require,module,exports){
(function (global){
module.exports = global.performance && global.performance.now ? function now() {
  return performance.now();
} : Date.now || function now() {
  return +new Date();
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],86:[function(require,module,exports){
module.exports = scope;
scope.replace = replace;

function scope(css, parent) {
	if (!css) return css;

	if (!parent) return css;

	css = replace(css, parent + ' $1$2');

	//regexp.escape
	let parentRe = parent.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');

	//replace self-selectors
	css = css.replace(new RegExp('(' + parentRe + ')\\s*\\1(?=[\\s\\r\\n,{])', 'g'), '$1');

	//replace `:host` with parent
	css = css.replace(new RegExp('(' + parentRe + ')\\s*:host', 'g'), '$1');

	//revoke wrongly replaced @ statements, like @supports, @import, @media etc.
	css = css.replace(new RegExp('(' + parentRe + ')\\s*@', 'g'), '@');

	return css;
}

function replace(css, replacer) {
	//strip block comments
	css = css.replace(/\/\*([\s\S]*?)\*\//g, '');

	return css.replace(/([^\r\n,{}]+)(,(?=[^}]*{)|\s*{)/g, replacer);
}

},{}],87:[function(require,module,exports){
var lowerCase = require('lower-case');

var NON_WORD_REGEXP = require('./vendor/non-word-regexp');
var CAMEL_CASE_REGEXP = require('./vendor/camel-case-regexp');
var TRAILING_DIGIT_REGEXP = require('./vendor/trailing-digit-regexp'

/**
 * Sentence case a string.
 *
 * @param  {String} str
 * @param  {String} locale
 * @param  {String} replacement
 * @return {String}
 */
);module.exports = function (str, locale, replacement) {
  if (str == null) {
    return '';
  }

  replacement = replacement || ' ';

  function replace(match, index, string) {
    if (index === 0 || index === string.length - match.length) {
      return '';
    }

    return replacement;
  }

  str = String(str
  // Support camel case ("camelCase" -> "camel Case").
  ).replace(CAMEL_CASE_REGEXP, '$1 $2'
  // Support digit groups ("test2012" -> "test 2012").
  ).replace(TRAILING_DIGIT_REGEXP, '$1 $2'
  // Remove all non-word characters and replace with a single space.
  ).replace(NON_WORD_REGEXP, replace

  // Lower case the entire string.
  );return lowerCase(str, locale);
};

},{"./vendor/camel-case-regexp":88,"./vendor/non-word-regexp":89,"./vendor/trailing-digit-regexp":90,"lower-case":67}],88:[function(require,module,exports){
module.exports = /([\u0061-\u007A\u00B5\u00DF-\u00F6\u00F8-\u00FF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A])([\u0041-\u005A\u00C0-\u00D6\u00D8-\u00DE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA\uFF21-\uFF3A\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])/g;

},{}],89:[function(require,module,exports){
module.exports = /[^\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]+/g;

},{}],90:[function(require,module,exports){
module.exports = /([\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])([^\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])/g;

},{}],91:[function(require,module,exports){
/**
 * @module settings-panel
 */
'use strict';

const Emitter = require('events').EventEmitter;
const inherits = require('inherits');
const extend = require('just-extend');
const css = require('dom-css');
const uid = require('get-uid');

const insertCss = require('insert-styles');
const isPlainObject = require('is-plain-obj');
const format = require('param-case');
const px = require('add-px-to-style');
const scopeCss = require('scope-css');

module.exports = Panel;

insertCss(".settings-panel {\r\n\tposition: relative;\r\n\t-webkit-user-select: none;\r\n\t-moz-user-select: none;\r\n\t-ms-user-select: none;\r\n\tuser-select: none;\r\n\tcursor: default;\r\n\ttext-align: left;\r\n\tbox-sizing: border-box;\r\n\tfont-family: sans-serif;\r\n\tfont-size: 1rem;\r\n\twidth: 32em;\r\n\tmax-width: 100%;\r\n\tpadding: 1em;\r\n}\r\n\r\n.settings-panel [hidden] {\r\n\tdisplay: none!important;\r\n}\r\n\r\n.settings-panel * {\r\n\tbox-sizing: border-box;\r\n}\r\n\r\n.settings-panel svg {\r\n\tfill: currentColor;\r\n\tmax-width: 100%;\r\n\tmax-height: 100%;\r\n\tdisplay: inline-block;\r\n}\r\n\r\n.settings-panel input,\r\n.settings-panel button,\r\n.settings-panel textarea,\r\n.settings-panel select {\r\n\tfont-family: inherit;\r\n\tfont-size: inherit;\r\n}\r\n\r\n.settings-panel textarea {\r\n\tmax-height: 8em;\r\n}\r\n\r\n\r\n.settings-panel a {\r\n\tcolor: inherit;\r\n}\r\n\r\n/** Basic layout */\r\n.settings-panel-field {\r\n\tposition: relative;\r\n\tpadding: .25em;\r\n\tdisplay: table;\r\n\twidth: 100%;\r\n}\r\n.settings-panel-field:last-child {\r\n\tmargin-bottom: 0;\r\n}\r\n.settings-panel-label {\r\n\tleft: 0;\r\n\tdisplay: table-cell;\r\n\tline-height: 1.2;\r\n\tvertical-align: baseline;\r\n\tpadding-top: 0;\r\n\tmax-width: 100%;\r\n}\r\n.settings-panel-input {\r\n\tdisplay: table-cell;\r\n\tvertical-align: baseline;\r\n\tposition: relative;\r\n\twhite-space: nowrap;\r\n}\r\n\r\n.settings-panel-orientation-left .settings-panel-label {\r\n\twidth: 9em;\r\n\tpadding-right: .5em;\r\n}\r\n.settings-panel-orientation-right .settings-panel-label {\r\n\tdisplay: block;\r\n\tmargin-right: 0;\r\n\tfloat: right;\r\n\twidth: 9em;\r\n\tpadding-top: .4em;\r\n\tpadding-left: .5em;\r\n}\r\n.settings-panel-orientation-right .settings-panel-label + .settings-panel-input {\r\n\tdisplay: block;\r\n\twidth: calc(100% - 9em);\r\n}\r\n.settings-panel-orientation-top .settings-panel-label {\r\n\tdisplay: block;\r\n\twidth: 100%;\r\n\tmargin-right: 0;\r\n\tpadding-top: 0;\r\n\tline-height: 1.5;\r\n}\r\n.settings-panel-orientation-top .settings-panel-label + .settings-panel-input {\r\n\tdisplay: block;\r\n\twidth: 100%;\r\n\tpadding: 0;\r\n}\r\n.settings-panel-orientation-bottom .settings-panel-label {\r\n\tdisplay: block;\r\n\twidth: 100%;\r\n\tmargin-right: 0;\r\n\tpadding: 0;\r\n\tline-height: 1.5;\r\n\tborder-top: 2.5em solid transparent;\r\n}\r\n.settings-panel-orientation-bottom .settings-panel-label + .settings-panel-input {\r\n\twidth: 100%;\r\n\tposition: absolute;\r\n\ttop: 0;\r\n}\r\n\r\n.settings-panel-orientation-left > .settings-panel-label {\r\n\twidth: 9em;\r\n\tdisplay: table-cell;\r\n}\r\n\r\n.settings-panel-title {\r\n\tfont-size: 1.6em;\r\n\tline-height: 1.25;\r\n\tmargin-top: 0;\r\n\tmargin-bottom: 0;\r\n\tpadding: .25em .25em;\r\n\ttext-align: center;\r\n}\r\n.settings-panel--collapsible .settings-panel-title {\r\n\tcursor: pointer;\r\n}\r\n.settings-panel--collapsed > *:not(.settings-panel-title) {\r\n\tdisplay: none!important;\r\n}\r\n\r\n\r\n/** Button */\r\n.settings-panel-field--button {\r\n\tdisplay: inline-block;\r\n}\r\n.settings-panel-field--button .settings-panel-input {\r\n\tdisplay: block;\r\n\ttext-align: center;\r\n}\r\n.settings-panel-button {\r\n\tvertical-align: baseline;\r\n\tline-height: 1;\r\n\tmin-height: 2em;\r\n\tpadding: .2em 1em;\r\n\twidth: 100%;\r\n\tcursor: pointer;\r\n}\r\n\r\n\r\n/** Default text and alike style */\r\n.settings-panel-text {\r\n\theight: 2em;\r\n\twidth: 100%;\r\n\tvertical-align: baseline;\r\n}\r\n.settings-panel-textarea {\r\n\twidth: 100%;\r\n\tdisplay: block;\r\n\tvertical-align: top; /* allowable as we use autoheight */\r\n\tmin-height: 2em;\r\n}\r\n\r\n/** Checkbox style */\r\n.settings-panel-field--checkbox .settings-panel-input {\r\n\tline-height: 2em;\r\n}\r\n.settings-panel-checkbox-group {\r\n\tborder: none;\r\n\t-webkit-appearance: none;\r\n\t-moz-appearance: none;\r\n\t-o-appearance: none;\r\n\tappearance: none;\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\twhite-space: normal;\r\n}\r\n.settings-panel-checkbox {\r\n\tdisplay: inline-block;\r\n\tvertical-align: middle;\r\n\twidth: 1.2em;\r\n\theight: 1.2em;\r\n\tline-height: 1.2em;\r\n\tmargin: -.15em .25em 0 0;\r\n}\r\n.settings-panel-checkbox-label {\r\n\tdisplay: inline-block;\r\n\tvertical-align: baseline;\r\n\t-webkit-user-select: none;\r\n\t-moz-user-select: none;\r\n\t-ms-user-select: none;\r\n\tuser-select: none;\r\n\tline-height: 1.2;\r\n\tmargin-right: 1em;\r\n}\r\n.settings-panel-checkbox-group .settings-panel-checkbox-label:last-child {\r\n\tmargin-right: 0;\r\n}\r\n\r\n\r\n/** Color picker style */\r\n.settings-panel-color {\r\n\tposition: relative;\r\n\twidth: 2em;\r\n\theight: 2em;\r\n\tposition: absolute;\r\n\ttop: 0;\r\n\tbottom: 0;\r\n\tmargin: auto;\r\n}\r\n.settings-panel-color-value {\r\n\twidth: 100%;\r\n\theight: 2em;\r\n\tpadding: 0 0 0 2.5em;\r\n}\r\n.settings-panel .Scp {\r\n\t-webkit-user-select: none;\r\n\t-moz-user-select: none;\r\n\t-ms-user-select: none;\r\n\tuser-select: none;\r\n\tposition: absolute;\r\n\tz-index: 10;\r\n\tcursor: pointer;\r\n\tbottom: -120px;\r\n}\r\n.settings-panel .Scp-saturation {\r\n\tposition: relative;\r\n\twidth: calc(100% - 25px);\r\n\theight: 100%;\r\n\tbackground: linear-gradient(to right, #fff 0%, #f00 100%);\r\n\tfloat: left;\r\n}\r\n.settings-panel .Scp-brightness {\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tbackground: linear-gradient(to top, #000 0%, rgba(255,255,255,0) 100%);\r\n}\r\n.settings-panel .Scp-sbSelector {\r\n\tborder: 1px solid;\r\n\tposition: absolute;\r\n\twidth: 14px;\r\n\theight: 14px;\r\n\tbackground: #fff;\r\n\tborder-radius: 10px;\r\n\ttop: -7px;\r\n\tleft: -7px;\r\n\tbox-sizing: border-box;\r\n\tz-index: 10;\r\n}\r\n.settings-panel .Scp-hue {\r\n\twidth: 20px;\r\n\theight: 100%;\r\n\tposition: relative;\r\n\tfloat: left;\r\n\tbackground: linear-gradient(to bottom, #f00 0%, #f0f 17%, #00f 34%, #0ff 50%, #0f0 67%, #ff0 84%, #f00 100%);\r\n}\r\n.settings-panel .Scp-hSelector {\r\n\tposition: absolute;\r\n\tbackground: #fff;\r\n\tborder-bottom: 1px solid #000;\r\n\tright: -3px;\r\n\twidth: 10px;\r\n\theight: 2px;\r\n}\r\n\r\n\r\n\r\n/** Interval style */\r\n.settings-panel-interval {\r\n\tposition: relative;\r\n\t-webkit-appearance: none;\r\n\tdisplay: inline-block;\r\n\tvertical-align: top;\r\n\theight: 2em;\r\n\tmargin: 0px 0;\r\n\twidth: 70%;\r\n\tbackground: #ddd;\r\n\tcursor: ew-resize;\r\n\t-webkit-touch-callout: none;\r\n\t-webkit-user-select: none;\r\n\t-khtml-user-select: none;\r\n\t-moz-user-select: none;\r\n\t-ms-user-select: none;\r\n\tuser-select: none;\r\n}\r\n.settings-panel-interval-handle {\r\n\tbackground: #7a4;\r\n\tposition: absolute;\r\n\ttop: 0;\r\n\tbottom: 0;\r\n\tmin-width: 1px;\r\n}\r\n.settings-panel.settings-panel-interval-dragging * {\r\n\t-webkit-touch-callout: none !important;\r\n\t-webkit-user-select: none !important;\r\n\t-khtml-user-select: none !important;\r\n\t-moz-user-select: none !important;\r\n\t-ms-user-select: none !important;\r\n\tuser-select: none !important;\r\n\r\n\tcursor: ew-resize !important;\r\n}\r\n\r\n.settings-panel-interval + .settings-panel-value {\r\n\tright: 0;\r\n\tpadding-left: .5em;\r\n}\r\n\r\n\r\n\r\n/** Select style */\r\n.settings-panel-select {\r\n\tdisplay: inline-block;\r\n\twidth: 100%;\r\n\theight: 2em;\r\n\tvertical-align: baseline;\r\n}\r\n\r\n/** Value style */\r\n.settings-panel-value {\r\n\t-webkit-appearance: none;\r\n\t-moz-appearance: none;\r\n\t-o-appearance: none;\r\n\tappearance: none;\r\n\tmin-width: 3em;\r\n\tpadding: 0 0 0 0em;\r\n\tdisplay: inline-block;\r\n\tvertical-align: baseline;\r\n\tcursor: text;\r\n\theight: 2em;\r\n\tborder: none;\r\n\tborder-radius: 0;\r\n\toutline: none;\r\n\tfont-family: inherit;\r\n\tbackground: none;\r\n\tcolor: inherit;\r\n\twidth: 15%;\r\n}\r\n.settings-panel-value:focus {\r\n\toutline: 0;\r\n\tbox-shadow: 0;\r\n}\r\n.settings-panel-value-tip {\r\n\tdisplay: none;\r\n}\r\n\r\n/** Range style */\r\n.settings-panel-range {\r\n\twidth: 85%;\r\n\tpadding: 0;\r\n\tmargin: 0px 0;\r\n\theight: 2em;\r\n\tvertical-align: top;\r\n}\r\n.settings-panel-range + .settings-panel-value {\r\n\tpadding-left: .5em;\r\n\twidth: 15%;\r\n}\r\n\r\n.settings-panel-switch {\r\n\t-webkit-appearance: none;\r\n\t-moz-appearance: none;\r\n\tappearance: none;\r\n\tborder: none;\r\n\tdisplay: block;\r\n\tvertical-align: baseline;\r\n\tpadding: 0;\r\n\tmargin: 0;\r\n\tline-height: 2em;\r\n}\r\n.settings-panel-switch-input {\r\n\tmargin: 0;\r\n\tvertical-align: middle;\r\n\twidth: 1.2em;\r\n\theight: 1.2em;\r\n\tcursor: pointer;\r\n\tmargin-right: .25em;\r\n}\r\n.settings-panel-switch-label {\r\n\tdisplay: inline-block;\r\n\tvertical-align: baseline;\r\n\tline-height: 1.2;\r\n\tmargin-right: 1em;\r\n}\r\n\r\n\r\n.settings-panel hr {\r\n\tborder: none;\r\n\theight: 0;\r\n\tmargin: .5em 0;\r\n\tborder-bottom: 1px dotted;\r\n}\r\n\r\n.settings-panel-field--disabled {\r\n\topacity: .5;\r\n\tpointer-events: none;\r\n}\r\n");

/**
 * @constructor
 */
function Panel(items, opts) {
	if (!(this instanceof Panel)) return new Panel(items, opts);

	extend(this, opts);

	//ensure container
	if (this.container === undefined) this.container = document.body || document.documentElement;

	this.container.classList.add('settings-panel-container');

	//create element
	if (!this.id) this.id = uid();
	this.element = document.createElement('div');
	this.element.className = 'settings-panel settings-panel-' + this.id;
	if (this.className) this.element.className += ' ' + this.className;

	//create title
	if (this.title) {
		this.titleEl = this.element.appendChild(document.createElement('h2'));
		this.titleEl.className = 'settings-panel-title';
	}

	//create collapse button
	if (this.collapsible && this.title) {
		// this.collapseEl = this.element.appendChild(document.createElement('div'));
		// this.collapseEl.className = 'settings-panel-collapse';
		this.element.classList.add('settings-panel--collapsible');
		this.titleEl.addEventListener('click', () => {
			if (this.collapsed) {
				this.collapsed = false;
				this.element.classList.remove('settings-panel--collapsed');
			} else {
				this.collapsed = true;
				this.element.classList.add('settings-panel--collapsed');
			}
		});
	}

	//state is values of items
	this.state = {};

	//items is all items settings
	this.items = {};

	//create fields
	this.set(items);

	if (this.container) {
		this.container.appendChild(this.element);
	}

	//create theme style
	this.update();
}

inherits(Panel, Emitter);

/**
 * Set item value/options
 */
Panel.prototype.set = function (name, value) {
	//handle list of properties
	if (Array.isArray(name)) {
		let items = name;
		items.forEach(item => {
			this.set(item.id || item.label, item);
		});

		return this;
	}

	//handle plain object
	if (isPlainObject(name)) {
		let items = name;
		let list = [];
		for (let key in items) {
			if (!isPlainObject(items[key])) {
				items[key] = { value: items[key] };
			}
			if (items[key].id == null) items[key].id = key;
			list.push(items[key]);
		}
		list = list.sort((a, b) => (a.order || 0) - (b.order || 0));

		return this.set(list);
	}

	//format name
	name = name || '';
	name = name.replace(/\-/g, 'dash-');
	name = format(name);

	if (name) {
		var item = this.items[name];
		if (!item) item = this.items[name] = { id: name, panel: this };
	}
	//noname items should not be saved in state
	else {
			var item = { id: null, panel: this };
		}

	var initialValue = item.value;
	var isBefore = item.before;
	var isAfter = item.after;

	if (isPlainObject(value)) {
		item = extend(item, value);
	} else {
		//ignore nothing-changed set
		if (value === item.value && value !== undefined) return this;
		item.value = value;
	}

	if (item.value === undefined) item.value = item.default;

	if (name) this.state[name] = item.value;

	//define label via name
	if (item.label === undefined && item.id) {
		item.label = item.id;
	}

	//detect type
	if (!item.type) {
		if (item.value && Array.isArray(item.value)) {
			if (typeof item.value[0] === 'string') {
				item.type = 'checkbox';
			} else {
				item.type = 'interval';
			}
		} else if (item.scale || item.max || item.steps || item.step || typeof item.value === 'number') {
			item.type = 'range';
		} else if (item.options) {
			if (Array.isArray(item.options) && item.options.join('').length < 90) {
				item.type = 'switch';
			} else {
				item.type = 'select';
			}
		} else if (item.format) {
			item.type = 'color';
		} else if (typeof item.value === 'boolean') {
			item.type = 'checkbox';
		} else if (item.content != null) {
			item.type = 'raw';
		} else {
			if (item.value && (item.value.length > 140 || /\n/.test(item.value))) {
				item.type = 'textarea';
			} else {
				item.type = 'text';
			}
		}
	}

	var field, fieldId;

	if (item.id != null) {
		fieldId = 'settings-panel-field-' + item.id;
		field = this.element.querySelector('#' + fieldId);
	}

	//create field container
	if (!field) {
		field = document.createElement('div');
		if (fieldId != null) field.id = fieldId;
		this.element.appendChild(field);
		item.field = field;
	} else {
		//clean previous before/after
		if (isBefore) {
			this.element.removeChild(field.prevSibling);
		}
		if (isAfter) {
			this.element.removeChild(field.nextSibling);
		}
	}

	field.className = 'settings-panel-field settings-panel-field--' + item.type;

	if (item.orientation) field.className += ' settings-panel-orientation-' + item.orientation;

	if (item.className) field.className += ' ' + item.className;

	if (item.style) {
		if (isPlainObject(item.style)) {
			css(field, item.style);
		} else if (typeof item.style === 'string') {
			field.style.cssText = item.style;
		}
	} else if (item.style !== undefined) {
		field.style = null;
	}

	if (item.hidden) {
		field.setAttribute('hidden', true);
	} else {
		field.removeAttribute('hidden');
	}

	//createe container for the input
	let inputContainer = field.querySelector('.settings-panel-input');

	if (!inputContainer) {
		inputContainer = document.createElement('div');
		inputContainer.className = 'settings-panel-input';
		item.container = inputContainer;
		field.appendChild(inputContainer);
	}

	if (item.disabled) field.className += ' settings-panel-field--disabled';

	let components = this.components;
	let component = item.component;

	if (!component) {
		item.component = component = (components[item.type] || components.text)(item);

		if (component.on) {
			component.on('init', data => {
				item.value = data;
				if (item.id) this.state[item.id] = item.value;
				let state = extend({}, this.state);

				item.init && item.init(data, state);
				this.emit('init', item.id, data, state);
				item.change && item.change(data, state);
				this.emit('change', item.id, data, state);
			});

			component.on('input', data => {
				item.value = data;
				if (item.id) this.state[item.id] = item.value;
				let state = extend({}, this.state);

				item.input && item.input(data, state);
				this.emit('input', item.id, data, state);
				item.change && item.change(data, state);
				this.emit('change', item.id, data, state);
			});

			component.on('action', () => {
				let state = extend({}, this.state);
				item.action && item.action(state);
			});

			component.on('change', data => {
				item.value = data;
				if (item.id) this.state[item.id] = item.value;
				let state = extend({}, this.state);

				item.change && item.change(data, state);
				this.emit('change', item.id, data, state);
			});
		}
	} else {
		component.update(item);
	}

	//create field label
	if (component.label !== false && (item.label || item.label === '')) {
		let label = field.querySelector('.settings-panel-label');
		if (!label) {
			label = document.createElement('label');
			label.className = 'settings-panel-label';
			field.insertBefore(label, inputContainer);
		}

		label.htmlFor = item.id;
		label.innerHTML = item.label;
		label.title = item.title || item.label;
	}

	//handle after and before
	// if (item.before) {
	// 	let before = item.before;
	// 	if (before instanceof Function) {
	// 		before = item.before.call(item, component);
	// 	}
	// 	if (before instanceof HTMLElement) {
	// 		this.element.insertBefore(before, field);
	// 	}
	// 	else {
	// 		field.insertAdjacentHTML('beforebegin', before);
	// 	}
	// }
	// if (item.after) {
	// 	let after = item.after;
	// 	if (after instanceof Function) {
	// 		after = item.after.call(item, component);
	// 	}
	// 	if (after instanceof HTMLElement) {
	// 		this.element.insertBefore(after, field.nextSibling);
	// 	}
	// 	else {
	// 		field.insertAdjacentHTML('afterend', after);
	// 	}
	// }

	//emit change
	if (initialValue !== item.value) {
		this.emit('change', item.id, item.value, this.state);
	}

	return this;
};

/**
 * Return property value or a list
 */
Panel.prototype.get = function (name) {
	if (name == null) return this.state;
	return this.state[name];
};

/**
 * Update theme
 */
Panel.prototype.update = function (opts) {
	extend(this, opts);

	//FIXME: decide whether we have to reset these params
	// if (opts && opts.theme) {
	// 	if (opts.theme.fontSize) this.fontSize = opts.theme.fontSize;
	// 	if (opts.theme.inputHeight) this.inputHeight = opts.theme.inputHeight;
	// 	if (opts.theme.fontFamily) this.fontFamily = opts.theme.fontFamily;
	// 	if (opts.theme.labelWidth) this.labelWidth = opts.theme.labelWidth;
	// 	if (opts.theme.palette) this.palette = opts.theme.palette;
	// }

	//update title, if any
	if (this.titleEl) this.titleEl.innerHTML = this.title;

	//update orientation
	this.element.classList.remove('settings-panel-orientation-top');
	this.element.classList.remove('settings-panel-orientation-bottom');
	this.element.classList.remove('settings-panel-orientation-left');
	this.element.classList.remove('settings-panel-orientation-right');
	this.element.classList.add('settings-panel-orientation-' + this.orientation);

	//apply style
	let cssStr = '';
	if (this.theme instanceof Function) {
		cssStr = this.theme.call(this, this);
	} else if (typeof this.theme === 'string') {
		cssStr = this.theme;
	}

	//append extra css
	if (this.css) {
		if (this.css instanceof Function) {
			cssStr += this.css.call(this, this);
		} else if (typeof this.css === 'string') {
			cssStr += this.css;
		}
	}

	//scope each rule
	cssStr = scopeCss(cssStr || '', '.settings-panel-' + this.id) || '';

	insertCss(cssStr.trim(), {
		id: this.id
	});

	if (this.style) {
		if (isPlainObject(this.style)) {
			css(this.element, this.style);
		} else if (typeof this.style === 'string') {
			this.element.style.cssText = this.style;
		}
	} else if (this.style !== undefined) {
		this.element.style = null;
	}

	return this;
};

//instance theme
Panel.prototype.theme = require('./theme/none');

/**
 * Registered components
 */
Panel.prototype.components = {
	range: require('./src/range'),

	button: require('./src/button'),
	text: require('./src/text'),
	textarea: require('./src/textarea'),

	checkbox: require('./src/checkbox'),
	toggle: require('./src/checkbox'),

	switch: require('./src/switch'),

	color: require('./src/color'),

	interval: require('./src/interval'),
	multirange: require('./src/interval'),

	custom: require('./src/custom'),
	raw: require('./src/custom'),

	select: require('./src/select')
};

/**
 * Additional class name
 */
Panel.prototype.className;

/**
 * Additional visual setup
 */
Panel.prototype.orientation = 'left';

/** Display collapse button */
Panel.prototype.collapsible = false;

},{"./src/button":92,"./src/checkbox":93,"./src/color":94,"./src/custom":95,"./src/interval":96,"./src/range":97,"./src/select":98,"./src/switch":99,"./src/text":100,"./src/textarea":101,"./theme/none":103,"add-px-to-style":12,"dom-css":31,"events":39,"get-uid":44,"inherits":48,"insert-styles":50,"is-plain-obj":54,"just-extend":55,"param-case":76,"scope-css":86}],92:[function(require,module,exports){
'use strict';

const EventEmitter = require('events').EventEmitter;
const inherits = require('inherits');

module.exports = Button;
inherits(Button, EventEmitter);

function Button(opts) {
	if (!(this instanceof Button)) return new Button(opts);

	var input = opts.container.querySelector('.settings-panel-button');
	if (!input) {
		this.element = input = opts.container.appendChild(document.createElement('button'));
		input.className = 'settings-panel-button';
		input.addEventListener('click', e => {
			e.preventDefault();
			this.emit('input');
			this.emit('action');
		});
	}

	this.update(opts);
}

Button.prototype.update = function (opts) {
	this.element.innerHTML = opts.value || opts.label;
	return this;
};

Button.prototype.label = false;

},{"events":39,"inherits":48}],93:[function(require,module,exports){
'use strict';

const EventEmitter = require('events').EventEmitter;
const inherits = require('inherits');
const format = require('param-case');
const extend = require('just-extend');

module.exports = Checkbox;
inherits(Checkbox, EventEmitter);

function Checkbox(opts) {
	if (!(this instanceof Checkbox)) return new Checkbox(opts);

	var that = this;

	if (!this.group) {
		this.group = document.createElement('fieldset');
		this.group.className = 'settings-panel-checkbox-group';
		opts.container.appendChild(this.group);
	}

	//detect multiple options from array value
	if (!opts.options && Array.isArray(opts.value)) {
		opts.options = opts.value;
	}

	//single checkbox
	if (!opts.options) {
		let input = this.group.querySelector('.settings-panel-checkbox');
		let label = this.group.querySelector('.settings-panel-checkbox-label');
		if (!input) {
			this.element = input = this.group.appendChild(document.createElement('input'));
			input.className = 'settings-panel-checkbox';
			this.labelEl = label = this.group.appendChild(document.createElement('label'));
			this.labelEl.innerHTML = '&nbsp;';
			label.className = 'settings-panel-checkbox-label';
			input.onchange = function (data) {
				that.emit('input', data.target.checked);
			};
			setTimeout(function () {
				that.emit('init', input.checked);
			});
		}
	}
	//multiple checkboxes
	else {
			var html = '';

			if (Array.isArray(opts.options)) {
				for (let i = 0; i < opts.options.length; i++) {
					let option = opts.options[i];
					html += createOption(option, option);
				}
			} else {
				for (let key in opts.options) {
					html += createOption(opts.options[key], key);
				}
			}

			this.group.innerHTML = html;

			this.group.addEventListener('change', () => {
				this.emit('input', getState());
			});
			setTimeout(() => {
				this.emit('init', getState());
			});
		}

	function getState() {
		let v = [];
		[].slice.call(that.group.querySelectorAll('.settings-panel-checkbox')).forEach(el => {
			if (el.checked) v.push(el.getAttribute('data-value'));
		});
		return v;
	}

	function createOption(label, value) {
		let htmlFor = `settings-panel-${format(opts.panel.id)}-${format(opts.id)}-input-${format(value)}`;

		let html = `<input type="checkbox" class="settings-panel-checkbox" ${value === opts.value ? 'checked' : ''} id="${htmlFor}" name="${format(opts.id)}" data-value="${value}" title="${value}"/><label for="${htmlFor}" class="settings-panel-checkbox-label" title="${value}">${label}</label>`;
		return html;
	}

	this.update(opts);
}

Checkbox.prototype.update = function (opts) {
	extend(this, opts);

	if (!this.options) {
		this.labelEl.htmlFor = this.id;
		this.element.id = this.id;
		this.element.type = 'checkbox';
		this.element.checked = !!this.value;
	} else {
		if (!Array.isArray(this.value)) this.value = [this.value];
		let els = [].slice.call(this.group.querySelectorAll('.settings-panel-checkbox'));
		els.forEach(el => {
			if (this.value.indexOf(el.getAttribute('data-value')) >= 0) {
				el.checked = true;
			} else {
				el.checked = false;
			}
		});
	}

	this.group.disabled = !!this.disabled;

	return this;
};

},{"events":39,"inherits":48,"just-extend":55,"param-case":76}],94:[function(require,module,exports){
'use strict';

const EventEmitter = require('events').EventEmitter;
const ColorPicker = require('simple-color-picker');
const inherits = require('inherits');
const css = require('dom-css');
const tinycolor = require('tinycolor2');
const formatParam = require('param-case');
const num = require('input-number');

module.exports = Color;
inherits(Color, EventEmitter);

function Color(opts) {
	if (!(this instanceof Color)) return new Color(opts);

	this.update(opts);
}

Color.prototype.update = function (opts) {
	opts.container.innerHTML = '';

	opts = opts || {};
	opts.format = opts.format || 'rgb';
	opts.value = opts.value || '#123456';
	var icon = opts.container.appendChild(document.createElement('div')
	//FIXME: this needed to make el vertical-aligned by baseline
	);icon.innerHTML = '&nbsp;';
	icon.className = 'settings-panel-color';

	var valueInput = opts.container.appendChild(document.createElement('input'));
	valueInput.id = opts.id;
	valueInput.className = 'settings-panel-color-value';
	num(valueInput);
	valueInput.onchange = () => {
		picker.setColor(valueInput.value);
	};
	valueInput.oninput = () => {
		picker.setColor(valueInput.value);
	};

	if (opts.readonly) {
		valueInput.setAttribute('readonly', true);
	}

	var initial = opts.value;
	switch (opts.format) {
		case 'rgb':
			initial = tinycolor(initial).toHexString();
			break;
		case 'hex':
			initial = tinycolor(initial).toHexString();
			break;
		case 'array':
			initial = tinycolor.fromRatio({ r: initial[0], g: initial[1], b: initial[2] }).toHexString();
			break;
		default:
			break;
	}

	var picker = new ColorPicker({
		el: icon,
		color: initial,
		width: 160,
		height: 120
	});

	picker.$el.style.display = 'none';

	if (!opts.readonly) {
		icon.onmouseover = function () {
			picker.$el.style.display = '';
		};
		icon.onmouseout = e => {
			picker.$el.style.display = 'none';
		};
	}

	setTimeout(() => {
		this.emit('init', initial);
	});

	picker.onChange(hex => {
		let v = format(hex);
		if (v !== valueInput.value) valueInput.value = v;
		css(icon, { backgroundColor: hex });
		this.emit('input', format(hex));
	});

	function format(hex) {
		switch (opts.format) {
			case 'rgb':
				return tinycolor(hex).toRgbString();
			case 'hex':
				return tinycolor(hex).toHexString();
			case 'array':
				var rgb = tinycolor(hex).toRgb();
				return [rgb.r / 255, rgb.g / 255, rgb.b / 255].map(function (x) {
					return x.toFixed(2);
				});
			default:
				return hex;
		}
	};

	return this;
};

},{"dom-css":31,"events":39,"inherits":48,"input-number":49,"param-case":76,"simple-color-picker":104,"tinycolor2":109}],95:[function(require,module,exports){
/**
 * @module  settings-panel/src/custom
 *
 * A custom html component
 */

'use strict';

const EventEmitter = require('events').EventEmitter;
const inherits = require('inherits');
const extend = require('just-extend');

module.exports = Custom;
inherits(Custom, EventEmitter);

function Custom(opts) {
	if (!(this instanceof Custom)) return new Custom(opts);

	//FIXME: these guys force unnecessary events, esp if element returns wrong value
	// opts.container.addEventListener('input', (e) => {
	// 	this.emit('input', e.target.value);
	// });
	// opts.container.addEventListener('change', (e) => {
	// 	this.emit('change', e.target.value);
	// });

	this.update(opts);
}

Custom.prototype.update = function (opts) {
	extend(this, opts);
	var el = this.content;
	if (this.content instanceof Function) {
		el = this.content(this);
		if (!el) return;

		if (typeof el === 'string') {
			this.container.innerHTML = el;
		} else if (!this.container.contains(el)) {
			this.container.appendChild(el);
		}
	} else if (typeof this.content === 'string') {
		this.container.innerHTML = el;
	} else if (this.content instanceof Element && !this.container.contains(el)) {
		this.container.appendChild(el);
	} else {
		//empty content is allowable, in case if user wants to show only label for example
		// throw Error('`content` should be a function returning html element or string');
	}
};

},{"events":39,"inherits":48,"just-extend":55}],96:[function(require,module,exports){
'use strict';

const isNumeric = require('is-numeric');
const css = require('dom-css');
const isMobile = require('is-mobile')();
const format = require('param-case');
const clamp = require('mumath/clamp');
const EventEmitter = require('events').EventEmitter;
const inherits = require('inherits');
const precision = require('mumath/precision');

module.exports = Range;

inherits(Range, EventEmitter);

function Range(opts) {
	if (!(this instanceof Range)) return new Range(opts);

	this.update(opts);
}

Range.prototype.update = function (opts) {
	var self = this;
	var scaleValue, scaleValueInverse, logmin, logmax, logsign, input, handle, panel;

	if (!!opts.step && !!opts.steps) {
		throw new Error('Cannot specify both step and steps. Got step = ' + opts.step + ', steps = ', opts.steps);
	}

	opts.container.innerHTML = '';

	if (opts.step) {
		var prec = precision(opts.step) || 1;
	} else {
		var prec = precision((opts.max - opts.min) / opts.steps) || 1;
	}

	// Create scale functions for converting to/from the desired scale:
	if (opts.scale === 'log' || opts.log) {
		scaleValue = function (x) {
			return logsign * Math.exp(Math.log(logmin) + (Math.log(logmax) - Math.log(logmin)) * x / 100);
		};
		scaleValueInverse = function (y) {
			return (Math.log(y * logsign) - Math.log(logmin)) * 100 / (Math.log(logmax) - Math.log(logmin));
		};
	} else {
		scaleValue = scaleValueInverse = function (x) {
			return x;
		};
	}

	if (!Array.isArray(opts.value)) {
		opts.value = [];
	}
	if (opts.scale === 'log' || opts.log) {
		// Get options or set defaults:
		opts.max = isNumeric(opts.max) ? opts.max : 100;
		opts.min = isNumeric(opts.min) ? opts.min : 0.1;

		// Check if all signs are valid:
		if (opts.min * opts.max <= 0) {
			throw new Error('Log range min/max must have the same sign and not equal zero. Got min = ' + opts.min + ', max = ' + opts.max);
		} else {
			// Pull these into separate variables so that opts can define the *slider* mapping
			logmin = opts.min;
			logmax = opts.max;
			logsign = opts.min > 0 ? 1 : -1;

			// Got the sign so force these positive:
			logmin = Math.abs(logmin);
			logmax = Math.abs(logmax

			// These are now simply 0-100 to which we map the log range:
			);opts.min = 0;
			opts.max = 100;

			// Step is invalid for a log range:
			if (isNumeric(opts.step)) {
				throw new Error('Log may only use steps (integer number of steps), not a step value. Got step =' + opts.step);
			}
			// Default step is simply 1 in linear slider space:
			opts.step = 1;
		}

		opts.value = [scaleValueInverse(isNumeric(opts.value[0]) ? opts.value[0] : scaleValue(opts.min + (opts.max - opts.min) * 0.25)), scaleValueInverse(isNumeric(opts.value[1]) ? opts.value[1] : scaleValue(opts.min + (opts.max - opts.min) * 0.75))];

		if (scaleValue(opts.value[0]) * scaleValue(opts.max) <= 0 || scaleValue(opts.value[1]) * scaleValue(opts.max) <= 0) {
			throw new Error('Log range initial value must have the same sign as min/max and must not equal zero. Got initial value = [' + scaleValue(opts.value[0]) + ', ' + scaleValue(opts.value[1]) + ']');
		}
	} else {
		// If linear, this is much simpler:
		opts.max = isNumeric(opts.max) ? opts.max : 100;
		opts.min = isNumeric(opts.min) ? opts.min : 0;
		opts.step = isNumeric(opts.step) ? opts.step : (opts.max - opts.min) / 100;

		opts.value = [isNumeric(opts.value[0]) ? opts.value[0] : (opts.min + opts.max) * 0.25, isNumeric(opts.value[1]) ? opts.value[1] : (opts.min + opts.max) * 0.75];
	}

	// If we got a number of steps, use that instead:
	if (isNumeric(opts.steps)) {
		opts.step = isNumeric(opts.steps) ? (opts.max - opts.min) / opts.steps : opts.step;
	}

	// Quantize the initial value to the requested step:
	opts.value[0] = opts.min + opts.step * Math.round((opts.value[0] - opts.min) / opts.step);
	opts.value[1] = opts.min + opts.step * Math.round((opts.value[1] - opts.min) / opts.step

	//create DOM
	);var lValue = require('./value')({
		container: opts.container,
		value: scaleValue(opts.value[0]).toFixed(prec),
		type: 'text',
		left: true,
		disabled: opts.disabled,
		id: opts.id,
		className: 'settings-panel-interval-value settings-panel-interval-value--left',
		input: v => {
			//TODO
		}
	});

	panel = opts.container.parentNode;

	input = opts.container.appendChild(document.createElement('span'));
	input.id = 'settings-panel-interval';
	input.className = 'settings-panel-interval';

	handle = document.createElement('span');
	handle.className = 'settings-panel-interval-handle';
	handle.value = 50;
	handle.min = 0;
	handle.max = 50;
	input.appendChild(handle);

	var value = opts.value;

	// Display the values:
	var rValue = require('./value')({
		container: opts.container,
		disabled: opts.disabled,
		value: scaleValue(opts.value[1]).toFixed(prec),
		type: 'text',
		className: 'settings-panel-interval-value settings-panel-interval-value--right',
		input: v => {
			//TODO
		}
	});

	function setHandleCSS() {
		let left = (value[0] - opts.min) / (opts.max - opts.min) * 100;
		let right = 100 - (value[1] - opts.min) / (opts.max - opts.min) * 100;
		css(handle, {
			left: left + '%',
			width: 100 - left - right + '%'
		});
		opts.container.style.setProperty('--low', left + '%');
		opts.container.style.setProperty('--high', 100 - right + '%');
		lValue.style.setProperty('--value', left + '%');
		rValue.style.setProperty('--value', 100 - right + '%');
	}

	// Initialize CSS:
	setHandleCSS
	// An index to track what's being dragged:
	();var activeIndex = -1;

	function mouseX(ev) {
		// Get mouse/touch position in page coords relative to the container:
		return (ev.touches && ev.touches[0] || ev).pageX - input.getBoundingClientRect().left;
	}

	function setActiveValue(fraction) {
		if (activeIndex === -1) {
			return;
		}

		// Get the position in the range [0, 1]:
		var lofrac = (value[0] - opts.min) / (opts.max - opts.min);
		var hifrac = (value[1] - opts.min) / (opts.max - opts.min);

		// Clip against the other bound:
		if (activeIndex === 0) {
			fraction = Math.min(hifrac, fraction);
		} else {
			fraction = Math.max(lofrac, fraction);
		}

		// Compute and quantize the new value:
		var newValue = opts.min + Math.round((opts.max - opts.min) * fraction / opts.step) * opts.step;

		// Update value, in linearized coords:
		value[activeIndex] = newValue;

		// Update and send the event:
		setHandleCSS();
		input.oninput();
	}

	var mousemoveListener = function (ev) {
		if (ev.target === input || ev.target === handle) ev.preventDefault();

		var fraction = clamp(mouseX(ev) / input.offsetWidth, 0, 1);

		setActiveValue(fraction);
	};

	var mouseupListener = function (ev) {
		panel.classList.remove('settings-panel-interval-dragging');

		document.removeEventListener(isMobile ? 'touchmove' : 'mousemove', mousemoveListener);
		document.removeEventListener(isMobile ? 'touchend' : 'mouseup', mouseupListener);

		activeIndex = -1;
	};

	input.addEventListener(isMobile ? 'touchstart' : 'mousedown', function (ev) {
		// Tweak control to make dragging experience a little nicer:
		panel.classList.add('settings-panel-interval-dragging'

		// Get mouse position fraction:
		);var fraction = clamp(mouseX(ev) / input.offsetWidth, 0, 1

		// Get the current fraction of position --> [0, 1]:
		);var lofrac = (value[0] - opts.min) / (opts.max - opts.min);
		var hifrac = (value[1] - opts.min) / (opts.max - opts.min);

		// This is just for making decisions, so perturb it ever
		// so slightly just in case the bounds are numerically equal:
		lofrac -= Math.abs(opts.max - opts.min) * 1e-15;
		hifrac += Math.abs(opts.max - opts.min) * 1e-15;

		// Figure out which is closer:
		var lodiff = Math.abs(lofrac - fraction);
		var hidiff = Math.abs(hifrac - fraction);

		activeIndex = lodiff < hidiff ? 0 : 1;

		// Attach this to *document* so that we can still drag if the mouse
		// passes outside the container:
		document.addEventListener(isMobile ? 'touchmove' : 'mousemove', mousemoveListener);
		document.addEventListener(isMobile ? 'touchend' : 'mouseup', mouseupListener);
	});

	setTimeout(() => {
		var scaledLValue = scaleValue(value[0]);
		var scaledRValue = scaleValue(value[1]);
		lValue.value = scaledLValue.toFixed(prec);
		rValue.value = scaledRValue.toFixed(prec);
		this.emit('init', [scaledLValue, scaledRValue]);
	});

	input.oninput = () => {
		var scaledLValue = scaleValue(value[0]);
		var scaledRValue = scaleValue(value[1]);
		lValue.value = scaledLValue.toFixed(prec);
		rValue.value = scaledRValue.toFixed(prec);
		this.emit('input', [scaledLValue, scaledRValue]);
	};

	return this;
};

},{"./value":102,"dom-css":31,"events":39,"inherits":48,"is-mobile":51,"is-numeric":53,"mumath/clamp":70,"mumath/precision":71,"param-case":76}],97:[function(require,module,exports){
'use strict';

const EventEmitter = require('events').EventEmitter;
const inherits = require('inherits');
const isNumeric = require('is-numeric');
const css = require('dom-css');
const format = require('param-case');
const precision = require('mumath/precision');

module.exports = Range;
inherits(Range, EventEmitter);

function Range(opts) {
	if (!(this instanceof Range)) return new Range(opts);

	this.update(opts);
}

Range.prototype.update = function (opts) {
	var scaleValue, scaleValueInverse, logmin, logmax, logsign;

	if (!!opts.step && !!opts.steps) {
		throw new Error('Cannot specify both step and steps. Got step = ' + opts.step + ', steps = ', opts.steps);
	}

	opts.container.innerHTML = '';

	if (!opts.container) opts.container = document.body;

	var input = opts.container.querySelector('.settings-panel-range');

	if (!input) {
		input = opts.container.appendChild(document.createElement('input'));
		input.type = 'range';
		input.className = 'settings-panel-range';
	}

	if (opts.disabled) input.disabled = true;

	if (opts.log) opts.scale = 'log';

	// Create scale functions for converting to/from the desired scale:
	if (opts.scale === 'log') {
		scaleValue = function (x) {
			return logsign * Math.exp(Math.log(logmin) + (Math.log(logmax) - Math.log(logmin)) * x / 100);
		};
		scaleValueInverse = function (y) {
			return (Math.log(y * logsign) - Math.log(logmin)) * 100 / (Math.log(logmax) - Math.log(logmin));
		};
	} else {
		scaleValue = scaleValueInverse = function (x) {
			return x;
		};
	}

	// Get initial value:
	if (opts.scale === 'log') {
		// Get options or set defaults:
		opts.max = isNumeric(opts.max) ? opts.max : 100;
		opts.min = isNumeric(opts.min) ? opts.min : 0.1;

		// Check if all signs are valid:
		if (opts.min * opts.max <= 0) {
			throw new Error('Log range min/max must have the same sign and not equal zero. Got min = ' + opts.min + ', max = ' + opts.max);
		} else {
			// Pull these into separate variables so that opts can define the *slider* mapping
			logmin = opts.min;
			logmax = opts.max;
			logsign = opts.min > 0 ? 1 : -1;

			// Got the sign so force these positive:
			logmin = Math.abs(logmin);
			logmax = Math.abs(logmax

			// These are now simply 0-100 to which we map the log range:
			);opts.min = 0;
			opts.max = 100;

			// Step is invalid for a log range:
			if (isNumeric(opts.step)) {
				throw new Error('Log may only use steps (integer number of steps), not a step value. Got step =' + opts.step);
			}
			// Default step is simply 1 in linear slider space:
			opts.step = 1;
		}

		opts.value = scaleValueInverse(isNumeric(opts.value) ? opts.value : scaleValue((opts.min + opts.max) * 0.5));

		if (opts.value * scaleValueInverse(opts.max) <= 0) {
			throw new Error('Log range initial value must have the same sign as min/max and must not equal zero. Got initial value = ' + opts.value);
		}
	} else {
		// If linear, this is much simpler:
		opts.max = isNumeric(opts.max) ? opts.max : 100;
		opts.min = isNumeric(opts.min) ? opts.min : 0;
		opts.step = isNumeric(opts.step) ? opts.step : (opts.max - opts.min) / 100;

		opts.value = isNumeric(opts.value) ? opts.value : (opts.min + opts.max) * 0.5;
	}

	// If we got a number of steps, use that instead:
	if (isNumeric(opts.steps)) {
		opts.step = isNumeric(opts.steps) ? (opts.max - opts.min) / opts.steps : opts.step;
	}

	// Quantize the initial value to the requested step:
	var initialStep = Math.round((opts.value - opts.min) / opts.step);
	opts.value = opts.min + opts.step * initialStep;

	//preser container data for display
	opts.container.setAttribute('data-min', opts.min);
	opts.container.setAttribute('data-max', opts.max);

	if (opts.scale === 'log') {
		//FIXME: not every log is of precision 3
		var prec = opts.precision != null ? opts.precision : 3;
	} else {
		if (opts.step) {
			var prec = opts.precision != null ? opts.precision : precision(opts.step);
		} else if (opts.steps) {
			var prec = opts.precision != null ? opts.precision : precision((opts.max - opts.min) / opts.steps);
		}
	}

	var value = require('./value')({
		id: opts.id,
		container: opts.container,
		className: 'settings-panel-range-value',
		value: scaleValue(opts.value).toFixed(prec),
		type: opts.scale === 'log' ? 'text' : 'number',
		min: scaleValue(opts.min),
		max: scaleValue(opts.max),
		disabled: opts.disabled,
		//FIXME: step here might vary
		step: opts.step,
		input: v => {
			let scaledValue = scaleValueInverse(v);
			input.value = scaledValue;
			value.title = input.value;
			// value.value = v
			this.emit('input', v);
			input.setAttribute('value', scaledValue.toFixed(0));
			opts.container.style.setProperty('--value', scaledValue + '%');
			opts.container.style.setProperty('--coef', scaledValue / 100);
		}
	});

	// Set value on the input itself:
	input.min = opts.min;
	input.max = opts.max;
	input.step = opts.step;
	input.value = opts.value;
	let v = 100 * (opts.value - opts.min) / (opts.max - opts.min);
	input.setAttribute('value', v.toFixed(0));
	opts.container.style.setProperty('--value', v + '%');
	opts.container.style.setProperty('--coef', v / 100);

	setTimeout(() => {
		this.emit('init', parseFloat(value.value));
	});

	input.oninput = data => {
		var scaledValue = scaleValue(parseFloat(data.target.value));
		value.value = scaledValue.toFixed(prec);
		let v = 100 * (data.target.value - opts.min) / (opts.max - opts.min);
		input.setAttribute('value', v.toFixed(0));
		opts.container.style.setProperty('--value', v + '%');
		opts.container.style.setProperty('--coef', v / 100);
		value.title = scaledValue;
		this.emit('input', scaledValue);
	};

	return this;
};

},{"./value":102,"dom-css":31,"events":39,"inherits":48,"is-numeric":53,"mumath/precision":71,"param-case":76}],98:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var inherits = require('inherits');
var format = require('param-case');

module.exports = Select;
inherits(Select, EventEmitter);

function Select(opts) {
	if (!(this instanceof Select)) return new Select(opts);

	this.update(opts);
}

Select.prototype.update = function (opts) {
	var i, container, input, downTriangle, upTriangle, key, option, el, keys;

	opts.container.innerHTML = '';

	input = document.createElement('select');
	input.id = opts.id;
	input.className = 'settings-panel-select';
	input.title = opts.title || opts.label;

	if (opts.disabled) input.disabled = true;

	downTriangle = document.createElement('span');
	downTriangle.className = 'settings-panel-select-triangle settings-panel-select-triangle--down';

	upTriangle = document.createElement('span');
	upTriangle.className = 'settings-panel-select-triangle settings-panel-select-triangle--up';

	if (Array.isArray(opts.options)) {
		for (let i = 0; i < opts.options.length; i++) {
			option = opts.options[i];
			el = document.createElement('option');
			el.value = el.textContent = option;
			if (opts.value === option) {
				el.selected = 'selected';
			}
			input.appendChild(el);
		}
	} else {
		keys = Object.keys(opts.options);
		for (let i = 0; i < keys.length; i++) {
			key = keys[i];
			el = document.createElement('option');
			el.value = key;
			if (opts.value === key) {
				el.selected = 'selected';
			}
			el.textContent = opts.options[key];
			input.appendChild(el);
		}
	}

	opts.container.appendChild(input);
	opts.container.appendChild(downTriangle);
	opts.container.appendChild(upTriangle);

	setTimeout(() => {
		this.emit('init', opts.value);
	});

	input.onchange = data => {
		this.emit('input', data.target.value);
	};

	return this;
};

},{"events":39,"inherits":48,"param-case":76}],99:[function(require,module,exports){
'use strict';

const inherits = require('inherits');
const Emitter = require('events').EventEmitter;
const format = require('param-case');
const extend = require('just-extend');

module.exports = Switch;

inherits(Switch, Emitter);

function Switch(opts) {
	if (!(this instanceof Switch)) return new Switch(opts);

	this.switch = opts.container.querySelector('.settings-panel-switch');

	if (!this.switch) {
		this.switch = document.createElement('fieldset');
		this.switch.className = 'settings-panel-switch';
		opts.container.appendChild(this.switch);

		var html = '';

		if (Array.isArray(opts.options)) {
			for (let i = 0; i < opts.options.length; i++) {
				let option = opts.options[i];
				html += createOption(option, option);
			}
		} else {
			for (let key in opts.options) {
				html += createOption(opts.options[key], key);
			}
		}

		this.switch.innerHTML = html;

		this.switch.onchange = e => {
			this.emit('input', e.target.getAttribute('data-value'));
		};

		setTimeout(() => {
			this.emit('init', opts.value);
		});
	}

	this.switch.id = opts.id;

	this.update(opts);

	function createOption(label, value) {
		let htmlFor = `settings-panel-${format(opts.panel.id)}-${format(opts.id)}-input-${format(value)}`;

		let html = `<input type="radio" class="settings-panel-switch-input" ${value == opts.value ? 'checked' : ''} id="${htmlFor}" name="${format(opts.id)}" data-value="${value}" title="${value}"/><label for="${htmlFor}" class="settings-panel-switch-label" title="${value}">${label}</label>`;
		return html;
	}
}

Switch.prototype.update = function (opts) {
	return this;
};

},{"events":39,"inherits":48,"just-extend":55,"param-case":76}],100:[function(require,module,exports){
'use strict';

const EventEmitter = require('events').EventEmitter;
const inherits = require('inherits');
const css = require('dom-css');
const num = require('input-number');
const extend = require('just-extend');

module.exports = Text;
inherits(Text, EventEmitter);

function Text(opts) {
	if (!(this instanceof Text)) return new Text(opts);

	let element = opts.container.querySelector('.settings-panel-text');

	if (!element) {
		element = opts.container.appendChild(document.createElement('input'));
		element.className = 'settings-panel-text';
		num(element);

		if (opts.placeholder) element.placeholder = opts.placeholder;

		this.element = element;

		element.oninput = data => {
			this.emit('input', data.target.value);
		};
		setTimeout(() => {
			this.emit('init', element.value);
		});
	}

	this.update(opts);
}

Text.prototype.update = function (opts) {
	extend(this, opts);
	this.element.type = this.type;
	this.element.id = this.id;
	this.element.value = this.value || '';
	this.element.disabled = !!this.disabled;
	return this;
};

},{"dom-css":31,"events":39,"inherits":48,"input-number":49,"just-extend":55}],101:[function(require,module,exports){
'use strict';

const EventEmitter = require('events').EventEmitter;
const inherits = require('inherits');
const css = require('dom-css');
const autosize = require('autosize');
const extend = require('just-extend');

module.exports = Textarea;
inherits(Textarea, EventEmitter);

function Textarea(opts) {
	if (!(this instanceof Textarea)) return new Textarea(opts);

	//<textarea rows="1" placeholder="${param.placeholder || 'value...'}" id="${param.name}" class="prama-input prama-textarea" title="${param.value}">${param.value}</textarea>
	let input = opts.container.querySelector('.settings-panel-textarea');
	if (!input) {
		input = opts.container.appendChild(document.createElement('textarea'));
		input.className = 'settings-panel-textarea';

		this.element = input;

		setTimeout(() => {
			this.emit('init', input.value);
			autosize.update(input);
		});

		input.oninput = data => {
			this.emit('input', data.target.value);
		};

		autosize(input);
	}

	this.update(opts);
}

Textarea.prototype.update = function (opts) {
	extend(this, opts);

	this.element.rows = this.rows || 1;
	this.element.placeholder = this.placeholder || '';
	this.element.id = this.id;

	this.element.value = this.value || '';

	this.element.disabled = !!this.disabled;

	autosize.update(this.element);

	return this;
};

},{"autosize":16,"dom-css":31,"events":39,"inherits":48,"just-extend":55}],102:[function(require,module,exports){
'use strict';

const num = require('input-number');

module.exports = function (opts) {
  opts = opts || {};
  var value = document.createElement('input');

  num(value, opts);

  if (opts.input) {
    value.addEventListener('input', function () {
      let v = value.value;
      if (opts.type === 'number') v = parseFloat(v);
      opts.input(v);
    });
  }
  if (opts.change) {
    value.addEventListener('change', function () {
      let v = value.value;
      if (opts.type === 'number') v = parseFloat(v);
      opts.change(v);
    });
  }

  if (opts.disabled) value.disabled = true;

  value.value = opts.value;

  if (opts.id) value.id = opts.id;
  value.className = 'settings-panel-value';
  if (opts.className) value.className += ' ' + opts.className;
  opts.container.appendChild(value);

  //add tip holder after value
  let tip = opts.container.appendChild(document.createElement('div'));
  tip.className = 'settings-panel-value-tip';

  return value;
};

},{"input-number":49}],103:[function(require,module,exports){
/**
 * @module  settings-panel/theme/none
 */
'use strict';

const px = require('add-px-to-style');

module.exports = none;

none.palette = ['white', 'black'];
none.fontSize = 13;
none.fontFamily = 'sans-serif';
none.labelWidth = '9em';
none.inputHeight = 2;
none.padding = 1 / 5;

function none(opts) {
	opts = opts || {};
	let fs = opts.fontSize || none.fontSize;
	let font = opts.fontFamily || none.fontFamily;
	let h = opts.inputHeight || none.inputHeight;
	let labelWidth = opts.labelWidth || none.labelWidth;
	let padding = opts.padding || none.padding;
	let palette = opts.palette || none.palette;
	let white = palette[0];
	let black = palette[palette.length - 1];

	if (/[-0-9.]*/.test(fs)) fs = parseFloat(fs);

	//just size part
	return `
		:host {
			background: ${white};
			color: ${black};
			font-family: ${font};
			font-size: ${px('font-size', fs)};
			padding: ${h * 2.5 * padding}em;
		}

		.settings-panel-title {
			min-height: ${h}em;
			line-height: 1.5;
			text-align: left;
			font-size: ${px('font-size', fs * 1.333)};
			padding: ${h * 2 * padding / 1.333}em ${h * padding / 1.333}em;
			min-height: ${h / 1.333}em;
			margin: 0;
		}

		.settings-panel-field {
			padding: ${h * padding}em;
		}

		:host.settings-panel-orientation-left .settings-panel-label,
		:host .settings-panel-orientation-left .settings-panel-label,
		:host.settings-panel-orientation-right .settings-panel-label,
		:host .settings-panel-orientation-right .settings-panel-label {
			width: ${px('width', labelWidth)};
		}
		:host.settings-panel-orientation-bottom .settings-panel-label {
			border-top-width: ${h}em;
		}
		:host.settings-panel-orientation-bottom .settings-panel-label + .settings-panel-input {
			top: ${h / 8}em;
		}
		:host.settings-panel-orientation-left .settings-panel-label {
			padding-right: ${h / 2}em;
		}
		:host.settings-panel-orientation-right .settings-panel-label {
			padding-left: ${h / 2}em;
		}
		:host.settings-panel-orientation-right .settings-panel-label + .settings-panel-input {
			width: calc(100% - ${labelWidth});
		}

		.settings-panel-text,
		.settings-panel-textarea,
		.settings-panel-range,
		.settings-panel-interval,
		.settings-panel-select,
		.settings-panel-color,
		.settings-panel-color-value,
		.settings-panel-value {
			height: ${h}em;
		}

		.settings-panel-button,
		.settings-panel-input,
		.settings-panel-switch,
		.settings-panel-checkbox-group,
		.settings-panel-switch-label {
			min-height: ${h}em;
		}
		.settings-panel-input,
		.settings-panel-switch,
		.settings-panel-select,
		.settings-panel-checkbox-group,
		.settings-panel-switch-label {
			line-height: ${h}em;
		}

		.settings-panel-switch-label,
		.settings-panel-checkbox,
		.settings-panel-checkbox-label,
		.settings-panel-button {
			cursor: pointer;
		}

		.settings-panel-range::-webkit-slider-thumb {
			cursor: ew-resize;
		}
		.settings-panel-range::-moz-range-thumb {
			cursor: ew-resize;
		}
		.settings-panel-range::-ms-track {
			cursor: ew-resize;
		}
		.settings-panel-range::-ms-thumb {
			cursor: ew-resize;
		}

		/* Default triangle styles are from control theme, just set display: block */
		.settings-panel-select-triangle {
			display: none;
			position: absolute;
			border-right: .3em solid transparent;
			border-left: .3em solid transparent;
			line-height: ${h}em;
			right: 2.5%;
			height: 0;
			z-index: 1;
			pointer-events: none;
		}
		.settings-panel-select-triangle--up {
			top: ${h / 2}em;
			margin-top: -${h / 4 + h / 24}em;
			border-bottom: ${h / 4}em solid;
			border-top: 0px transparent;
		}
		.settings-panel-select-triangle--down {
			top: ${h / 2}em;
			margin-top: ${h / 24}em;
			border-top: ${h / 4}em solid;
			border-bottom: .0 transparent;
		}

		:host hr {
			opacity: .5;

			color: ${black}
		}
	`;
}

},{"add-px-to-style":12}],104:[function(require,module,exports){
'use strict';

var bindAll = require('lodash.bindall');
var transform = require('dom-transform');
var tinycolor = require('tinycolor2');
var Emitter = require('component-emitter');
var isNumber = require('is-number');
var clamp = require('./src/utils/maths/clamp');

/**
 * Creates a new Colorpicker
 * @param {Object} options
 * @param {String|Number|Object} options.color The default color that the colorpicker will display. Default is #FFFFFF. It can be a hexadecimal number or an hex String.
 * @param {String|Number|Object} options.background The background color of the colorpicker. Default is transparent. It can be a hexadecimal number or an hex String.
 * @param {DomElement} options.el A dom node to add the colorpicker to. You can also use `colorPicker.appendTo(domNode)` afterwards if you prefer.
 * @param {Number} options.width Desired width of the color picker. Default is 175.
 * @param {Number} options.height Desired height of the color picker. Default is 150.
 */
function SimpleColorPicker(options) {
  // options
  options = options || {};

  // properties
  this.color = null;
  this.width = 0;
  this.height = 0;
  this.hue = 0;
  this.choosing = false;
  this.position = { x: 0, y: 0 };
  this.huePosition = 0;
  this.saturationWidth = 0;
  this.maxHue = 0;
  this.inputIsNumber = false;

  // bind methods to scope (only if needed)
  bindAll(this, '_onSaturationMouseMove', '_onSaturationMouseDown', '_onSaturationMouseUp', '_onHueMouseDown', '_onHueMouseUp', '_onHueMouseMove');

  // create dom
  this.$el = document.createElement('div');
  this.$el.className = 'Scp';
  this.$el.innerHTML = ['<div class="Scp-saturation">', '<div class="Scp-brightness"></div>', '<div class="Scp-sbSelector"></div>', '</div>', '<div class="Scp-hue">', '<div class="Scp-hSelector"></div>', '</div>'].join('\n');

  // dom accessors
  this.$saturation = this.$el.querySelector('.Scp-saturation');
  this.$hue = this.$el.querySelector('.Scp-hue');
  this.$sbSelector = this.$el.querySelector('.Scp-sbSelector');
  this.$hSelector = this.$el.querySelector('.Scp-hSelector');

  // event listeners
  this.$saturation.addEventListener('mousedown', this._onSaturationMouseDown);
  this.$saturation.addEventListener('touchstart', this._onSaturationMouseDown);
  this.$hue.addEventListener('mousedown', this._onHueMouseDown);
  this.$hue.addEventListener('touchstart', this._onHueMouseDown);

  // some styling and DOMing from options
  if (options.el) {
    this.appendTo(options.el);
  }
  if (options.background) {
    this.setBackgroundColor(options.background);
  }
  this.setSize(options.width || 175, options.height || 150);
  this.setColor(options.color);

  return this;
}

Emitter(SimpleColorPicker.prototype);

/* =============================================================================
  Public API
============================================================================= */
/**
 * Add the colorPicker instance to a domElement.
 * @param  {domElement} domElement
 * @return {colorPicker} returns itself for chaining purpose
 */
SimpleColorPicker.prototype.appendTo = function (domElement) {
  domElement.appendChild(this.$el);
  return this;
};

/**
 * Removes colorpicker from is parent and kill all listeners.
 * Call this method for proper destroy.
 */
SimpleColorPicker.prototype.remove = function () {
  this.$saturation.removeEventListener('mousedown', this._onSaturationMouseDown);
  this.$saturation.removeEventListener('touchstart', this._onSaturationMouseDown);
  this.$hue.removeEventListener('mousedown', this._onHueMouseDown);
  this.$hue.removeEventListener('touchstart', this._onHueMouseDown);
  this._onSaturationMouseUp();
  this._onHueMouseUp();
  this.off();
  if (this.$el.parentNode) {
    this.$el.parentNode.removeChild(this.$el);
  }
};

/**
 * Manually set the current color of the colorpicker. This is the method
 * used on instantiation to convert `color` option to actual color for
 * the colorpicker. Param can be a hexadecimal number or an hex String.
 * @param {String|Number} color hex color desired
 */
SimpleColorPicker.prototype.setColor = function (color) {
  if (isNumber(color)) {
    this.inputIsNumber = true;
    color = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
  } else {
    this.inputIsNumber = false;
  }
  this.color = tinycolor(color);

  var hsvColor = this.color.toHsv();

  if (!isNaN(hsvColor.h)) {
    this.hue = hsvColor.h;
  }

  this._moveSelectorTo(this.saturationWidth * hsvColor.s, (1 - hsvColor.v) * this.height);
  this._moveHueTo((1 - this.hue / 360) * this.height);

  this._updateHue();
  return this;
};

/**
 * Set size of the color picker for a given width and height. Note that
 * a padding of 5px will be added if you chose to use the background option
 * of the constructor.
 * @param {Number} width
 * @param {Number} height
 */
SimpleColorPicker.prototype.setSize = function (width, height) {
  this.width = width;
  this.height = height;
  this.$el.style.width = this.width + 'px';
  this.$el.style.height = this.height + 'px';
  this.saturationWidth = this.width - 25;
  this.maxHue = this.height - 2;
  return this;
};

/**
 * Set the background color of the colorpicker. It also adds a 5px padding
 * for design purpose.
 * @param {String|Number} color hex color desired for background
 */
SimpleColorPicker.prototype.setBackgroundColor = function (color) {
  if (isNumber(color)) {
    color = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
  }
  this.$el.style.padding = '5px';
  this.$el.style.background = tinycolor(color).toHexString();
};

/**
 * Removes background of the colorpicker if previously set. It's no use
 * calling this method if you didn't set the background option on start
 * or if you didn't call setBackgroundColor previously.
 */
SimpleColorPicker.prototype.setNoBackground = function () {
  this.$el.style.padding = '0px';
  this.$el.style.background = 'none';
};

/**
 * Registers callback to the update event of the colorpicker.
 * ColorPicker inherits from [component/emitter](https://github.com/component/emitter)
 * so you could do the same thing by calling `colorPicker.on('update');`
 * @param  {Function} callback
 * @return {colorPicker} returns itself for chaining purpose
 */
SimpleColorPicker.prototype.onChange = function (callback) {
  this.on('update', callback);
  this.emit('update', this.getHexString());
  return this;
};

/* =============================================================================
  Color getters
============================================================================= */
/**
 * Main color getter, will return a formatted color string depending on input
 * or a number depending on the last setColor call.
 * @return {Number|String}
 */
SimpleColorPicker.prototype.getColor = function () {
  if (this.inputIsNumber) {
    return this.getHexNumber();
  }
  return this.color.toString();
};

/**
 * Returns color as css hex string (ex: '#FF0000').
 * @return {String}
 */
SimpleColorPicker.prototype.getHexString = function () {
  return this.color.toHexString().toUpperCase();
};

/**
 * Returns color as number (ex: 0xFF0000).
 * @return {Number}
 */
SimpleColorPicker.prototype.getHexNumber = function () {
  return parseInt(this.color.toHex(), 16);
};

/**
 * Returns color as {r: 255, g: 0, b: 0} object.
 * @return {Object}
 */
SimpleColorPicker.prototype.getRGB = function () {
  return this.color.toRgb();
};

/**
 * Returns color as {h: 100, s: 1, v: 1} object.
 * @return {Object}
 */
SimpleColorPicker.prototype.getHSV = function () {
  return this.color.toHsv();
};

/**
 * Returns true if color is perceived as dark
 * @return {Boolean}
 */
SimpleColorPicker.prototype.isDark = function () {
  return this.color.isDark();
};

/**
 * Returns true if color is perceived as light
 * @return {Boolean}
 */
SimpleColorPicker.prototype.isLight = function () {
  return this.color.isLight();
};

/* =============================================================================
  "Private" Methods LOL silly javascript
============================================================================= */
SimpleColorPicker.prototype._moveSelectorTo = function (x, y) {
  this.position.x = clamp(x, 0, this.saturationWidth);
  this.position.y = clamp(y, 0, this.height);

  transform(this.$sbSelector, {
    x: this.position.x,
    y: this.position.y
  });
};

SimpleColorPicker.prototype._updateColorFromPosition = function () {
  this.color = tinycolor({ h: this.hue, s: this.position.x / this.saturationWidth, v: 1 - this.position.y / this.height });
  this._updateColor();
};

SimpleColorPicker.prototype._moveHueTo = function (y) {
  this.huePosition = clamp(y, 0, this.maxHue);

  transform(this.$hSelector, {
    y: this.huePosition
  });
};

SimpleColorPicker.prototype._updateHueFromPosition = function () {
  var hsvColor = this.color.toHsv();
  this.hue = 360 * (1 - this.huePosition / this.maxHue);
  this.color = tinycolor({ h: this.hue, s: hsvColor.s, v: hsvColor.v });
  this._updateHue();
};

SimpleColorPicker.prototype._updateHue = function () {
  var hueColor = tinycolor({ h: this.hue, s: 1, v: 1 });
  this.$saturation.style.background = 'linear-gradient(to right, #fff 0%, ' + hueColor.toHexString() + ' 100%)';
  this._updateColor();
};

SimpleColorPicker.prototype._updateColor = function () {
  this.$sbSelector.style.background = this.color.toHexString();
  this.$sbSelector.style.borderColor = this.color.isDark() ? '#FFF' : '#000';
  this.emit('update', this.color.toHexString());
};

/* =============================================================================
  Events handlers
============================================================================= */
SimpleColorPicker.prototype._onSaturationMouseDown = function (e) {
  this.choosing = true;
  var sbOffset = this.$saturation.getBoundingClientRect();
  var xPos = e.type.indexOf('touch') === 0 ? e.touches[0].clientX : e.clientX;
  var yPos = e.type.indexOf('touch') === 0 ? e.touches[0].clientY : e.clientY;
  this._moveSelectorTo(xPos - sbOffset.left, yPos - sbOffset.top);
  this._updateColorFromPosition();
  window.addEventListener('mouseup', this._onSaturationMouseUp);
  window.addEventListener('touchend', this._onSaturationMouseUp);
  window.addEventListener('mousemove', this._onSaturationMouseMove);
  window.addEventListener('touchmove', this._onSaturationMouseMove);
  e.preventDefault();
};

SimpleColorPicker.prototype._onSaturationMouseMove = function (e) {
  var sbOffset = this.$saturation.getBoundingClientRect();
  var xPos = e.type.indexOf('touch') === 0 ? e.touches[0].clientX : e.clientX;
  var yPos = e.type.indexOf('touch') === 0 ? e.touches[0].clientY : e.clientY;
  this._moveSelectorTo(xPos - sbOffset.left, yPos - sbOffset.top);
  this._updateColorFromPosition();
};

SimpleColorPicker.prototype._onSaturationMouseUp = function () {
  this.choosing = false;
  window.removeEventListener('mouseup', this._onSaturationMouseUp);
  window.removeEventListener('touchend', this._onSaturationMouseUp);
  window.removeEventListener('mousemove', this._onSaturationMouseMove);
  window.removeEventListener('touchmove', this._onSaturationMouseMove);
};

SimpleColorPicker.prototype._onHueMouseDown = function (e) {
  this.choosing = true;
  var hOffset = this.$hue.getBoundingClientRect();
  var yPos = e.type.indexOf('touch') === 0 ? e.touches[0].clientY : e.clientY;
  this._moveHueTo(yPos - hOffset.top);
  this._updateHueFromPosition();
  window.addEventListener('mouseup', this._onHueMouseUp);
  window.addEventListener('touchend', this._onHueMouseUp);
  window.addEventListener('mousemove', this._onHueMouseMove);
  window.addEventListener('touchmove', this._onHueMouseMove);
  e.preventDefault();
};

SimpleColorPicker.prototype._onHueMouseMove = function (e) {
  var hOffset = this.$hue.getBoundingClientRect();
  var yPos = e.type.indexOf('touch') === 0 ? e.touches[0].clientY : e.clientY;
  this._moveHueTo(yPos - hOffset.top);
  this._updateHueFromPosition();
};

SimpleColorPicker.prototype._onHueMouseUp = function () {
  this.choosing = false;
  window.removeEventListener('mouseup', this._onHueMouseUp);
  window.removeEventListener('touchend', this._onHueMouseUp);
  window.removeEventListener('mousemove', this._onHueMouseMove);
  window.removeEventListener('touchmove', this._onHueMouseMove);
};

module.exports = SimpleColorPicker;

},{"./src/utils/maths/clamp":105,"component-emitter":30,"dom-transform":32,"is-number":52,"lodash.bindall":60,"tinycolor2":109}],105:[function(require,module,exports){
'use strict';

module.exports = function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
};

},{}],106:[function(require,module,exports){
arguments[4][8][0].apply(exports,arguments)
},{"dup":8}],107:[function(require,module,exports){
arguments[4][9][0].apply(exports,arguments)
},{"./lib/sort":106,"dup":9,"typedarray-pool":119}],108:[function(require,module,exports){
'use strict';

module.exports = TinySDF;

var INF = 1e20;

function TinySDF(fontSize, buffer, radius, cutoff, fontFamily) {
    this.fontSize = fontSize || 24;
    this.buffer = buffer === undefined ? 3 : buffer;
    this.cutoff = cutoff || 0.25;
    this.fontFamily = fontFamily || 'sans-serif';
    this.radius = radius || 8;
    var size = this.size = this.fontSize + this.buffer * 2;

    this.canvas = document.createElement('canvas');
    this.canvas.width = this.canvas.height = size;

    this.ctx = this.canvas.getContext('2d');
    this.ctx.font = fontSize + 'px ' + this.fontFamily;
    this.ctx.textBaseline = 'middle';
    this.ctx.fillStyle = 'black';

    // temporary arrays for the distance transform
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.d = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Int16Array(size);

    // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852
    this.middle = Math.round(size / 2 * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));
}

TinySDF.prototype.draw = function (char) {
    this.ctx.clearRect(0, 0, this.size, this.size);
    this.ctx.fillText(char, this.buffer, this.middle);

    var imgData = this.ctx.getImageData(0, 0, this.size, this.size);
    var data = imgData.data;

    for (var i = 0; i < this.size * this.size; i++) {
        var a = data[i * 4 + 3] / 255; // alpha value
        this.gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);
        this.gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);
    }

    edt(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z);
    edt(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z);

    for (i = 0; i < this.size * this.size; i++) {
        var d = this.gridOuter[i] - this.gridInner[i];
        var c = Math.max(0, Math.min(255, Math.round(255 - 255 * (d / this.radius + this.cutoff))));
        data[4 * i + 0] = c;
        data[4 * i + 1] = c;
        data[4 * i + 2] = c;
        data[4 * i + 3] = 255;
    }

    return imgData;
};

// 2D Euclidean distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/dt/
function edt(data, width, height, f, d, v, z) {
    for (var x = 0; x < width; x++) {
        for (var y = 0; y < height; y++) {
            f[y] = data[y * width + x];
        }
        edt1d(f, d, v, z, height);
        for (y = 0; y < height; y++) {
            data[y * width + x] = d[y];
        }
    }
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            f[x] = data[y * width + x];
        }
        edt1d(f, d, v, z, width);
        for (x = 0; x < width; x++) {
            data[y * width + x] = Math.sqrt(d[x]);
        }
    }
}

// 1D squared distance transform
function edt1d(f, d, v, z, n) {
    v[0] = 0;
    z[0] = -INF;
    z[1] = +INF;

    for (var q = 1, k = 0; q < n; q++) {
        var s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        while (s <= z[k]) {
            k--;
            s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        }
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = +INF;
    }

    for (q = 0, k = 0; q < n; q++) {
        while (z[k + 1] < q) k++;
        d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];
    }
}

},{}],109:[function(require,module,exports){
// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function (Math) {

    var trimLeft = /^\s+/,
        trimRight = /\s+$/,
        tinyCounter = 0,
        mathRound = Math.round,
        mathMin = Math.min,
        mathMax = Math.max,
        mathRandom = Math.random;

    function tinycolor(color, opts) {

        color = color ? color : '';
        opts = opts || {};

        // If input is already a tinycolor, return itself
        if (color instanceof tinycolor) {
            return color;
        }
        // If we are called as a function, call using new instead
        if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
        }

        var rgb = inputToRGB(color);
        this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
        this._gradientType = opts.gradientType;

        // Don't let the range of [0,255] come back in [0,1].
        // Potentially lose a little bit of precision here, but will fix issues where
        // .5 gets interpreted as half of the total, instead of half of 1
        // If it was supposed to be 128, this was already taken care of by `inputToRgb`
        if (this._r < 1) {
            this._r = mathRound(this._r);
        }
        if (this._g < 1) {
            this._g = mathRound(this._g);
        }
        if (this._b < 1) {
            this._b = mathRound(this._b);
        }

        this._ok = rgb.ok;
        this._tc_id = tinyCounter++;
    }

    tinycolor.prototype = {
        isDark: function () {
            return this.getBrightness() < 128;
        },
        isLight: function () {
            return !this.isDark();
        },
        isValid: function () {
            return this._ok;
        },
        getOriginalInput: function () {
            return this._originalInput;
        },
        getFormat: function () {
            return this._format;
        },
        getAlpha: function () {
            return this._a;
        },
        getBrightness: function () {
            //http://www.w3.org/TR/AERT#color-contrast
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        },
        getLuminance: function () {
            //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
            var rgb = this.toRgb();
            var RsRGB, GsRGB, BsRGB, R, G, B;
            RsRGB = rgb.r / 255;
            GsRGB = rgb.g / 255;
            BsRGB = rgb.b / 255;

            if (RsRGB <= 0.03928) {
                R = RsRGB / 12.92;
            } else {
                R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
                G = GsRGB / 12.92;
            } else {
                G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
                B = BsRGB / 12.92;
            } else {
                B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R + 0.7152 * G + 0.0722 * B;
        },
        setAlpha: function (value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(100 * this._a) / 100;
            return this;
        },
        toHsv: function () {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function () {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360),
                s = mathRound(hsv.s * 100),
                v = mathRound(hsv.v * 100);
            return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
        },
        toHsl: function () {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },
        toHslString: function () {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360),
                s = mathRound(hsl.s * 100),
                l = mathRound(hsl.l * 100);
            return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
        },
        toHex: function (allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function (allow3Char) {
            return '#' + this.toHex(allow3Char);
        },
        toHex8: function (allow4Char) {
            return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
        },
        toHex8String: function (allow4Char) {
            return '#' + this.toHex8(allow4Char);
        },
        toRgb: function () {
            return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function () {
            return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function () {
            return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function () {
            return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function () {
            if (this._a === 0) {
                return "transparent";
            }

            if (this._a < 1) {
                return false;
            }

            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function (secondColor) {
            var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";

            if (secondColor) {
                var s = tinycolor(secondColor);
                secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
            }

            return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
        },
        toString: function (format) {
            var formatSet = !!format;
            format = format || this._format;

            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

            if (needsAlphaFormat) {
                // Special case for "transparent", all other non-alpha formats
                // will return rgba when there is transparency.
                if (format === "name" && this._a === 0) {
                    return this.toName();
                }
                return this.toRgbString();
            }
            if (format === "rgb") {
                formattedString = this.toRgbString();
            }
            if (format === "prgb") {
                formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
                formattedString = this.toHexString();
            }
            if (format === "hex3") {
                formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
                formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
                formattedString = this.toHex8String();
            }
            if (format === "name") {
                formattedString = this.toName();
            }
            if (format === "hsl") {
                formattedString = this.toHslString();
            }
            if (format === "hsv") {
                formattedString = this.toHsvString();
            }

            return formattedString || this.toHexString();
        },
        clone: function () {
            return tinycolor(this.toString());
        },

        _applyModification: function (fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
        },
        lighten: function () {
            return this._applyModification(lighten, arguments);
        },
        brighten: function () {
            return this._applyModification(brighten, arguments);
        },
        darken: function () {
            return this._applyModification(darken, arguments);
        },
        desaturate: function () {
            return this._applyModification(desaturate, arguments);
        },
        saturate: function () {
            return this._applyModification(saturate, arguments);
        },
        greyscale: function () {
            return this._applyModification(greyscale, arguments);
        },
        spin: function () {
            return this._applyModification(spin, arguments);
        },

        _applyCombination: function (fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function () {
            return this._applyCombination(analogous, arguments);
        },
        complement: function () {
            return this._applyCombination(complement, arguments);
        },
        monochromatic: function () {
            return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function () {
            return this._applyCombination(splitcomplement, arguments);
        },
        triad: function () {
            return this._applyCombination(triad, arguments);
        },
        tetrad: function () {
            return this._applyCombination(tetrad, arguments);
        }
    };

    // If input is an object, force 1 into "1.0" to handle ratios properly
    // String input requires "1.0" as input, so 1 will be treated as 1
    tinycolor.fromRatio = function (color, opts) {
        if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
                if (color.hasOwnProperty(i)) {
                    if (i === "a") {
                        newColor[i] = color[i];
                    } else {
                        newColor[i] = convertToPercentage(color[i]);
                    }
                }
            }
            color = newColor;
        }

        return tinycolor(color, opts);
    };

    // Given a string or object, convert that input to RGB
    // Possible string inputs:
    //
    //     "red"
    //     "#f00" or "f00"
    //     "#ff0000" or "ff0000"
    //     "#ff000000" or "ff000000"
    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
    //
    function inputToRGB(color) {

        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var s = null;
        var v = null;
        var l = null;
        var ok = false;
        var format = false;

        if (typeof color == "string") {
            color = stringInputToObject(color);
        }

        if (typeof color == "object") {
            if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
                s = convertToPercentage(color.s);
                v = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, s, v);
                ok = true;
                format = "hsv";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
                s = convertToPercentage(color.s);
                l = convertToPercentage(color.l);
                rgb = hslToRgb(color.h, s, l);
                ok = true;
                format = "hsl";
            }

            if (color.hasOwnProperty("a")) {
                a = color.a;
            }
        }

        a = boundAlpha(a);

        return {
            ok: ok,
            format: color.format || format,
            r: mathMin(255, mathMax(rgb.r, 0)),
            g: mathMin(255, mathMax(rgb.g, 0)),
            b: mathMin(255, mathMax(rgb.b, 0)),
            a: a
        };
    }

    // Conversion Functions
    // --------------------

    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

    // `rgbToRgb`
    // Handle bounds / percentage checking to conform to CSS color spec
    // <http://www.w3.org/TR/css3-color/>
    // *Assumes:* r, g, b in [0, 255] or [0, 1]
    // *Returns:* { r, g, b } in [0, 255]
    function rgbToRgb(r, g, b) {
        return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
        };
    }

    // `rgbToHsl`
    // Converts an RGB color value to HSL.
    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
    // *Returns:* { h, s, l } in [0,1]
    function rgbToHsl(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b),
            min = mathMin(r, g, b);
        var h,
            s,
            l = (max + min) / 2;

        if (max == min) {
            h = s = 0; // achromatic
        } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);break;
                case g:
                    h = (b - r) / d + 2;break;
                case b:
                    h = (r - g) / d + 4;break;
            }

            h /= 6;
        }

        return { h: h, s: s, l: l };
    }

    // `hslToRgb`
    // Converts an HSL color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hslToRgb(h, s, l) {
        var r, g, b;

        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);

        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }

        if (s === 0) {
            r = g = b = l; // achromatic
        } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHsv`
    // Converts an RGB color value to HSV
    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
    // *Returns:* { h, s, v } in [0,1]
    function rgbToHsv(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b),
            min = mathMin(r, g, b);
        var h,
            s,
            v = max;

        var d = max - min;
        s = max === 0 ? 0 : d / max;

        if (max == min) {
            h = 0; // achromatic
        } else {
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);break;
                case g:
                    h = (b - r) / d + 2;break;
                case b:
                    h = (r - g) / d + 4;break;
            }
            h /= 6;
        }
        return { h: h, s: s, v: v };
    }

    // `hsvToRgb`
    // Converts an HSV color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hsvToRgb(h, s, v) {

        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);

        var i = Math.floor(h),
            f = h - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s),
            mod = i % 6,
            r = [v, q, p, p, t, v][mod],
            g = [t, v, v, q, p, p][mod],
            b = [p, p, t, v, v, q][mod];

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHex`
    // Converts an RGB color to hex
    // Assumes r, g, and b are contained in the set [0, 255]
    // Returns a 3 or 6 character hex
    function rgbToHex(r, g, b, allow3Char) {

        var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];

        // Return a 3 character hex if possible
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }

        return hex.join("");
    }

    // `rgbaToHex`
    // Converts an RGBA color plus alpha transparency to hex
    // Assumes r, g, b are contained in the set [0, 255] and
    // a in [0, 1]. Returns a 4 or 8 character rgba hex
    function rgbaToHex(r, g, b, a, allow4Char) {

        var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)), pad2(convertDecimalToHex(a))];

        // Return a 4 character hex if possible
        if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
        }

        return hex.join("");
    }

    // `rgbaToArgbHex`
    // Converts an RGBA color to an ARGB Hex8 string
    // Rarely used, but required for "toFilter()"
    function rgbaToArgbHex(r, g, b, a) {

        var hex = [pad2(convertDecimalToHex(a)), pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];

        return hex.join("");
    }

    // `equals`
    // Can be called with any tinycolor input
    tinycolor.equals = function (color1, color2) {
        if (!color1 || !color2) {
            return false;
        }
        return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };

    tinycolor.random = function () {
        return tinycolor.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom()
        });
    };

    // Modification Functions
    // ----------------------
    // Thanks to less.js for some of the basics here
    // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

    function desaturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function saturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function greyscale(color) {
        return tinycolor(color).desaturate(100);
    }

    function lighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    function brighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var rgb = tinycolor(color).toRgb();
        rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
        rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
        rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
        return tinycolor(rgb);
    }

    function darken(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
    // Values outside of this range will be wrapped into this range.
    function spin(color, amount) {
        var hsl = tinycolor(color).toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return tinycolor(hsl);
    }

    // Combination Functions
    // ---------------------
    // Thanks to jQuery xColor for some of the ideas behind these
    // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

    function complement(color) {
        var hsl = tinycolor(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return tinycolor(hsl);
    }

    function triad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [tinycolor(color), tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }), tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })];
    }

    function tetrad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [tinycolor(color), tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }), tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }), tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })];
    }

    function splitcomplement(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [tinycolor(color), tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }), tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })];
    }

    function analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;

        var hsl = tinycolor(color).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor(color)];

        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
        }
        return ret;
    }

    function monochromatic(color, results) {
        results = results || 6;
        var hsv = tinycolor(color).toHsv();
        var h = hsv.h,
            s = hsv.s,
            v = hsv.v;
        var ret = [];
        var modification = 1 / results;

        while (results--) {
            ret.push(tinycolor({ h: h, s: s, v: v }));
            v = (v + modification) % 1;
        }

        return ret;
    }

    // Utility Functions
    // ---------------------

    tinycolor.mix = function (color1, color2, amount) {
        amount = amount === 0 ? 0 : amount || 50;

        var rgb1 = tinycolor(color1).toRgb();
        var rgb2 = tinycolor(color2).toRgb();

        var p = amount / 100;

        var rgba = {
            r: (rgb2.r - rgb1.r) * p + rgb1.r,
            g: (rgb2.g - rgb1.g) * p + rgb1.g,
            b: (rgb2.b - rgb1.b) * p + rgb1.b,
            a: (rgb2.a - rgb1.a) * p + rgb1.a
        };

        return tinycolor(rgba);
    };

    // Readability Functions
    // ---------------------
    // <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

    // `contrast`
    // Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
    tinycolor.readability = function (color1, color2) {
        var c1 = tinycolor(color1);
        var c2 = tinycolor(color2);
        return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };

    // `isReadable`
    // Ensure that foreground and background color combinations meet WCAG2 guidelines.
    // The third argument is an optional Object.
    //      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
    //      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
    // If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

    // *Example*
    //    tinycolor.isReadable("#000", "#111") => false
    //    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
    tinycolor.isReadable = function (color1, color2, wcag2) {
        var readability = tinycolor.readability(color1, color2);
        var wcag2Parms, out;

        out = false;

        wcag2Parms = validateWCAG2Parms(wcag2);
        switch (wcag2Parms.level + wcag2Parms.size) {
            case "AAsmall":
            case "AAAlarge":
                out = readability >= 4.5;
                break;
            case "AAlarge":
                out = readability >= 3;
                break;
            case "AAAsmall":
                out = readability >= 7;
                break;
        }
        return out;
    };

    // `mostReadable`
    // Given a base color and a list of possible foreground or background
    // colors for that base, returns the most readable color.
    // Optionally returns Black or White if the most readable color is unreadable.
    // *Example*
    //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
    //    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
    //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
    //    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
    tinycolor.mostReadable = function (baseColor, colorList, args) {
        var bestColor = null;
        var bestScore = 0;
        var readability;
        var includeFallbackColors, level, size;
        args = args || {};
        includeFallbackColors = args.includeFallbackColors;
        level = args.level;
        size = args.size;

        for (var i = 0; i < colorList.length; i++) {
            readability = tinycolor.readability(baseColor, colorList[i]);
            if (readability > bestScore) {
                bestScore = readability;
                bestColor = tinycolor(colorList[i]);
            }
        }

        if (tinycolor.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
            return bestColor;
        } else {
            args.includeFallbackColors = false;
            return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
        }
    };

    // Big List of Colors
    // ------------------
    // <http://www.w3.org/TR/css3-color/#svg-color>
    var names = tinycolor.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
    };

    // Make it easy to access colors via `hexNames[hex]`
    var hexNames = tinycolor.hexNames = flip(names);

    // Utilities
    // ---------

    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
    function flip(o) {
        var flipped = {};
        for (var i in o) {
            if (o.hasOwnProperty(i)) {
                flipped[o[i]] = i;
            }
        }
        return flipped;
    }

    // Return a valid alpha value [0,1] with all invalid values being set to 1
    function boundAlpha(a) {
        a = parseFloat(a);

        if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
        }

        return a;
    }

    // Take input from [0, n] and return it as [0, 1]
    function bound01(n, max) {
        if (isOnePointZero(n)) {
            n = "100%";
        }

        var processPercent = isPercentage(n);
        n = mathMin(max, mathMax(0, parseFloat(n)));

        // Automatically convert percentage into number
        if (processPercent) {
            n = parseInt(n * max, 10) / 100;
        }

        // Handle floating point rounding errors
        if (Math.abs(n - max) < 0.000001) {
            return 1;
        }

        // Convert into [0, 1] range if it isn't already
        return n % max / parseFloat(max);
    }

    // Force a number between 0 and 1
    function clamp01(val) {
        return mathMin(1, mathMax(0, val));
    }

    // Parse a base-16 hex value into a base-10 integer
    function parseIntFromHex(val) {
        return parseInt(val, 16);
    }

    // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
    function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
    }

    // Check to see if string passed in is a percentage
    function isPercentage(n) {
        return typeof n === "string" && n.indexOf('%') != -1;
    }

    // Force a hex value to have 2 characters
    function pad2(c) {
        return c.length == 1 ? '0' + c : '' + c;
    }

    // Replace a decimal with it's percentage value
    function convertToPercentage(n) {
        if (n <= 1) {
            n = n * 100 + "%";
        }

        return n;
    }

    // Converts a decimal to a hex value
    function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
    }
    // Converts a hex value to a decimal
    function convertHexToDecimal(h) {
        return parseIntFromHex(h) / 255;
    }

    var matchers = function () {

        // <http://www.w3.org/TR/css3-values/#integers>
        var CSS_INTEGER = "[-\\+]?\\d+%?";

        // <http://www.w3.org/TR/css3-values/#number-value>
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

        // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

        // Actual matching.
        // Parentheses and commas are optional, but not required.
        // Whitespace can take the place of commas or opening paren
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

        return {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
    }();

    // `isValidCSSUnit`
    // Take in a single string / number and check to see if it looks like a CSS unit
    // (see `matchers` above for definition).
    function isValidCSSUnit(color) {
        return !!matchers.CSS_UNIT.exec(color);
    }

    // `stringInputToObject`
    // Permissive string parsing.  Take in a number of formats, and output an object
    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
    function stringInputToObject(color) {

        color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();
        var named = false;
        if (names[color]) {
            color = names[color];
            named = true;
        } else if (color == 'transparent') {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }

        // Try to match string input using regular expressions.
        // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
        // Just return an object and let the conversion functions handle that.
        // This way the result will be the same whether the tinycolor is initialized with string or object.
        var match;
        if (match = matchers.rgb.exec(color)) {
            return { r: match[1], g: match[2], b: match[3] };
        }
        if (match = matchers.rgba.exec(color)) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if (match = matchers.hsl.exec(color)) {
            return { h: match[1], s: match[2], l: match[3] };
        }
        if (match = matchers.hsla.exec(color)) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if (match = matchers.hsv.exec(color)) {
            return { h: match[1], s: match[2], v: match[3] };
        }
        if (match = matchers.hsva.exec(color)) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if (match = matchers.hex8.exec(color)) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                a: convertHexToDecimal(match[4]),
                format: named ? "name" : "hex8"
            };
        }
        if (match = matchers.hex6.exec(color)) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
            };
        }
        if (match = matchers.hex4.exec(color)) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                a: convertHexToDecimal(match[4] + '' + match[4]),
                format: named ? "name" : "hex8"
            };
        }
        if (match = matchers.hex3.exec(color)) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                format: named ? "name" : "hex"
            };
        }

        return false;
    }

    function validateWCAG2Parms(parms) {
        // return valid WCAG2 parms for isReadable.
        // If input parms are invalid, return {"level":"AA", "size":"small"}
        var level, size;
        parms = parms || { "level": "AA", "size": "small" };
        level = (parms.level || "AA").toUpperCase();
        size = (parms.size || "small").toLowerCase();
        if (level !== "AA" && level !== "AAA") {
            level = "AA";
        }
        if (size !== "small" && size !== "large") {
            size = "small";
        }
        return { "level": level, "size": size };
    }

    // Node: Export function
    if (typeof module !== "undefined" && module.exports) {
        module.exports = tinycolor;
    }
    // AMD/requirejs: Define the module
    else if (typeof define === 'function' && define.amd) {
            define(function () {
                return tinycolor;
            });
        }
        // Browser: Expose to window
        else {
                window.tinycolor = tinycolor;
            }
})(Math);

},{}],110:[function(require,module,exports){

var space = require('to-space-case'

/**
 * Export.
 */

);module.exports = toCamelCase;

/**
 * Convert a `string` to camel case.
 *
 * @param {String} string
 * @return {String}
 */

function toCamelCase(string) {
  return space(string).replace(/\s(\w)/g, function (matches, letter) {
    return letter.toUpperCase();
  });
}

},{"to-space-case":114}],111:[function(require,module,exports){
'use strict';

var repeatString = require('repeat-string');
var objectAssign = require('object-assign');
var arrify = require('arrify');

module.exports = function toCss(object, opts) {
	opts = objectAssign({
		indent: '',
		property: identity,
		value: identity,
		selector: identity
	}, opts);

	if (typeof opts.indent === 'number') {
		opts.indent = repeatString(' ', opts.indent);
	}

	function props(prop, val) {
		return arrify(prop).reduce(function (props, p) {
			return props.concat(opts.property(p, val));
		}, []);
	}

	function values(val, prop) {
		return arrify(val).reduce(function (vals, v) {
			return vals.concat(opts.value(v, prop));
		}, []);
	}

	function selectors(sel, value) {
		return arrify(sel).reduce(function (sels, s) {
			return sels.concat(opts.selector(s, value));
		}, []);
	}

	function _toCss(obj, level) {
		var str = '';
		Object.keys(obj).forEach(function (sel) {
			var value = obj[sel];
			if (isLastLevel(value)) {
				str += rule(props(sel, value), values(value, sel), opts.indent, level - 1);
				return;
			} else if (Array.isArray(value)) {
				value.forEach(function (val) {
					str += _toCss(nest(sel, val), level);
				});
				return;
			}
			selectors(sel, value).forEach(function (selector) {
				str += start(selector, opts.indent, level);
				Object.keys(value).forEach(function (prop) {
					var value = obj[sel][prop];
					if (oneMoreLevelExists(value)) {
						str += _toCss(nest(prop, value), level + 1);
					} else {
						str += rule(props(prop, value), values(value, prop), opts.indent, level);
					}
				});
				str += end(opts.indent, level);
			});
		});
		return str;
	}

	return arrify(object).map(function (o) {
		return _toCss(o, 0);
	}).join(lineEnd(opts.indent));
};

function nest(prop, val) {
	var tmp = {};
	tmp[prop] = val;
	return tmp;
}

function isLastLevel(val) {
	return typeof val === 'string' || Array.isArray(val) && val.length && typeof val[0] !== 'object';
}

function oneMoreLevelExists(val) {
	return typeof val === 'object' && !Array.isArray(val);
}

function identity(v) {
	return v;
}

function lineStart(indent, level) {
	return indent ? repeatString(indent, level) : '';
}

function space(indent) {
	return indent ? ' ' : '';
}

function lineEnd(indent) {
	return indent ? '\n' : '';
}

function start(sel, indent, level) {
	return lineStart(indent, level) + sel + space(indent) + '{' + lineEnd(indent);
}

function end(indent, level) {
	return lineStart(indent, level) + '}' + lineEnd(indent);
}

function rule(props, values, indent, level) {
	var linestart = lineStart(indent, level + 1);
	var lineend = lineEnd(indent);
	var s = space(indent);

	var str = '';

	for (var i = 0, propLength = props.length; i < propLength; i++) {
		for (var j = 0, valueLength = values.length; j < valueLength; j++) {
			str += linestart + props[i] + (isAtRule(props[i]) ? ' ' : ':') + s + values[j] + ';' + lineend;
		}
	}

	return str;
}

function isAtRule(prop) {
	return prop.indexOf('@') === 0;
}

},{"arrify":15,"object-assign":74,"repeat-string":84}],112:[function(require,module,exports){

/**
 * Export.
 */

module.exports = toNoCase;

/**
 * Test whether a string is camel-case.
 */

var hasSpace = /\s/;
var hasSeparator = /(_|-|\.|:)/;
var hasCamel = /([a-z][A-Z]|[A-Z][a-z])/;

/**
 * Remove any starting case from a `string`, like camel or snake, but keep
 * spaces and punctuation that may be important otherwise.
 *
 * @param {String} string
 * @return {String}
 */

function toNoCase(string) {
  if (hasSpace.test(string)) return string.toLowerCase();
  if (hasSeparator.test(string)) return (unseparate(string) || string).toLowerCase();
  if (hasCamel.test(string)) return uncamelize(string).toLowerCase();
  return string.toLowerCase();
}

/**
 * Separator splitter.
 */

var separatorSplitter = /[\W_]+(.|$)/g;

/**
 * Un-separate a `string`.
 *
 * @param {String} string
 * @return {String}
 */

function unseparate(string) {
  return string.replace(separatorSplitter, function (m, next) {
    return next ? ' ' + next : '';
  });
}

/**
 * Camelcase splitter.
 */

var camelSplitter = /(.)([A-Z]+)/g;

/**
 * Un-camelcase a `string`.
 *
 * @param {String} string
 * @return {String}
 */

function uncamelize(string) {
  return string.replace(camelSplitter, function (m, previous, uppers) {
    return previous + ' ' + uppers.toLowerCase().split('').join(' ');
  });
}

},{}],113:[function(require,module,exports){
'use strict';

var parseUnit = require('parse-unit');

module.exports = toPX;

var PIXELS_PER_INCH = 96;

function getPropertyInPX(element, prop) {
  var parts = parseUnit(getComputedStyle(element).getPropertyValue(prop));
  return parts[0] * toPX(parts[1], element);
}

//This brutal hack is needed
function getSizeBrutal(unit, element) {
  var testDIV = document.createElement('div');
  testDIV.style['font-size'] = '128' + unit;
  element.appendChild(testDIV);
  var size = getPropertyInPX(testDIV, 'font-size') / 128;
  element.removeChild(testDIV);
  return size;
}

function toPX(str, element) {
  element = element || document.body;
  str = (str || 'px').trim().toLowerCase();
  if (element === window || element === document) {
    element = document.body;
  }
  switch (str) {
    case '%':
      //Ambiguous, not sure if we should use width or height
      return element.clientHeight / 100.0;
    case 'ch':
    case 'ex':
      return getSizeBrutal(str, element);
    case 'em':
      return getPropertyInPX(element, 'font-size');
    case 'rem':
      return getPropertyInPX(document.body, 'font-size');
    case 'vw':
      return window.innerWidth / 100;
    case 'vh':
      return window.innerHeight / 100;
    case 'vmin':
      return Math.min(window.innerWidth, window.innerHeight) / 100;
    case 'vmax':
      return Math.max(window.innerWidth, window.innerHeight) / 100;
    case 'in':
      return PIXELS_PER_INCH;
    case 'cm':
      return PIXELS_PER_INCH / 2.54;
    case 'mm':
      return PIXELS_PER_INCH / 25.4;
    case 'pt':
      return PIXELS_PER_INCH / 72;
    case 'pc':
      return PIXELS_PER_INCH / 6;
  }
  return 1;
}

},{"parse-unit":77}],114:[function(require,module,exports){

var clean = require('to-no-case'

/**
 * Export.
 */

);module.exports = toSpaceCase;

/**
 * Convert a `string` to space case.
 *
 * @param {String} string
 * @return {String}
 */

function toSpaceCase(string) {
  return clean(string).replace(/[\W_]+(.|$)/g, function (matches, match) {
    return match ? ' ' + match : '';
  }).trim();
}

},{"to-no-case":112}],115:[function(require,module,exports){
var getDistance = require('gl-vec2/distance');
var EventEmitter = require('events').EventEmitter;
var dprop = require('dprop');
var eventOffset = require('mouse-event-offset');

module.exports = touchPinch;
function touchPinch(target) {
  target = target || window;

  var emitter = new EventEmitter();
  var fingers = [null, null];
  var activeCount = 0;

  var lastDistance = 0;
  var ended = false;
  var enabled = false;

  // some read-only values
  Object.defineProperties(emitter, {
    pinching: dprop(function () {
      return activeCount === 2;
    }),

    fingers: dprop(function () {
      return fingers;
    })
  });

  enable();
  emitter.enable = enable;
  emitter.disable = disable;
  emitter.indexOfTouch = indexOfTouch;
  return emitter;

  function indexOfTouch(touch) {
    var id = touch.identifier;
    for (var i = 0; i < fingers.length; i++) {
      if (fingers[i] && fingers[i].touch && fingers[i].touch.identifier === id) {
        return i;
      }
    }
    return -1;
  }

  function enable() {
    if (enabled) return;
    enabled = true;
    target.addEventListener('touchstart', onTouchStart, false);
    target.addEventListener('touchmove', onTouchMove, false);
    target.addEventListener('touchend', onTouchRemoved, false);
    target.addEventListener('touchcancel', onTouchRemoved, false);
  }

  function disable() {
    if (!enabled) return;
    enabled = false;
    activeCount = 0;
    fingers[0] = null;
    fingers[1] = null;
    lastDistance = 0;
    ended = false;
    target.removeEventListener('touchstart', onTouchStart, false);
    target.removeEventListener('touchmove', onTouchMove, false);
    target.removeEventListener('touchend', onTouchRemoved, false);
    target.removeEventListener('touchcancel', onTouchRemoved, false);
  }

  function onTouchStart(ev) {
    for (var i = 0; i < ev.changedTouches.length; i++) {
      var newTouch = ev.changedTouches[i];
      var id = newTouch.identifier;
      var idx = indexOfTouch(id);

      if (idx === -1 && activeCount < 2) {
        var first = activeCount === 0;

        // newest and previous finger (previous may be undefined)
        var newIndex = fingers[0] ? 1 : 0;
        var oldIndex = fingers[0] ? 0 : 1;
        var newFinger = new Finger();

        // add to stack
        fingers[newIndex] = newFinger;
        activeCount++;

        // update touch event & position
        newFinger.touch = newTouch;
        eventOffset(newTouch, target, newFinger.position);

        var oldTouch = fingers[oldIndex] ? fingers[oldIndex].touch : undefined;
        emitter.emit('place', newTouch, oldTouch);

        if (!first) {
          var initialDistance = computeDistance();
          ended = false;
          emitter.emit('start', initialDistance);
          lastDistance = initialDistance;
        }
      }
    }
  }

  function onTouchMove(ev) {
    var changed = false;
    for (var i = 0; i < ev.changedTouches.length; i++) {
      var movedTouch = ev.changedTouches[i];
      var idx = indexOfTouch(movedTouch);
      if (idx !== -1) {
        changed = true;
        fingers[idx].touch = movedTouch; // avoid caching touches
        eventOffset(movedTouch, target, fingers[idx].position);
      }
    }

    if (activeCount === 2 && changed) {
      var currentDistance = computeDistance();
      emitter.emit('change', currentDistance, lastDistance);
      lastDistance = currentDistance;
    }
  }

  function onTouchRemoved(ev) {
    for (var i = 0; i < ev.changedTouches.length; i++) {
      var removed = ev.changedTouches[i];
      var idx = indexOfTouch(removed);

      if (idx !== -1) {
        fingers[idx] = null;
        activeCount--;
        var otherIdx = idx === 0 ? 1 : 0;
        var otherTouch = fingers[otherIdx] ? fingers[otherIdx].touch : undefined;
        emitter.emit('lift', removed, otherTouch);
      }
    }

    if (!ended && activeCount !== 2) {
      ended = true;
      emitter.emit('end');
    }
  }

  function computeDistance() {
    if (activeCount < 2) return 0;
    return getDistance(fingers[0].position, fingers[1].position);
  }
}

function Finger() {
  this.position = [0, 0];
  this.touch = null;
}

},{"dprop":35,"events":39,"gl-vec2/distance":45,"mouse-event-offset":68}],116:[function(require,module,exports){
var offset = require('mouse-event-offset');
var EventEmitter = require('events').EventEmitter;

function attach(opt) {
  opt = opt || {};
  var element = opt.element || window;

  var emitter = new EventEmitter();

  var position = opt.position || [0, 0];
  if (opt.touchstart !== false) {
    element.addEventListener('mousedown', update, false);
    element.addEventListener('touchstart', updateTouch, false);
  }

  element.addEventListener('mousemove', update, false);
  element.addEventListener('touchmove', updateTouch, false);

  emitter.position = position;
  emitter.dispose = dispose;
  return emitter;

  function updateTouch(ev) {
    var touch = ev.targetTouches[0];
    update(touch);
  }

  function update(ev) {
    offset(ev, element, position);
    emitter.emit('move', ev);
  }

  function dispose() {
    element.removeEventListener('mousemove', update, false);
    element.removeEventListener('mousedown', update, false);
    element.removeEventListener('touchmove', updateTouch, false);
    element.removeEventListener('touchstart', updateTouch, false);
  }
}

module.exports = function (opt) {
  return attach(opt).position;
};

module.exports.emitter = function (opt) {
  return attach(opt);
};

},{"events":39,"mouse-event-offset":68}],117:[function(require,module,exports){

exports = module.exports = trim;

function trim(str) {
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function (str) {
  return str.replace(/^\s*/, '');
};

exports.right = function (str) {
  return str.replace(/\s*$/, '');
};

},{}],118:[function(require,module,exports){

/**
 * @module typedarray-polyfill
 */

var methods = ['values', 'sort', 'some', 'slice', 'reverse', 'reduceRight', 'reduce', 'map', 'keys', 'lastIndexOf', 'join', 'indexOf', 'includes', 'forEach', 'find', 'findIndex', 'copyWithin', 'filter', 'entries', 'every', 'fill'];

if (typeof Int8Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Int8Array.prototype[method]) Int8Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Uint8Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Uint8Array.prototype[method]) Uint8Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Uint8ClampedArray !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Uint8ClampedArray.prototype[method]) Uint8ClampedArray.prototype[method] = Array.prototype[method];
    }
}
if (typeof Int16Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Int16Array.prototype[method]) Int16Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Uint16Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Uint16Array.prototype[method]) Uint16Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Int32Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Int32Array.prototype[method]) Int32Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Uint32Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Uint32Array.prototype[method]) Uint32Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Float32Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Float32Array.prototype[method]) Float32Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof Float64Array !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!Float64Array.prototype[method]) Float64Array.prototype[method] = Array.prototype[method];
    }
}
if (typeof TypedArray !== 'undefined') {
    for (var i = methods.length; i--;) {
        var method = methods[i];
        if (!TypedArray.prototype[method]) TypedArray.prototype[method] = Array.prototype[method];
    }
}

},{}],119:[function(require,module,exports){
arguments[4][10][0].apply(exports,arguments)
},{"bit-twiddle":18,"buffer":19,"dup":10}],120:[function(require,module,exports){
'use strict';

require('enable-mobile');
const createScatter = require('./');
const panZoom = require('pan-zoom');
const createSettings = require('settings-panel');
const fps = require('fps-indicator')({ css: `padding: 1.4rem` });
const random = require('gauss-random');
const cluster = require('../point-cluster');
const rgba = require('color-rgba');

let N = 5e4;
let scatter = createScatter({
	positions: generate(N),
	// positions: [0,0, 1,1, -1,-1, 1,-1, -1,1, 0,1, 0,-1, 1,0, -1,0],

	size: Array(N).fill(15).map(x => Math.random() * x),
	// size: 10,
	color: Array(N).fill(0).map(() => [Math.random(), Math.random(), Math.random(), Math.random()]),
	// color: 'rgba(0, 10, 10, .3)',

	borderSize: 0,
	cluster: false,
	borderColor: [.1, .2, .3, 1]
}).autorange();

scatter.draw

/*
let settings = createSettings([
	{type: 'number', label: '№ points', min: 1, max: 1e8, log: true, value: 1e4, change: value => {
		let positions = generate(value)
		// let positions = [0,0, 1,1, -1,-1, 1,-1, -1,1, 0,1, 0,-1, 1,0, -1,0]

		// let from = lod[6].offset, to = from + lod[6].count
		scatter
		.update(positions)
		.autorange()
		.clear()
		.draw()
	}},
	{type: 'interval', label: 'Size', min: 1, max: 50, value: [10,10], step: .5, change: value => {
		//same size
		if (value[0] === value[1]) {
			scatter.update({
				size: value[0]
			})
			.clear()
			.draw()
			return
		}

		let sizes = []
		for (let i = 0, l = scatter.positions.length/2; i < l; i++) {
			sizes.push(Math.random() * (value[1] - value[0]) + value[0])
		}
		scatter.update({
			size: sizes
		})
		.clear()
		.draw()
	}},
	{type: 'checkbox', label: 'Multicolor', value: false, change: v => {
		if (v) {
			//generate colors
			let colors = Array(scatter.positions.length/2).fill(0).map(() =>
				[Math.random(), Math.random(), Math.random(), Math.random()]
			)
			scatter.update({color: colors})
		}
		else {
			let color = Array(4).fill(0).map(Math.random)
			scatter.update({color: color})
		}
		scatter.draw()
	}}
], {
	theme: require('settings-panel/theme/control'),
	style: `
	bottom: 0;
	left: 0;
	right: 0;
	width: 340px;
	margin: auto;
	min-width: 240px;
	position: absolute;
	background: none;
	font-family: Roboto, sans-serif;
	font-weight: 300;
	`
})
*/

//interactions
();let canvas = scatter.canvas;
panZoom(canvas, e => {
	let w = canvas.width;
	let h = canvas.height;
	let scale = scatter.scale;
	let translate = scatter.translate;

	translate[0] += e.dx / scale[0] / w;
	translate[1] -= e.dy / scale[1] / h;

	let prevScale = scale.slice();

	scale[0] -= scale[0] * e.dz / w;
	scale[1] -= scale[1] * e.dz / w;

	let rx = e.x / w;
	let ry = e.y / h;

	translate[0] += e.x / scale[0] / w - e.x / prevScale[0] / w;
	translate[1] += (h - e.y) / scale[1] / h - (h - e.y) / prevScale[1] / h;
	scatter.update({
		scale: e.dz ? scale : null,
		translate: translate
	});

	scatter.clear();
	scatter.draw();
});

function generate(N) {
	var positions = new Float32Array(2 * N);

	for (var i = 0; i < 2 * N; ++i) {
		positions[i] = random();
	}

	return positions;
}

},{"../point-cluster":1,"./":11,"color-rgba":27,"enable-mobile":38,"fps-indicator":41,"gauss-random":42,"pan-zoom":75,"settings-panel":91}]},{},[120]);
</script>
</html>
